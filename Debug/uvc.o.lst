   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2_480.h"//
  65:../uvc.c      **** #include "cyfxgpif2config_usb2_640.h"//
  66:../uvc.c      **** #else
  67:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  68:../uvc.c      **** #endif
  69:../uvc.c      **** #else
  70:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  71:../uvc.c      **** #endif
  72:../uvc.c      **** 
  73:../uvc.c      **** #include "cmdqu.h"
  74:../uvc.c      **** 
  75:../uvc.c      **** #define  NOQU    //for queue debug
  76:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  77:../uvc.c      **** 
  78:../uvc.c      **** /*************************************************************************************************
  79:../uvc.c      ****                                          Global Variables
  80:../uvc.c      ****  *************************************************************************************************/
  81:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  82:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  83:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  85:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  86:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  87:../uvc.c      **** 
  88:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  89:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  90:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  91:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  92:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  93:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  94:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  95:../uvc.c      **** CyU3PMutex       cmdQuMux;
  96:../uvc.c      **** CyU3PMutex       staQuMux;
  97:../uvc.c      **** CyU3PMutex       timMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0,takeFull=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** 
 106:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 107:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 108:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 109:../uvc.c      ****                                                            received. */
 110:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 111:../uvc.c      **** #ifdef BACKFLOW_DETECT
 112:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 113:../uvc.c      **** #endif
 114:../uvc.c      **** 
 115:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 116:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 117:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 118:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 119:../uvc.c      **** #endif
 120:../uvc.c      **** 
 121:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 122:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 123:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 126:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 127:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 128:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 129:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 130:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 131:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 132:../uvc.c      ****                                    with adjustable compression parameters */
 133:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 134:../uvc.c      ****                                    streaming with adjustable compression parameters */
 135:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 136:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 137:../uvc.c      ****     0x00, 0x0C, 0x00, 0x00 //0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single pa
 138:../uvc.c      **** };
 139:../uvc.c      **** 
 140:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 141:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 142:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 144:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 145:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 146:../uvc.c      ****     0x00, 0x0C, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 147:../uvc.c      **** };
 148:../uvc.c      **** 
 149:../uvc.c      **** 
 150:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 151:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 152:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 154:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 155:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 156:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 157:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 158:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 159:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 160:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 161:../uvc.c      ****                                    with adjustable compression parameters */
 162:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 163:../uvc.c      ****                                    streaming with adjustable compression parameters */
 164:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 165:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x0C, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 170:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 171:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 172:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 173:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 174:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 175:../uvc.c      ****     0x00, 0x0C, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 176:../uvc.c      **** };
 177:../uvc.c      **** 
 178:../uvc.c      **** 
 179:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 180:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 181:../uvc.c      **** 
 182:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 183:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 184:../uvc.c      **** {
 185:../uvc.c      ****     0x0C,                               /* Header Length */
 186:../uvc.c      ****     0x8C,                               /* Bit field header field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 188:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 189:../uvc.c      **** };
 190:../uvc.c      **** 
 191:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 192:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 193:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 194:../uvc.c      ****                                                            the current video frame. */
 195:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 196:../uvc.c      **** #define isWBMamu   0  // Is white balance control manual mode.
 197:../uvc.c      **** 
 198:../uvc.c      **** /************ control parameters array ***********
 199:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 200:../uvc.c      ****  *    e.g.
 201:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 202:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 203:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 204:../uvc.c      ****  **************************************************/
 205:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 206:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 207:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 208:../uvc.c      **** 		{BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,
 209:../uvc.c      **** 		{BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  255,    0, 1, 0, 3, 0, 118, 0, 118,
 210:../uvc.c      **** 		{ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0, 112,
 211:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 212:../uvc.c      **** 		{MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,   1,
 213:../uvc.c      **** 		{HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,   0,
 214:../uvc.c      **** 		{SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,  50,
 215:../uvc.c      **** 		{SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 216:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 217:../uvc.c      **** 		{WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 218:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,   0,
 219:../uvc.c      **** 		{ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,  32,
 220:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 221:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 222:../uvc.c      **** 		{DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,   0,
 223:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 224:../uvc.c      **** 		{ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0,   0,
 225:../uvc.c      **** 		{SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0,   1,
 226:../uvc.c      **** 		{MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   2,
 227:../uvc.c      **** 		{NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,   0,
 228:../uvc.c      **** 		{NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 229:../uvc.c      **** 		{DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0,
 230:../uvc.c      **** 		{DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0,   0,
 231:../uvc.c      **** 		{DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 232:../uvc.c      **** 		{NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 233:../uvc.c      **** 		{AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32,   0,
 234:../uvc.c      **** 		{AExReferleveReg     , AExReferleveReg      , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 235:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0,   0,
 236:../uvc.c      **** 		{SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0,   3,
 237:../uvc.c      **** 		{0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 238:../uvc.c      **** 		{SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 239:../uvc.c      **** 		/**********************************
 240:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 241:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 242:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 243:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 244:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 245:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 246:../uvc.c      **** 		 *
 247:../uvc.c      **** 		 *********************************/
 248:../uvc.c      **** 		{0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 0,   0
 249:../uvc.c      **** };
 250:../uvc.c      **** 
 251:../uvc.c      **** #ifndef CAM720
 252:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 253:../uvc.c      **** #else
 254:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 255:../uvc.c      **** #endif
 256:../uvc.c      **** 
 257:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 258:../uvc.c      **** 		{0x13/*Ext1BLCRangeCtlID0 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0, 0x23
 259:../uvc.c      **** 		{0x11/*Ext1BLCWeightCtlID1*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,   1, 
 260:../uvc.c      **** 		{0x17/*Ext1BLCGridCtlID2*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0, 
 261:../uvc.c      **** 		{0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,0x4
 262:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,   0,
 263:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,   0,
 264:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,   0,
 265:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0xa,
 266:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,   0,
 267:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 268:../uvc.c      **** 		{0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0,   0,
 269:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 270:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 271:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 272:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 273:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 274:../uvc.c      **** };
 275:../uvc.c      **** 
 276:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 277:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 278:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 279:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 280:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 281:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 282:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 283:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 284:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 285:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 286:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 287:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 288:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 289:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 290:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 291:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 292:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 293:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 294:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 295:../uvc.c      **** };
 296:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 297:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 298:../uvc.c      **** /*
 299:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 300:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 301:../uvc.c      ****  */
 302:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 303:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 304:../uvc.c      **** };
 305:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 306:../uvc.c      **** 		0
 307:../uvc.c      **** };
 308:../uvc.c      **** 
 309:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 310:../uvc.c      **** 
 311:../uvc.c      **** void I2CCmdHandler(){
 312:../uvc.c      **** 	uint8_t buf[2];
 313:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 314:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 315:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 316:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 317:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 318:../uvc.c      **** 
 319:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 320:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 321:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 322:../uvc.c      **** 
 323:../uvc.c      **** 	if(CmdType == 0)//I2C read
 324:../uvc.c      **** 	{
 325:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 326:../uvc.c      **** #if 0 //for debugging
 327:../uvc.c      **** 		/* test still image operation */
 328:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 329:../uvc.c      **** 			snapButFlag = 0; //press
 330:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 331:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 332:../uvc.c      **** 			snapButFlag = 0xf; //release
 333:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 334:../uvc.c      **** 		}
 335:../uvc.c      **** 
 336:../uvc.c      **** 		/* end of the test */
 337:../uvc.c      **** #endif
 338:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 339:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 340:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 341:../uvc.c      **** 			if(CmdDataLen == 2){
 342:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 343:../uvc.c      **** 			}
 344:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 345:../uvc.c      **** 		}else{//not support currently
 346:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 347:../uvc.c      **** 		}
 348:../uvc.c      **** 	}else if(CmdType == 1){
 349:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 350:../uvc.c      **** 			if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 351:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 352:../uvc.c      **** 				cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 353:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 354:../uvc.c      **** 			}
 355:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 356:../uvc.c      **** 		}else{//not support currently
 357:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 358:../uvc.c      **** 		}
 359:../uvc.c      **** 
 360:../uvc.c      **** 	}
 361:../uvc.c      **** }
 362:../uvc.c      **** 
 363:../uvc.c      **** /************************************
 364:../uvc.c      ****  * set Iris mode
 365:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 366:../uvc.c      ****  */
 367:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 368:../uvc.c      **** 	uint8_t dataIdx;
 369:../uvc.c      **** 	  dataIdx = 0;
 370:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 371:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 372:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 373:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 374:../uvc.c      **** }
 375:../uvc.c      **** 
 376:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 377:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 378:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 379:../uvc.c      ****     uint16_t readCount;
 380:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 381:../uvc.c      ****     uint8_t devAdd;
 382:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 383:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 384:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 385:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 386:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 387:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 388:../uvc.c      ****     }else{
 389:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 390:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 391:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 392:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 393:../uvc.c      ****     }
 394:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 395:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 396:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 397:../uvc.c      **** #endif
 398:../uvc.c      ****     reqData = bRequest;
 399:../uvc.c      ****     /*
 400:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 401:../uvc.c      ****      */
 402:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 403:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 404:../uvc.c      ****     	goto EndofSet;
 405:../uvc.c      ****     }
 406:../uvc.c      ****     switch (bRequest)
 407:../uvc.c      **** 		 {
 408:../uvc.c      **** 
 409:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 410:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 411:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 412:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 413:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 414:../uvc.c      **** 			  break;
 415:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 416:../uvc.c      **** 
 417:../uvc.c      **** 			 switch(CtrlID)
 418:../uvc.c      **** 			 {
 419:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 420:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID0:
 421:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID1:
 422:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID2:
 423:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 424:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 425:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 426:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 427:../uvc.c      **** 			 	 		 break;
 428:../uvc.c      **** 			 	 }
 429:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 430:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 431:../uvc.c      **** 					 if(CamMode == 1){//720p
 432:../uvc.c      **** 						if(sendData >= 3){
 433:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 434:../uvc.c      **** 							sendData = 0; //set back to default
 435:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 436:../uvc.c      **** 						}
 437:../uvc.c      **** 						sendData += 4;
 438:../uvc.c      **** 					 }
 439:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 440:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 441:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 442:../uvc.c      **** 					 break;
 443:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 444:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 445:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 446:../uvc.c      **** 			 		 }
 447:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 448:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 449:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 450:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 451:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 452:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 453:../uvc.c      **** #endif
 454:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 455:../uvc.c      **** 			 		 {
 456:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 457:../uvc.c      **** 			 		 }
 458:../uvc.c      **** 			 		 break;
 459:../uvc.c      **** 				 case ExtAexModCtlID9:
 460:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 461:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 462:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 463:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 464:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 465:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 466:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 467:../uvc.c      **** 					 break;
 468:../uvc.c      **** 
 469:../uvc.c      **** 			 	 case BrgtCtlID1:
 470:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 471:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 472:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 473:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 474:../uvc.c      **** 					 }else{
 475:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 476:../uvc.c      **** 					 }
 477:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 478:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 479:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 480:../uvc.c      **** 					 break;
 481:../uvc.c      **** 				 case HueCtlID5:
 482:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 483:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 484:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 485:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 486:../uvc.c      **** 					 break;
 487:../uvc.c      **** 				 case WBTLevCtlID11:
 488:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 489:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 490:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 491:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 492:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 493:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 494:../uvc.c      **** 					 break;
 495:../uvc.c      **** 				 case SaturCtlID6:
 496:../uvc.c      **** 				 default:
 497:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 498:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 499:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 500:../uvc.c      **** 					 break;
 501:../uvc.c      **** 			 }
 502:../uvc.c      **** 
 503:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 504:../uvc.c      **** 
 505:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 506:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 507:../uvc.c      **** #endif
 508:../uvc.c      **** 			  break;
 509:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 510:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 511:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 512:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 513:../uvc.c      **** 		 	 }
 514:../uvc.c      **** 
 515:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 516:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 517:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 518:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 519:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 520:../uvc.c      **** 			 }else
 521:../uvc.c      **** 			 {
 522:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 523:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 524:../uvc.c      **** 			 }
 525:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 526:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 527:../uvc.c      **** 			  break;
 528:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 529:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 530:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 531:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 532:../uvc.c      **** 		 	 }
 533:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 534:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 535:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 536:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 537:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 538:../uvc.c      **** 			 }else
 539:../uvc.c      **** 			 {
 540:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 541:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 542:../uvc.c      **** 			 }
 543:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 544:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 545:../uvc.c      **** 			  break;
 546:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 547:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 548:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 549:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 550:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 551:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 552:../uvc.c      **** 		 	 }
 553:../uvc.c      **** 		 	 else{
 554:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 555:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 556:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 557:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 558:../uvc.c      **** 		 	 }
 559:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 560:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 561:../uvc.c      **** 			  break;
 562:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 563:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 564:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 565:../uvc.c      **** 		 	 }
 566:../uvc.c      **** 		 	 else{
 567:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 568:../uvc.c      **** 		 	 }
 569:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 570:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 571:../uvc.c      **** 			  Len = 1;
 572:../uvc.c      **** 			  break;
 573:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 574:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 575:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 576:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 577:../uvc.c      **** 		 	 }
 578:../uvc.c      **** 
 579:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 580:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 581:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 582:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 583:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 584:../uvc.c      **** 			 }else{
 585:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 586:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 587:../uvc.c      **** 			 }
 588:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 589:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 590:../uvc.c      **** 			  break;
 591:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 592:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 593:../uvc.c      **** 				  glEp0Buffer, &readCount);
 594:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 595:../uvc.c      **** 			   {
 596:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 597:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 598:../uvc.c      **** 				  getData = glEp0Buffer[0];
 599:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 600:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 601:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 602:../uvc.c      **** #endif
 603:../uvc.c      **** 				  switch(CtrlID)
 604:../uvc.c      **** 					 {
 605:../uvc.c      **** 						 case ExtShutCtlID0:
 606:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 607:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 608:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 609:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 610:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 611:../uvc.c      **** 									 }else{
 612:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 613:../uvc.c      **** 									 }
 614:../uvc.c      **** 								 }
 615:../uvc.c      **** 							 }else{
 616:../uvc.c      **** 								 Data1 = Data0 - 1;
 617:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 618:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 619:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 620:../uvc.c      **** 									 }else{
 621:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 622:../uvc.c      **** 									 }
 623:../uvc.c      **** 								 }
 624:../uvc.c      **** 								 if(Data1 < 8){
 625:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 626:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 627:../uvc.c      **** 								 }else{
 628:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 629:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 630:../uvc.c      **** 								 }
 631:../uvc.c      **** 							 }
 632:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 633:../uvc.c      **** 							 dataIdx = 0;
 634:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 635:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 636:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 637:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 638:../uvc.c      **** 							 break;
 639:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 640:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 641:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 642:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 643:../uvc.c      **** 							 dataIdx = 0;
 644:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 645:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 646:../uvc.c      **** 							 if(getData != 0){
 647:../uvc.c      **** 								 dataIdx++;
 648:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 649:../uvc.c      **** 							 }
 650:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 651:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 652:../uvc.c      **** 							 break;
 653:../uvc.c      **** 						 case ExtCamMCtlID12:
 654:../uvc.c      **** 							 dataIdx = 0;
 655:../uvc.c      **** 							 if(Data0 <= 3){
 656:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 657:../uvc.c      **** 								 Data1 = Data0;
 658:../uvc.c      **** 							 }else{
 659:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 660:../uvc.c      **** 								 Data1 = Data0-4;
 661:../uvc.c      **** 							 }
 662:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 663:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 664:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 665:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 666:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 667:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 668:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 669:../uvc.c      **** 							 break;
 670:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 671:../uvc.c      **** 							 dataIdx = 0;
 672:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 673:../uvc.c      **** 								 Data0 = 1;
 674:../uvc.c      **** 							 }else{ //save current sensor parameters.
 675:../uvc.c      **** 								 Data0 = 0;
 676:../uvc.c      **** 							 }
 677:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 678:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 679:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 680:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 681:../uvc.c      **** 							 break;
 682:../uvc.c      **** 						 case ExtI2CCtlID15:
 683:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 684:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 685:../uvc.c      **** 					 		 }
 686:../uvc.c      **** 					 		I2CCmdHandler();
 687:../uvc.c      **** 							 break;
 688:../uvc.c      **** 						 case Ext1BLCRangeCtlID0: //registers value BLD window enable (0x17); position (0x13); size (
 689:../uvc.c      **** 							 dataIdx = 0;
 690:../uvc.c      **** #if 0 //seperate version
 691:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 692:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 693:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 694:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 695:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 696:../uvc.c      **** 							 }else{ //disable BLD window
 697:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 698:../uvc.c      **** 							 }
 699:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 700:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 701:../uvc.c      **** 							 dataIdx++;
 702:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 703:../uvc.c      **** 							 dataIdx++;
 704:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 705:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 706:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 707:../uvc.c      **** 							 dataIdx++;
 708:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 709:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 710:../uvc.c      **** #else //combination version
 711:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 712:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 713:../uvc.c      **** 						     /* end test */
 714:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 715:../uvc.c      **** 							 dataIdx++;
 716:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 717:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 718:../uvc.c      **** 							 getData1 = Data1;
 719:../uvc.c      **** #endif
 720:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 721:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 722:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 723:../uvc.c      **** 							 break;
 724:../uvc.c      **** 						 case Ext1BLCWeightCtlID1: //register value 0x11 (need check).
 725:../uvc.c      **** 							 dataIdx = 0;
 726:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 727:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 728:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 729:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 730:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 731:../uvc.c      **** 							 break;
 732:../uvc.c      **** 						 case Ext1BLCGridCtlID2:
 733:../uvc.c      **** 							 dataIdx = 0;
 734:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 735:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 736:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 737:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 738:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 739:../uvc.c      **** 							 break;
 740:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 741:../uvc.c      **** 							 dataIdx = 0;
 742:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 743:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 744:../uvc.c      **** 							  if(Data0&0x80){
 745:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 746:../uvc.c      **** 							  }else{
 747:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 748:../uvc.c      **** 							  }
 749:../uvc.c      **** 							 Data1 |= ~0x03;
 750:../uvc.c      **** 							 Data1 &= 0xC7;
 751:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 752:../uvc.c      **** 						  	 dataIdx++;
 753:../uvc.c      **** 
 754:../uvc.c      **** 							 Data0 = (Data0 << 2);
 755:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 756:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 757:../uvc.c      **** 
 758:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 759:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 760:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 761:../uvc.c      **** 
 762:../uvc.c      **** 							 break;
 763:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 764:../uvc.c      **** 							 dataIdx = 0;
 765:../uvc.c      **** 
 766:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 767:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 768:../uvc.c      **** 							 dataIdx++;
 769:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 770:../uvc.c      **** 							 dataIdx++;
 771:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 772:../uvc.c      **** 							 dataIdx++;
 773:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 774:../uvc.c      **** 							 dataIdx++;
 775:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 776:../uvc.c      **** 							 dataIdx++;
 777:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 778:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 779:../uvc.c      **** 
 780:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 781:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 782:../uvc.c      **** 							 break;
 783:../uvc.c      **** 						 case SaturCtlID6:
 784:../uvc.c      **** 							 dataIdx = 0;
 785:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 786:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 787:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 788:../uvc.c      **** 							 dataIdx++;
 789:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 790:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 791:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 792:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 793:../uvc.c      **** 							 break;
 794:../uvc.c      **** 
 795:../uvc.c      **** 						 case WBTLevCtlID11:
 796:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 797:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 798:../uvc.c      **** 							 dataIdx = 0;
 799:../uvc.c      **** 
 800:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 801:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 802:../uvc.c      **** 							 dataIdx++;
 803:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 804:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 805:../uvc.c      **** 
 806:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 807:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 808:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 809:../uvc.c      **** 							 break;
 810:../uvc.c      **** 						 case MFreqCtlID4:
 811:../uvc.c      **** 							 dataIdx = 0;
 812:../uvc.c      **** 							 Data0 = Data0 - 1;
 813:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 814:../uvc.c      **** 								 Data0 = 0;
 815:../uvc.c      **** 							 else if(Data0 >2)
 816:../uvc.c      **** 								 Data0 = 1;
 817:../uvc.c      **** 
 818:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 819:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 820:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 821:../uvc.c      **** 
 822:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 823:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 824:../uvc.c      **** 							 break;
 825:../uvc.c      **** 					 	 case BLCCtlID0:
 826:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 827:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 828:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 829:../uvc.c      **** 							 {
 830:../uvc.c      **** 								 if(Data0 < 3){
 831:../uvc.c      **** 					 				 Data0 += 4;
 832:../uvc.c      **** 					 			 }else{
 833:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 834:../uvc.c      **** 									Data0 = 4; //set to default.
 835:../uvc.c      **** 					 			 }
 836:../uvc.c      **** 					 		 }
 837:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 838:../uvc.c      **** 							 dataIdx = 0;
 839:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 840:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 841:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 842:../uvc.c      **** 
 843:../uvc.c      **** 					 		 break;
 844:../uvc.c      **** 						 default:
 845:../uvc.c      **** 							 dataIdx = 0;
 846:../uvc.c      **** 
 847:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 849:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 850:../uvc.c      **** 
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 852:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 853:../uvc.c      **** 							 break;
 854:../uvc.c      **** 					 }
 855:../uvc.c      **** 			   }else{
 856:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 857:../uvc.c      **** 			   }
 858:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 859:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 860:../uvc.c      **** #endif
 861:../uvc.c      **** 
 862:../uvc.c      **** 			  break;
 863:../uvc.c      **** 		  default:
 864:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 865:../uvc.c      **** 			  break;
 866:../uvc.c      **** 		 }
 867:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 868:../uvc.c      **** }
 869:../uvc.c      **** /************** CT control requests handler *************************/
 870:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 871:../uvc.c      **** 
 872:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 873:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 874:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 875:../uvc.c      ****     uint16_t readCount;
 876:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 877:../uvc.c      ****     uint16_t diff, value, diffRd;
 878:../uvc.c      ****     uint8_t i, shutter, index;
 879:../uvc.c      ****     diff = 0xffff;
 880:../uvc.c      ****     shutter = 1;
 881:../uvc.c      ****     index = 1;
 882:../uvc.c      **** 
 883:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 884:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 885:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 886:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 887:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 888:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 889:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 890:../uvc.c      **** #endif
 891:../uvc.c      ****     reqData = bRequest;
 892:../uvc.c      **** 
 893:../uvc.c      ****     switch (bRequest)
 894:../uvc.c      **** 		 {
 895:../uvc.c      **** 
 896:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 897:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 898:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 899:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 900:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 901:../uvc.c      **** 			  break;
 902:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 903:../uvc.c      **** 
 904:../uvc.c      **** 			 switch(CtrlID)
 905:../uvc.c      **** 			 {
 906:../uvc.c      **** 				 default:
 907:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 908:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 909:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 910:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 911:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 912:../uvc.c      **** 					 break;
 913:../uvc.c      **** 			 }
 914:../uvc.c      **** 
 915:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 916:../uvc.c      **** 
 917:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 918:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
 919:../uvc.c      **** #endif
 920:../uvc.c      **** 			  break;
 921:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 922:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 923:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 924:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 925:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 926:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 927:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 928:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 929:../uvc.c      **** 			  break;
 930:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 931:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 932:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 933:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 934:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 935:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 936:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 937:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 938:../uvc.c      **** 			  break;
 939:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 940:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 941:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 942:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 943:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 944:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 945:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 946:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 947:../uvc.c      **** 			  break;
 948:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 949:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 950:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 951:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 952:../uvc.c      **** 			  Len = 1;
 953:../uvc.c      **** 			  break;
 954:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 955:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 956:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 957:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 958:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 959:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 960:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 961:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 962:../uvc.c      **** 			  break;
 963:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 964:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 965:../uvc.c      **** 			  glEp0Buffer, &readCount);
 966:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 967:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 968:../uvc.c      **** 			  value = Data1;
 969:../uvc.c      **** 
 970:../uvc.c      **** 			  switch(CtrlID)
 971:../uvc.c      **** 			  {
 972:../uvc.c      **** 		  	      case AutoExMCtlID1:
 973:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
 974:../uvc.c      **** 
 975:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 976:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 977:../uvc.c      **** 				    getData = glEp0Buffer[0];
 978:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
 979:../uvc.c      **** 		  		    switch (getData){
 980:../uvc.c      **** 						case 1:
 981:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
 982:../uvc.c      **** 							break;
 983:../uvc.c      **** 						case 2:
 984:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 985:../uvc.c      **** 							dataIdx = 0;
 986:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 987:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 988:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 989:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 990:../uvc.c      **** 
 991:../uvc.c      **** 							break;
 992:../uvc.c      **** 						case 4:
 993:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
 994:../uvc.c      **** 							break;
 995:../uvc.c      **** 						case 8:
 996:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 997:../uvc.c      **** 			  		    	dataIdx = 0;
 998:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 999:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1000:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1001:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1002:../uvc.c      **** 							break;
1003:../uvc.c      **** 		  		    }
1004:../uvc.c      **** #if 0
1005:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1006:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1007:../uvc.c      **** 						  dataIdx = 0;
1008:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1009:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1010:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1011:../uvc.c      **** 		  		    }
1012:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1013:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1014:../uvc.c      **** 		  		    }
1015:../uvc.c      **** #endif
1016:../uvc.c      **** 				    break;
1017:../uvc.c      **** 
1018:../uvc.c      **** 			  	  case ExTmACtlID3:
1019:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1020:../uvc.c      **** 
1021:../uvc.c      **** 					  value = (value << 8)|Data0;
1022:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1023:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1024:../uvc.c      **** 					  {
1025:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1026:../uvc.c      **** 						  {
1027:../uvc.c      **** 							if(value > ShutValueArry[i]){
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1029:../uvc.c      **** 							}else{
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1031:../uvc.c      **** 							}
1032:../uvc.c      **** 							  if(diff > diffRd){
1033:../uvc.c      **** 								  diff = diffRd;
1034:../uvc.c      **** 								  index = i;
1035:../uvc.c      **** 							  }
1036:../uvc.c      **** 						  }
1037:../uvc.c      **** 						  shutter = shutter+index;
1038:../uvc.c      **** 
1039:../uvc.c      **** 						  dataIdx = 0;
1040:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1041:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1042:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1043:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1044:../uvc.c      **** 
1045:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1046:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1047:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1048:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1049:../uvc.c      **** 					  }else{
1050:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1051:../uvc.c      **** 					  }
1052:../uvc.c      **** 					  getData = glEp0Buffer[0];
1053:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1054:../uvc.c      **** 					  break;
1055:../uvc.c      **** 			  	  case IriACtlID7:
1056:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1057:../uvc.c      **** 					  {
1058:../uvc.c      **** 							 dataIdx = 0;
1059:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1060:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
1061:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1062:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1063:../uvc.c      **** 
1064:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1065:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1066:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1067:../uvc.c      **** 					  }else{
1068:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1069:../uvc.c      **** 					  }
1070:../uvc.c      **** 					  getData = glEp0Buffer[0];
1071:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1072:../uvc.c      **** 
1073:../uvc.c      **** 					  break;
1074:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1075:../uvc.c      **** 					  getData = glEp0Buffer[0];
1076:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1077:../uvc.c      **** #if 1
1078:../uvc.c      **** 					  dataIdx = 0;
1079:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1080:../uvc.c      **** 					  if(getData == 1)
1081:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1082:../uvc.c      **** 					  else if(getData == 0xff)
1083:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1084:../uvc.c      **** 					  else
1085:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
1086:../uvc.c      **** 					  //dataIdx++;
1087:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1088:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1089:../uvc.c      **** #endif
1090:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1091:../uvc.c      **** 					  break;
1092:../uvc.c      **** 
1093:../uvc.c      **** 			  	  default:
1094:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1095:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1096:../uvc.c      **** 			  		 break;
1097:../uvc.c      **** 			  }
1098:../uvc.c      **** 			  break;
1099:../uvc.c      **** 		  default:
1100:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1101:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1102:../uvc.c      **** 			  break;
1103:../uvc.c      **** 		 }
1104:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1105:../uvc.c      **** 
1106:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1107:../uvc.c      **** }
1108:../uvc.c      **** 
1109:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1110:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1111:../uvc.c      **** {
1112:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1113:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1114:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1115:../uvc.c      **** 
1116:../uvc.c      ****     CtrlID = BrgtCtlID1;
1117:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1118:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1119:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1120:../uvc.c      ****     Data1 = Data0;
1121:../uvc.c      **** 
1122:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1123:../uvc.c      ****     if(Data1&0x80){
1124:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1125:../uvc.c      ****     }else{
1126:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1127:../uvc.c      ****     }
1128:../uvc.c      ****     Data0 = (Data0 << 2);
1129:../uvc.c      **** 
1130:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1131:../uvc.c      **** 
1132:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1133:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1134:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1135:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1136:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1137:../uvc.c      **** 
1138:../uvc.c      ****     CtrlID = ConsCtlID2;
1139:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1140:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1141:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1142:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1143:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1144:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1145:../uvc.c      **** 
1146:../uvc.c      ****     CtrlID = HueCtlID5;
1147:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1148:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1149:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1150:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1151:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1152:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1153:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1154:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1155:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1156:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1157:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1158:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1159:../uvc.c      **** 
1160:../uvc.c      ****     CtrlID = SaturCtlID6;
1161:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1162:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1163:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1164:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1165:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1166:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1167:../uvc.c      **** 
1168:../uvc.c      ****     CtrlID = ShapCtlID7;
1169:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1170:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1171:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1172:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1173:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1174:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1175:../uvc.c      **** 
1176:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1177:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1178:../uvc.c      **** 	return;
1179:../uvc.c      **** }
1180:../uvc.c      **** 
1181:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1182:../uvc.c      **** void
1183:../uvc.c      **** CyFxUVCAddHeader (
1184:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1185:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1186:../uvc.c      ****         )
1187:../uvc.c      **** {
1188:../uvc.c      ****     /* Copy header to buffer */
1189:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1190:../uvc.c      **** 
1191:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1192:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1193:../uvc.c      ****     {
1194:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1195:../uvc.c      ****     }
1196:../uvc.c      **** }
1197:../uvc.c      **** 
1198:../uvc.c      **** 
1199:../uvc.c      **** /* Application Error Handler */
1200:../uvc.c      **** void
1201:../uvc.c      **** CyFxAppErrorHandler (
1202:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1203:../uvc.c      ****         )
1204:../uvc.c      **** {
1205:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1206:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1207:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1208:../uvc.c      **** 
1209:../uvc.c      ****        This function can be modified to take additional error handling actions such
1210:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1211:../uvc.c      ****      */
1212:../uvc.c      ****     for (;;)
1213:../uvc.c      ****     {
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
1215:../uvc.c      ****         for(;;){}
1216:../uvc.c      ****         CyU3PThreadSleep (1000);
1217:../uvc.c      ****     }
1218:../uvc.c      **** }
1219:../uvc.c      **** 
1220:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1221:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1222:../uvc.c      ****  */
1223:../uvc.c      **** static void
1224:../uvc.c      **** CyFxUVCApplnAbortHandler (
1225:../uvc.c      ****         void)
1226:../uvc.c      **** {
1227:../uvc.c      **** 	uint32_t flag;
1228:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1229:../uvc.c      **** 	{
1230:../uvc.c      ****         /* Clear the Video Stream Request Event */
1231:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1232:../uvc.c      **** 
1233:../uvc.c      ****         /* Set Video Stream Abort Event */
1234:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1235:../uvc.c      **** 	}
1236:../uvc.c      **** }
1237:../uvc.c      **** 
1238:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1239:../uvc.c      **** static void
1240:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1241:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1242:../uvc.c      ****         uint16_t             evdata  /* Event data */
1243:../uvc.c      ****         )
1244:../uvc.c      **** {
1245:../uvc.c      ****     switch (evtype)
1246:../uvc.c      ****     {
1247:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1248:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1249:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1250:../uvc.c      ****             gpif_initialized = 0;
1251:../uvc.c      ****             streamingStarted = CyFalse;
1252:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1253:../uvc.c      ****             break;
1254:../uvc.c      **** 
1255:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1256:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1257:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1258:../uvc.c      ****             gpif_initialized = 0;
1259:../uvc.c      ****             streamingStarted = CyFalse;
1260:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1261:../uvc.c      ****             break;
1262:../uvc.c      **** 
1263:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1264:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1265:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1266:../uvc.c      ****             gpif_initialized = 0;
1267:../uvc.c      ****             isUsbConnected = CyFalse;
1268:../uvc.c      ****             streamingStarted = CyFalse;
1269:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1270:../uvc.c      ****             break;
1271:../uvc.c      **** 
1272:../uvc.c      **** #ifdef BACKFLOW_DETECT
1273:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1274:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1275:../uvc.c      ****             break;
1276:../uvc.c      **** #endif
1277:../uvc.c      **** 
1278:../uvc.c      ****         default:
1279:../uvc.c      ****             break;
1280:../uvc.c      ****     }
1281:../uvc.c      **** }
1282:../uvc.c      **** 
1283:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1284:../uvc.c      **** static CyBool_t
1285:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1286:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1287:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1288:../uvc.c      ****         )
1289:../uvc.c      **** {
1290:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1291:../uvc.c      ****     uint32_t status;
1292:../uvc.c      **** 
1293:../uvc.c      ****     /* Obtain Request Type and Request */
1294:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1295:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1296:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1297:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1298:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1299:../uvc.c      **** 
1300:../uvc.c      ****     /* Check for UVC Class Requests */
1301:../uvc.c      ****     switch (bmReqType)
1302:../uvc.c      ****     {
1303:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1304:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1305:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1306:../uvc.c      ****             switch (wIndex & 0xFF)
1307:../uvc.c      ****             {
1308:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1309:../uvc.c      ****                     {
1310:../uvc.c      ****                         uvcHandleReq = CyTrue;
1311:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1312:../uvc.c      ****                                 CYU3P_EVENT_OR);
1313:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1314:../uvc.c      ****                         {
1315:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1316:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1317:../uvc.c      ****                         }
1318:../uvc.c      ****                     }
1319:../uvc.c      ****                     break;
1320:../uvc.c      **** 
1321:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1322:../uvc.c      ****                     {
1323:../uvc.c      ****                         uvcHandleReq = CyTrue;
1324:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1325:../uvc.c      ****                                 CYU3P_EVENT_OR);
1326:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1327:../uvc.c      ****                         {
1328:../uvc.c      ****                             /* Error handling */
1329:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1330:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1331:../uvc.c      ****                         }
1332:../uvc.c      ****                     }
1333:../uvc.c      ****                     break;
1334:../uvc.c      **** 
1335:../uvc.c      ****                 default:
1336:../uvc.c      ****                     break;
1337:../uvc.c      ****             }
1338:../uvc.c      ****             break;
1339:../uvc.c      **** 
1340:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1341:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1342:../uvc.c      ****             {
1343:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1344:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1345:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1346:../uvc.c      ****                 {
1347:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1348:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1349:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1350:../uvc.c      ****                     gpif_initialized = 0;
1351:../uvc.c      ****                     streamingStarted = CyFalse;
1352:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1353:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1354:../uvc.c      ****                     CyU3PBusyWait (100);
1355:../uvc.c      **** 
1356:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1357:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1358:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1359:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1360:../uvc.c      ****                     CyU3PBusyWait (100);
1361:../uvc.c      **** 
1362:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1363:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1364:../uvc.c      ****                     uvcHandleReq = CyTrue;
1365:../uvc.c      ****                     /* Complete Control request handshake */
1366:../uvc.c      ****                     CyU3PUsbAckSetup ();
1367:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1368:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1369:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1370:../uvc.c      **** 
1371:../uvc.c      ****                 }
1372:../uvc.c      ****                 if((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue != 0))
1373:../uvc.c      ****                 {
1374:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting %d..\r\n", wValue);
1375:../uvc.c      ****                 }
1376:../uvc.c      ****             }
1377:../uvc.c      ****             break;
1378:../uvc.c      **** 
1379:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1380:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1381:../uvc.c      ****             {
1382:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1383:../uvc.c      ****                 {
1384:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1385:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1386:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1387:../uvc.c      ****                 	 * has started. */
1388:../uvc.c      ****                     if (streamingStarted == CyTrue)
1389:../uvc.c      ****                     {
1390:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1391:../uvc.c      **** 
1392:../uvc.c      ****                         /* Disable the GPIF state machine. */
1393:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1394:../uvc.c      ****                         gpif_initialized = 0;
1395:../uvc.c      ****                         streamingStarted = CyFalse;
1396:../uvc.c      **** 
1397:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1398:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1399:../uvc.c      ****                         CyU3PBusyWait (100);
1400:../uvc.c      **** 
1401:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1402:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1403:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1404:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1405:../uvc.c      ****                         CyU3PBusyWait (100);
1406:../uvc.c      **** 
1407:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1408:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1409:../uvc.c      **** 
1410:../uvc.c      ****                         uvcHandleReq = CyTrue;
1411:../uvc.c      ****                         /* Complete Control request handshake */
1412:../uvc.c      ****                         CyU3PUsbAckSetup ();
1413:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1414:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1415:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1416:../uvc.c      ****                     }
1417:../uvc.c      ****                     else
1418:../uvc.c      ****                     {
1419:../uvc.c      ****                         uvcHandleReq = CyTrue;
1420:../uvc.c      ****                         CyU3PUsbAckSetup ();
1421:../uvc.c      ****                     }
1422:../uvc.c      ****                 }
1423:../uvc.c      ****             }
1424:../uvc.c      ****             break;
1425:../uvc.c      **** 
1426:../uvc.c      ****         default:
1427:../uvc.c      ****             break;
1428:../uvc.c      ****     }
1429:../uvc.c      **** 
1430:../uvc.c      ****     /* Return status of request handling to the USB driver */
1431:../uvc.c      ****     return uvcHandleReq;
1432:../uvc.c      **** }
1433:../uvc.c      **** 
1434:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1435:../uvc.c      **** 
1436:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1437:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1438:../uvc.c      ****  */
1439:../uvc.c      **** void
1440:../uvc.c      **** CyFxUvcApplnDmaCallback (
1441:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1442:../uvc.c      ****         CyU3PDmaCbType_t      type,
1443:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1444:../uvc.c      ****         )
1445:../uvc.c      **** {
1446:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1447:../uvc.c      **** #if 1
1448:../uvc.c      ****     CyU3PReturnStatus_t status;
1449:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
1450:../uvc.c      ****       //                                      type, input->buffer_p.count, prodCount - consCount);
1451:../uvc.c      **** 
1452:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1453:../uvc.c      ****     {
1454:../uvc.c      ****             if (input->buffer_p.count == 0xB70/*CY_FX_UVC_BUF_FULL_SIZE*/)
1455:../uvc.c      ****             {
1456:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1457:../uvc.c      ****                 fb++;
1458:../uvc.c      ****                 takeFull = 1;
1459:../uvc.c      ****             }
1460:../uvc.c      ****             else
1461:../uvc.c      ****             {
1462:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1463:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1464:../uvc.c      ****                 pb++;
1465:../uvc.c      ****                 pbc = input->buffer_p.count;
1466:../uvc.c      ****                 takeFull = 0;
1467:../uvc.c      ****                 //CyU3PDebugPrint (4, "partition: Code = %d, size = %x, dmaDone %d, full %d\r\n",
1468:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount);
1469:../uvc.c      ****                // hitFV = CyTrue;
1470:../uvc.c      ****             }
1471:../uvc.c      **** 
1472:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1473:../uvc.c      ****             prodCount++;
1474:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1475:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1476:../uvc.c      ****             //CyU3PDebugPrint(1 ,"\r\n %d",input->buffer_p.count);
1477:../uvc.c      ****             if (1 & (status != CY_U3P_SUCCESS))
1478:../uvc.c      ****             {
1479:../uvc.c      ****                 prodCount--;
1480:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
1481:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount, takeFull);
1482:../uvc.c      ****             }
1483:../uvc.c      ****     }
1484:../uvc.c      **** #endif
1485:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1486:../uvc.c      ****     {
1487:../uvc.c      ****         consCount++;
1488:../uvc.c      ****         streamingStarted = CyTrue;
1489:../uvc.c      ****         //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
1490:../uvc.c      ****                              //                       type, input->buffer_p.count, prodCount - cons
1491:../uvc.c      ****     }
1492:../uvc.c      **** }
1493:../uvc.c      **** 
1494:../uvc.c      **** /*
1495:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1496:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1497:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1498:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1499:../uvc.c      ****  * to commit the buffer.
1500:../uvc.c      ****  */
1501:../uvc.c      **** static uint8_t
1502:../uvc.c      **** CyFxUvcAppCommitEOF (
1503:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1504:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1505:../uvc.c      ****         )
1506:../uvc.c      **** {
1507:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1508:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1509:../uvc.c      **** 
1510:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1511:../uvc.c      **** 
1512:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1513:../uvc.c      ****     {
1514:../uvc.c      ****         switch (stateId)
1515:../uvc.c      ****         {
1516:../uvc.c      ****         CyU3PDebugPrint(4,"\r\n commiteof state = %d",stateId);
1517:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
1518:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1519:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1520:../uvc.c      ****                 break;
1521:../uvc.c      **** 
1522:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1523:../uvc.c      ****                 socket = 0;
1524:../uvc.c      ****                 break;
1525:../uvc.c      **** 
1526:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1527:../uvc.c      ****                 socket = 1;
1528:../uvc.c      ****                 break;
1529:../uvc.c      **** 
1530:../uvc.c      ****             default:
1531:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1532:../uvc.c      ****                 /* Unexpected current state. Return error. */
1533:../uvc.c      ****                 return 1;
1534:../uvc.c      ****         }
1535:../uvc.c      ****     }
1536:../uvc.c      **** 
1537:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1538:../uvc.c      ****     {
1539:../uvc.c      ****         switch (stateId)
1540:../uvc.c      ****         {
1541:../uvc.c      **** #ifndef CAM720
1542:../uvc.c      **** #ifdef GPIFIIM
1543:../uvc.c      ****             case 13:
1544:../uvc.c      ****             case 22://24:
1545:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1546:../uvc.c      ****                 break;
1547:../uvc.c      **** 
1548:../uvc.c      ****             case 8:
1549:../uvc.c      ****                 socket = 0;
1550:../uvc.c      ****                 break;
1551:../uvc.c      **** 
1552:../uvc.c      ****             case 18://20:
1553:../uvc.c      ****                 socket = 1;
1554:../uvc.c      ****                 break;
1555:../uvc.c      **** #else
1556:../uvc.c      ****             case 11:
1557:../uvc.c      ****             case 18:
1558:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1559:../uvc.c      ****                 break;
1560:../uvc.c      **** 
1561:../uvc.c      ****             case 8:
1562:../uvc.c      ****                 socket = 0;
1563:../uvc.c      ****                 break;
1564:../uvc.c      **** 
1565:../uvc.c      ****             case 15:
1566:../uvc.c      ****                 socket = 1;
1567:../uvc.c      ****                 break;
1568:../uvc.c      **** #endif
1569:../uvc.c      **** #else
1570:../uvc.c      ****             case 11:
1571:../uvc.c      ****             case 18:
1572:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1573:../uvc.c      ****                 break;
1574:../uvc.c      **** 
1575:../uvc.c      ****             case 8:
1576:../uvc.c      ****                 socket = 0;
1577:../uvc.c      ****                 break;
1578:../uvc.c      **** 
1579:../uvc.c      ****             case 15:
1580:../uvc.c      ****                 socket = 1;
1581:../uvc.c      ****                 break;
1582:../uvc.c      **** 
1583:../uvc.c      **** #endif
1584:../uvc.c      ****              default:
1585:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1586:../uvc.c      ****                 /* Unexpected current state. Return error. */
1587:../uvc.c      ****                return 1;
1588:../uvc.c      ****         }
1589:../uvc.c      ****     }
1590:../uvc.c      **** 
1591:../uvc.c      ****     if (socket != 0xFF)
1592:../uvc.c      ****     {
1593:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1594:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1595:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1596:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1597:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1598:../uvc.c      ****         {
1599:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1600:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1601:../uvc.c      ****         }
1602:../uvc.c      ****     }
1603:../uvc.c      **** 
1604:../uvc.c      ****     return 0;
1605:../uvc.c      **** }
1606:../uvc.c      **** 
1607:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1608:../uvc.c      **** void
1609:../uvc.c      **** CyFxGpifCB (
1610:../uvc.c      ****         CyU3PGpifEventType event,
1611:../uvc.c      ****         uint8_t currentState
1612:../uvc.c      ****         )
1613:../uvc.c      **** {
1614:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1615:../uvc.c      ****     {
1616:../uvc.c      ****         hitFV = CyTrue;
1617:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1618:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
1619:../uvc.c      ****     }
1620:../uvc.c      ****     //CyU3PDebugPrint(4,"\r\n evt %d state = %d",event, currentState);
1621:../uvc.c      **** }
1622:../uvc.c      **** 
1623:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1624:../uvc.c      **** static void
1625:../uvc.c      **** CyFxUVCApplnDebugInit (
1626:../uvc.c      ****         void)
1627:../uvc.c      **** {
1628:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1629:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1630:../uvc.c      **** 
1631:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1632:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1633:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1634:../uvc.c      ****     {
1635:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1636:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1637:../uvc.c      ****     }
1638:../uvc.c      **** 
1639:../uvc.c      ****     /* Set UART Configuration */
1640:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1641:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1642:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1643:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1644:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1645:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1646:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1647:../uvc.c      **** 
1648:../uvc.c      ****     /* Set the UART configuration */
1649:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1650:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1651:../uvc.c      ****     {
1652:../uvc.c      ****     	CyU3PDebugPrint (4, "test UART config");
1653:../uvc.c      ****     	CyFxAppErrorHandler (apiRetStatus);
1654:../uvc.c      ****     }
1655:../uvc.c      **** 
1656:../uvc.c      ****     /* Set the UART transfer */
1657:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1658:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1659:../uvc.c      ****     {
1660:../uvc.c      ****     	CyU3PDebugPrint (4, "test UART transfer");
1661:../uvc.c      ****     	CyFxAppErrorHandler (apiRetStatus);
1662:../uvc.c      ****     }
1663:../uvc.c      **** 
1664:../uvc.c      ****     /* Initialize the Debug logger module. */
1665:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1666:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1667:../uvc.c      ****     {
1668:../uvc.c      ****     	CyU3PDebugPrint (4, "test debug");
1669:../uvc.c      ****     	CyFxAppErrorHandler (apiRetStatus);
1670:../uvc.c      ****     }
1671:../uvc.c      **** 
1672:../uvc.c      ****     /* Disable log message headers. */
1673:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1674:../uvc.c      **** }
1675:../uvc.c      **** 
1676:../uvc.c      **** /* I2C initialization. */
1677:../uvc.c      **** static void
1678:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1679:../uvc.c      **** {
1680:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1681:../uvc.c      ****     CyU3PReturnStatus_t status;
1682:../uvc.c      **** 
1683:../uvc.c      ****     status = CyU3PI2cInit ();
1684:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1685:../uvc.c      ****     {
1686:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1687:../uvc.c      ****         CyFxAppErrorHandler (status);
1688:../uvc.c      ****     }
1689:../uvc.c      **** 
1690:../uvc.c      ****     /*  Set I2C Configuration */
1691:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1692:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1693:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1694:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1695:../uvc.c      **** 
1696:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1697:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1698:../uvc.c      ****     {
1699:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1700:../uvc.c      ****         CyFxAppErrorHandler (status);
1701:../uvc.c      ****     }
1702:../uvc.c      **** }
1703:../uvc.c      **** 
1704:../uvc.c      **** #ifdef BACKFLOW_DETECT
1705:../uvc.c      **** static void CyFxUvcAppPibCallback (
1706:../uvc.c      ****         CyU3PPibIntrType cbType,
1707:../uvc.c      ****         uint16_t cbArg)
1708:../uvc.c      **** {
1709:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1710:../uvc.c      ****     {
1711:../uvc.c      ****         if (!back_flow_detected)
1712:../uvc.c      ****         {
1713:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1714:../uvc.c      ****             back_flow_detected = 1;
1715:../uvc.c      ****         }
1716:../uvc.c      ****     }
1717:../uvc.c      **** }
1718:../uvc.c      **** #endif
1719:../uvc.c      **** 
1720:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1721:../uvc.c      **** static void
1722:../uvc.c      **** CyFxUvcAppDebugCallback (
1723:../uvc.c      ****         CyU3PDmaChannel   *handle,
1724:../uvc.c      ****         CyU3PDmaCbType_t   type,
1725:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1726:../uvc.c      **** {
1727:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1728:../uvc.c      ****     {
1729:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1730:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1731:../uvc.c      ****     }
1732:../uvc.c      **** }
1733:../uvc.c      **** #endif
1734:../uvc.c      **** 
1735:../uvc.c      **** #if 0
1736:../uvc.c      **** static void CyFxAppIntEpCb(
1737:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1738:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1739:../uvc.c      **** 		uint8_t  ebNum)
1740:../uvc.c      **** 		{
1741:../uvc.c      **** 			//CyBool_t value;
1742:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1743:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1744:../uvc.c      **** 
1745:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1746:../uvc.c      **** 		}
1747:../uvc.c      **** #endif
1748:../uvc.c      **** 
1749:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1750:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1751:../uvc.c      ****    configures the DMA module for the UVC Application */
1752:../uvc.c      **** static void
1753:../uvc.c      **** CyFxUVCApplnInit (void)
1754:../uvc.c      **** {
1755:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1756:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1757:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1758:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1759:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1760:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1761:../uvc.c      **** 
1762:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1763:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1764:../uvc.c      **** 
1765:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1766:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1767:../uvc.c      **** #endif
1768:../uvc.c      **** 
1769:../uvc.c      ****     /* Create UVC event group */
1770:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1771:../uvc.c      ****     if (apiRetStatus != 0)
1772:../uvc.c      ****     {
1773:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1774:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1775:../uvc.c      ****     }
1776:../uvc.c      **** 
1777:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1778:../uvc.c      ****     CyFxUvcAppPTZInit ();
1779:../uvc.c      **** #endif
1780:../uvc.c      **** 
1781:../uvc.c      ****     isUsbConnected = CyFalse;
1782:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1783:../uvc.c      **** 
1784:../uvc.c      ****     /* Init the GPIO module */
1785:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1786:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1787:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1788:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1789:../uvc.c      ****     gpioClock.halfDiv    = 0;
1790:../uvc.c      **** 
1791:../uvc.c      ****     /* Initialize Gpio interface */
1792:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1793:../uvc.c      ****     if (apiRetStatus != 0)
1794:../uvc.c      ****     {
1795:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1796:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1797:../uvc.c      ****     }
1798:../uvc.c      **** 
1799:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1800:../uvc.c      ****      * must use GpioOverride to configure it */
1801:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1802:../uvc.c      ****     if (apiRetStatus != 0)
1803:../uvc.c      ****     {
1804:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1805:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1806:../uvc.c      ****     }
1807:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1808:../uvc.c      ****     if (apiRetStatus != 0)
1809:../uvc.c      ****     {
1810:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1811:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1812:../uvc.c      ****     }
1813:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1814:../uvc.c      ****     if (apiRetStatus != 0)
1815:../uvc.c      ****     {
1816:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1817:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1818:../uvc.c      ****     }
1819:../uvc.c      **** 
1820:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1821:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1822:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1823:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1824:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1825:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1826:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1827:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1828:../uvc.c      ****     {
1829:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1830:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1831:../uvc.c      ****     }
1832:../uvc.c      **** 
1833:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1834:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1835:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1836:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1837:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1838:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1839:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1840:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1841:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1842:../uvc.c      ****     {
1843:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1844:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1845:../uvc.c      ****     }
1846:../uvc.c      **** 
1847:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1848:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1849:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1850:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1851:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1852:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1853:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1855:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1856:../uvc.c      ****     {
1857:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1858:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1859:../uvc.c      ****     }
1860:../uvc.c      **** 
1861:../uvc.c      ****     /* Initialize the P-port. */
1862:../uvc.c      ****     pibclock.clkDiv      = 2;
1863:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1864:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1865:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1866:../uvc.c      **** 
1867:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1868:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1869:../uvc.c      ****     {
1870:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1871:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1872:../uvc.c      ****     }
1873:../uvc.c      **** 
1874:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1875:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1876:../uvc.c      **** 
1877:../uvc.c      **** #ifdef BACKFLOW_DETECT
1878:../uvc.c      ****     back_flow_detected = 0;
1879:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1880:../uvc.c      **** #endif
1881:../uvc.c      **** 
1882:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1883:../uvc.c      ****     SensorReset ();
1884:../uvc.c      ****     SensorInit ();
1885:../uvc.c      **** 
1886:../uvc.c      ****     /* USB initialization. */
1887:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1888:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1889:../uvc.c      ****     {
1890:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1891:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1892:../uvc.c      ****     }
1893:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1894:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1895:../uvc.c      **** 
1896:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1897:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1898:../uvc.c      **** 
1899:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1900:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1901:../uvc.c      **** 
1902:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1903:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1904:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1905:../uvc.c      **** 
1906:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1907:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1908:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1909:../uvc.c      **** 
1910:../uvc.c      ****     /* Configuration descriptors. */
1911:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1912:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
1913:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
1914:../uvc.c      **** 
1915:../uvc.c      ****     /* String Descriptors */
1916:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
1917:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
1918:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
1919:../uvc.c      **** 
1920:../uvc.c      ****     /* Configure the status interrupt endpoint.
1921:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
1922:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
1923:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
1924:../uvc.c      ****      */
1925:../uvc.c      ****     endPointConfig.enable   = 1;
1926:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
1927:../uvc.c      ****     endPointConfig.pcktSize = 64;
1928:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1929:../uvc.c      ****     endPointConfig.streams  = 0;
1930:../uvc.c      ****     endPointConfig.burstLen = 1;
1931:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
1932:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1933:../uvc.c      ****     {
1934:../uvc.c      ****         /* Error Handling */
1935:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(int), Error Code = %d\n", apiRetStatus)
1936:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1937:../uvc.c      ****     }
1938:../uvc.c      **** 
1939:../uvc.c      ****     /* create a DMA for interrupt endpoint */
1940:../uvc.c      ****     dmaInterConfig.size           = 1024;
1941:../uvc.c      ****     dmaInterConfig.count          = 1;
1942:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
1943:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
1944:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
1945:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
1946:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
1947:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
1948:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1949:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
1950:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
1951:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
1952:../uvc.c      ****             &dmaInterConfig);
1953:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1954:../uvc.c      ****     {
1955:../uvc.c      ****         /* Error handling */
1956:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
1957:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1958:../uvc.c      ****     }
1959:../uvc.c      **** 
1960:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
1961:../uvc.c      ****     if (glInterStaBuffer == 0)
1962:../uvc.c      ****     {
1963:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
1964:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
1965:../uvc.c      ****     }
1966:../uvc.c      **** 
1967:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
1968:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
1969:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
1970:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
1971:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
1972:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
1973:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
1974:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
1975:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
1976:../uvc.c      ****     dmaMultiConfig.prodFooter     = 132;                  /* 4 byte footer to compensate for the 12
1977:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
1978:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1979:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
1980:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
1981:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
1982:../uvc.c      ****             &dmaMultiConfig);
1983:../uvc.c      ****     CyU3PDebugPrint (4, "DMA Channel Creation. xfersize %d, size %d, count %d, activeProInd %d, act
1984:../uvc.c      ****     		glChHandleUVCStream.xferSize, glChHandleUVCStream.size,
1985:../uvc.c      ****     		glChHandleUVCStream.count, glChHandleUVCStream.activeProdIndex, glChHandleUVCStream.activeCon
1986:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1987:../uvc.c      ****     {
1988:../uvc.c      ****         /* Error handling */
1989:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
1990:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1991:../uvc.c      ****     }
1992:../uvc.c      **** 
1993:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1994:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
1995:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
1996:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
1997:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
1998:../uvc.c      ****      */
1999:../uvc.c      **** 
2000:../uvc.c      ****     endPointConfig.enable   = 1;
2001:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2002:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2003:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2004:../uvc.c      ****     endPointConfig.streams  = 0;
2005:../uvc.c      ****     endPointConfig.burstLen = 1;
2006:../uvc.c      **** 
2007:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2008:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2009:../uvc.c      ****     {
2010:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2011:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2012:../uvc.c      ****     }
2013:../uvc.c      **** 
2014:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2015:../uvc.c      **** 
2016:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2017:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2018:../uvc.c      ****     {
2019:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2020:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2021:../uvc.c      ****     }
2022:../uvc.c      **** 
2023:../uvc.c      ****     channelConfig.size           = 1024;
2024:../uvc.c      ****     channelConfig.count          = 1;
2025:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2026:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2027:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2028:../uvc.c      ****     channelConfig.prodHeader     = 0;
2029:../uvc.c      ****     channelConfig.prodFooter     = 0;
2030:../uvc.c      ****     channelConfig.consHeader     = 0;
2031:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2032:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2033:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2034:../uvc.c      **** 
2035:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2036:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2037:../uvc.c      ****     {
2038:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2039:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2040:../uvc.c      ****     }
2041:../uvc.c      **** 
2042:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2043:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2044:../uvc.c      ****     {
2045:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2046:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2047:../uvc.c      ****     }
2048:../uvc.c      **** 
2049:../uvc.c      ****     channelConfig.size           = 1024;
2050:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2051:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2052:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2053:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2054:../uvc.c      ****     channelConfig.prodHeader     = 0;
2055:../uvc.c      ****     channelConfig.prodFooter     = 0;
2056:../uvc.c      ****     channelConfig.consHeader     = 0;
2057:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2058:../uvc.c      ****     channelConfig.notification   = 0;
2059:../uvc.c      ****     channelConfig.cb             = 0;
2060:../uvc.c      **** 
2061:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2062:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2063:../uvc.c      ****     {
2064:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2065:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2066:../uvc.c      ****     }
2067:../uvc.c      **** 
2068:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2069:../uvc.c      ****     if (glDebugRspBuffer == 0)
2070:../uvc.c      ****     {
2071:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2072:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2073:../uvc.c      ****     }
2074:../uvc.c      **** #endif
2075:../uvc.c      **** 
2076:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2077:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2078:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2079:../uvc.c      ****     {
2080:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2081:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2082:../uvc.c      ****     }
2083:../uvc.c      **** 
2084:../uvc.c      ****     CyU3PBusyWait(100);
2085:../uvc.c      **** 
2086:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2087:../uvc.c      **** 
2088:../uvc.c      ****     endPointConfig.enable   = 1;
2089:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_ISO;//CY_U3P_USB_EP_BULK;
2090:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2091:../uvc.c      ****     {
2092:../uvc.c      ****     	endPointConfig.pcktSize = 0x400;//CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2093:../uvc.c      ****     	endPointConfig.burstLen = 1;
2094:../uvc.c      ****     	endPointConfig.isoPkts = 3; //for isochronous
2095:../uvc.c      ****     }
2096:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2097:../uvc.c      ****     {
2098:../uvc.c      ****     	endPointConfig.pcktSize = 0x400;
2099:../uvc.c      ****     	endPointConfig.burstLen = 1;
2100:../uvc.c      ****     	endPointConfig.isoPkts = 3; //for isochronous
2101:../uvc.c      ****     }
2102:../uvc.c      ****     endPointConfig.streams  = 0;
2103:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2104:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2105:../uvc.c      ****     {
2106:../uvc.c      ****         /* Error Handling */
2107:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(iso), Error Code = %d\n", apiRetStatus)
2108:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2109:../uvc.c      ****     }
2110:../uvc.c      **** #if 0    //for still image method 3 using
2111:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2112:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2113:../uvc.c      ****     {
2114:../uvc.c      ****         /* Error Handling */
2115:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2116:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2117:../uvc.c      ****     }
2118:../uvc.c      **** #endif
2119:../uvc.c      **** 
2120:../uvc.c      **** }
2121:../uvc.c      **** 
2122:../uvc.c      **** /*
2123:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2124:../uvc.c      ****  * streaming session is started.
2125:../uvc.c      ****  */
2126:../uvc.c      **** static void
2127:../uvc.c      **** CyFxUvcAppGpifInit (
2128:../uvc.c      ****         void)
2129:../uvc.c      **** {
2130:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2131:../uvc.c      **** 
2132:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2133:../uvc.c      ****     {
2134:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2135:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2136:../uvc.c      ****     }
2137:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2138:../uvc.c      ****     {
2139:../uvc.c      ****     	CyU3PDebugPrint(1,"%d \r\n high gpif", glProbeCtrl20[3]);
2140:../uvc.c      ****     	if(glProbeCtrl20[3]==2)//480x320
2141:../uvc.c      ****     		apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2_480);
2142:../uvc.c      ****     	else //640x480 (default)
2143:../uvc.c      ****     		apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2_640);
2144:../uvc.c      ****     }
2145:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2146:../uvc.c      ****     {
2147:../uvc.c      ****         /* Error Handling */
2148:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2149:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2150:../uvc.c      ****     }
2151:../uvc.c      **** 
2152:../uvc.c      ****     /* Start the state machine from the designated start state. */
2153:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2154:../uvc.c      ****     {
2155:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2156:../uvc.c      ****     }
2157:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2158:../uvc.c      ****     {
2159:../uvc.c      ****     	if(glProbeCtrl20[3]==2)//480x320
2160:../uvc.c      ****     		apiRetStatus = CyU3PGpifSMStart (START_USB2_480, ALPHA_START_USB2_480);
2161:../uvc.c      ****     	else //640x480 (default)
2162:../uvc.c      ****     		apiRetStatus = CyU3PGpifSMStart (START_USB2_640, ALPHA_START_USB2_640);
2163:../uvc.c      ****     }
2164:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2165:../uvc.c      ****     {
2166:../uvc.c      ****         /* Error Handling */
2167:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2168:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2169:../uvc.c      ****     }
2170:../uvc.c      **** }
2171:../uvc.c      **** 
2172:../uvc.c      **** /*
2173:../uvc.c      ****  * Entry function for the UVC Application Thread
2174:../uvc.c      ****  */
2175:../uvc.c      **** 
2176:../uvc.c      **** uint32_t posTick;
2177:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2178:../uvc.c      **** 
2179:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2180:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2181:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2182:../uvc.c      **** }
2183:../uvc.c      **** 
2184:../uvc.c      **** 
2185:../uvc.c      **** void
2186:../uvc.c      **** UVCAppThread_Entry (
2187:../uvc.c      ****         uint32_t input)
2188:../uvc.c      **** {
2189:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2190:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2191:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2192:../uvc.c      ****     uint8_t i = 0;
2193:../uvc.c      ****     uint32_t flag;
2194:../uvc.c      ****     uint32_t prinflag = 0;
2195:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2196:../uvc.c      ****     uint32_t frameCnt = 0;
2197:../uvc.c      **** #endif
2198:../uvc.c      ****     /* Initialize the Uart Debug Module */
2199:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2200:../uvc.c      **** 
2201:../uvc.c      ****     /* Initialize the I2C interface */
2202:../uvc.c      **** 	while (i++ < 6){
2203:../uvc.c      **** 		CyU3PThreadSleep(500);
2204:../uvc.c      **** 	}
2205:../uvc.c      **** 
2206:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2207:../uvc.c      **** 
2208:../uvc.c      ****     /* Initialize the UVC Application */
2209:../uvc.c      ****     CyFxUVCApplnInit ();
2210:../uvc.c      **** 
2211:../uvc.c      ****     /*
2212:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2213:../uvc.c      **** 
2214:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2215:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2216:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2217:../uvc.c      **** 
2218:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2219:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2220:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2221:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2222:../uvc.c      **** 
2223:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2224:../uvc.c      ****        of handling the abort request.
2225:../uvc.c      ****      */
2226:../uvc.c      **** 
2227:../uvc.c      ****     for (;;)
2228:../uvc.c      ****     {
2229:../uvc.c      ****         /* Waiting for the Video Stream Event */
2230:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2231:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2232:../uvc.c      ****         {
2233:../uvc.c      **** #if 0 //test for new firmware no video bring up
2234:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2235:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2236:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2237:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2238:../uvc.c      ****             {
2239:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2240:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2241:../uvc.c      ****                 {
2242:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2243:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2244:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2245:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2246:../uvc.c      **** #endif
2247:../uvc.c      **** #endif
2248:../uvc.c      ****                     }
2249:../uvc.c      ****                 else
2250:../uvc.c      ****                 {
2251:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2252:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2253:../uvc.c      **** #ifdef USB_LOWRES_IMG
2254:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2255:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2256:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2257:../uvc.c      **** #endif
2258:../uvc.c      **** #endif
2259:../uvc.c      ****                 }
2260:../uvc.c      **** 
2261:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2262:../uvc.c      ****                 prodCount++;
2263:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2264:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2265:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2266:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2267:../uvc.c      ****                 {
2268:../uvc.c      ****                     prodCount--;
2269:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2270:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2271:../uvc.c      ****                 }
2272:../uvc.c      ****             }
2273:../uvc.c      **** #endif
2274:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2275:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2276:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2277:../uvc.c      ****             {
2278:../uvc.c      ****             	if(0&&(prinflag == 0)){
2279:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\r\n", fb, pb, pbc);
2280:../uvc.c      ****             		prinflag = 1;
2281:../uvc.c      ****             	}
2282:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2283:../uvc.c      ****             	fb=0;
2284:../uvc.c      ****             	pb=0;
2285:../uvc.c      ****             	pbc=0;
2286:../uvc.c      ****                 prodCount = 0;
2287:../uvc.c      ****                 consCount = 0;
2288:../uvc.c      ****                 hitFV     = CyFalse;
2289:../uvc.c      **** 
2290:../uvc.c      **** #ifdef BACKFLOW_DETECT
2291:../uvc.c      ****                 back_flow_detected = 0;
2292:../uvc.c      **** #endif
2293:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2294:../uvc.c      ****                 frameCnt++;
2295:../uvc.c      **** #endif
2296:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2297:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2298:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2299:../uvc.c      ****                 //}
2300:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2301:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2302:../uvc.c      ****                 if(stiflag){
2303:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
2304:../uvc.c      ****                 	stiflag = CyFalse;
2305:../uvc.c      ****                 }else{
2306:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2307:../uvc.c      ****                 }
2308:../uvc.c      ****                 /* Reset the DMA channel. */
2309:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2310:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2311:../uvc.c      ****                 {
2312:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2313:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2314:../uvc.c      ****                 }
2315:../uvc.c      **** 
2316:../uvc.c      ****                 /* Start Channel Immediately */
2317:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2318:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2319:../uvc.c      ****                 {
2320:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2321:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2322:../uvc.c      ****                 }
2323:../uvc.c      **** 
2324:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2325:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2326:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2327:../uvc.c      ****                 }
2328:../uvc.c      ****         }
2329:../uvc.c      ****         else
2330:../uvc.c      ****         {
2331:../uvc.c      ****             /* If we have a stream abort request pending. */
2332:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2333:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2334:../uvc.c      ****             {
2335:../uvc.c      ****                 hitFV     = CyFalse;
2336:../uvc.c      ****                 prodCount = 0;
2337:../uvc.c      ****                 consCount = 0;
2338:../uvc.c      ****                 if(0&&(prinflag == 0)){
2339:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\r\n", fb, pb, pbc);
2340:../uvc.c      ****                 	prinflag = 1;
2341:../uvc.c      ****                 }
2342:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2343:../uvc.c      ****                 fb=0;
2344:../uvc.c      ****                 pb=0;
2345:../uvc.c      ****                 pbc=0;
2346:../uvc.c      **** 
2347:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2348:../uvc.c      ****                 {
2349:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2350:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2351:../uvc.c      ****                     {
2352:../uvc.c      ****                     	CyU3PDebugPrint (4, "test 1 0x%x\r\n", apiRetStatus);
2353:../uvc.c      ****                     	CyFxAppErrorHandler (apiRetStatus);
2354:../uvc.c      ****                     }
2355:../uvc.c      **** 
2356:../uvc.c      ****                     /* Flush the Endpoint memory */
2357:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2358:../uvc.c      ****                 }
2359:../uvc.c      **** 
2360:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2361:../uvc.c      ****             }
2362:../uvc.c      ****             else
2363:../uvc.c      ****             {
2364:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2365:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2366:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2367:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2368:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2369:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2370:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2371:../uvc.c      ****                 {
2372:../uvc.c      ****                     /* Error handling */
2373:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2374:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2375:../uvc.c      ****                 }
2376:../uvc.c      **** 
2377:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2378:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2379:../uvc.c      ****                 {
2380:../uvc.c      ****                     //for start up of the AF Lens
2381:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2382:../uvc.c      ****                     CyU3PThreadSleep(500);
2383:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2384:../uvc.c      ****                     CyU3PThreadSleep(500);
2385:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2386:../uvc.c      ****                    	CyU3PThreadSleep(300);
2387:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2388:../uvc.c      ****                     CyU3PThreadSleep(500);
2389:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2390:../uvc.c      ****                     CyU3PThreadSleep(500);
2391:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2392:../uvc.c      ****                     gpif_initialized = CyTrue;
2393:../uvc.c      ****                     CyU3PThreadSleep(200);
2394:../uvc.c      ****                     
2395:../uvc.c      ****                 }
2396:../uvc.c      ****                 else
2397:../uvc.c      ****                 {
2398:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2399:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2400:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2401:../uvc.c      ****                 }
2402:../uvc.c      ****             }
2403:../uvc.c      ****         }
2404:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2405:../uvc.c      **** 
2406:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2407:../uvc.c      ****         CyU3PThreadRelinquish ();
2408:../uvc.c      ****     }
2409:../uvc.c      **** }
2410:../uvc.c      **** 
2411:../uvc.c      **** /*
2412:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2413:../uvc.c      ****  */
2414:../uvc.c      **** 
2415:../uvc.c      **** static void
2416:../uvc.c      **** UVCHandleProcessingUnitRqts (
2417:../uvc.c      ****         void)
2418:../uvc.c      **** {
2419:../uvc.c      ****     uint8_t CtrlAdd;
2420:../uvc.c      **** #ifdef DbgInfo
2421:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2422:../uvc.c      **** #endif
2423:../uvc.c      ****     switch (wValue)
2424:../uvc.c      ****     {
2425:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2426:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2427:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2428:../uvc.c      ****     		break;
2429:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2430:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2431:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2432:../uvc.c      ****     		break;
2433:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2434:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2435:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2436:../uvc.c      **** 			break;
2437:../uvc.c      **** 
2438:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2439:../uvc.c      **** 
2440:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2441:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2442:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2443:../uvc.c      ****       		break;
2444:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2445:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2446:../uvc.c      ****      		ControlHandle(HueCtlID5);
2447:../uvc.c      ****      		break;
2448:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2449:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2450:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2451:../uvc.c      ****           		break;
2452:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2453:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2454:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2455:../uvc.c      ****           		break;
2456:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2457:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2458:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2459:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2460:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2461:../uvc.c      ****     		break;
2462:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2463:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2464:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2465:../uvc.c      ****     		break;
2466:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2467:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2468:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2469:../uvc.c      ****     		break;
2470:../uvc.c      **** 
2471:../uvc.c      ****         default:
2472:../uvc.c      ****             /*
2473:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2474:../uvc.c      ****              * other controls.
2475:../uvc.c      ****              */
2476:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2477:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2478:../uvc.c      ****             break;
2479:../uvc.c      ****     }
2480:../uvc.c      **** }
2481:../uvc.c      **** 
2482:../uvc.c      **** /*
2483:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2484:../uvc.c      ****  */
2485:../uvc.c      **** static void
2486:../uvc.c      **** UVCHandleCameraTerminalRqts (
2487:../uvc.c      ****         void)
2488:../uvc.c      **** {
2489:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2490:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2491:../uvc.c      ****     uint16_t readCount;
2492:../uvc.c      ****     uint16_t zoomVal;
2493:../uvc.c      ****     int32_t  panVal, tiltVal;
2494:../uvc.c      ****     CyBool_t sendData = CyFalse;
2495:../uvc.c      **** #endif
2496:../uvc.c      ****     uint8_t CtrlAdd;
2497:../uvc.c      **** 
2498:../uvc.c      ****     switch (wValue)
2499:../uvc.c      ****     {
2500:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2501:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2502:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2503:../uvc.c      ****     		break;
2504:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2505:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2506:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2507:../uvc.c      ****     		break;
2508:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2509:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2510:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2511:../uvc.c      **** 			break;
2512:../uvc.c      **** 
2513:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2514:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2515:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2516:../uvc.c      **** 			break;
2517:../uvc.c      **** 
2518:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2519:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2520:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2521:../uvc.c      ****       		break;
2522:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2523:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2524:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2525:../uvc.c      ****      		break;
2526:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2527:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2528:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2529:../uvc.c      ****           		break;
2530:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2531:../uvc.c      ****           		break;
2532:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2533:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2534:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2535:../uvc.c      ****      		break;
2536:../uvc.c      **** 
2537:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2538:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2539:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2540:../uvc.c      ****     		break;
2541:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2542:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2543:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2544:../uvc.c      ****     		break;
2545:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2546:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2547:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2548:../uvc.c      ****     		break;
2549:../uvc.c      **** 
2550:../uvc.c      ****         default:
2551:../uvc.c      ****             /*
2552:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2553:../uvc.c      ****              * other controls.
2554:../uvc.c      ****              */
2555:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2556:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2557:../uvc.c      ****             break;
2558:../uvc.c      ****     }
2559:../uvc.c      **** 
2560:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2561:../uvc.c      ****     switch (wValue)
2562:../uvc.c      ****     {
2563:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2564:../uvc.c      ****             switch (bRequest)
2565:../uvc.c      ****             {
2566:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2567:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2568:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2569:../uvc.c      ****                     break;
2570:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2571:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2572:../uvc.c      ****                     sendData = CyTrue;
2573:../uvc.c      ****                     break;
2574:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2575:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2576:../uvc.c      ****                     sendData = CyTrue;
2577:../uvc.c      ****                     break;
2578:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2579:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2580:../uvc.c      ****                     sendData = CyTrue;
2581:../uvc.c      ****                     break;
2582:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2583:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2584:../uvc.c      ****                     sendData = CyTrue;
2585:../uvc.c      ****                     break;
2586:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2587:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2588:../uvc.c      ****                     sendData = CyTrue;
2589:../uvc.c      ****                     break;
2590:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2591:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2592:../uvc.c      ****                             glEp0Buffer, &readCount);
2593:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2594:../uvc.c      ****                     {
2595:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2596:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2597:../uvc.c      ****                     }
2598:../uvc.c      ****                     break;
2599:../uvc.c      ****                 default:
2600:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2601:../uvc.c      ****                     break;
2602:../uvc.c      ****             }
2603:../uvc.c      **** 
2604:../uvc.c      ****             if (sendData)
2605:../uvc.c      ****             {
2606:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2607:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2608:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2609:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2610:../uvc.c      ****             }
2611:../uvc.c      ****             break;
2612:../uvc.c      **** 
2613:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2614:../uvc.c      ****             switch (bRequest)
2615:../uvc.c      ****             {
2616:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2617:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2618:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2619:../uvc.c      ****                     break;
2620:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2621:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2622:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2623:../uvc.c      ****                     sendData = CyTrue;
2624:../uvc.c      ****                     break;
2625:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2626:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2627:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2628:../uvc.c      ****                     sendData = CyTrue;
2629:../uvc.c      ****                     break;
2630:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2631:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2632:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2633:../uvc.c      ****                     sendData = CyTrue;
2634:../uvc.c      ****                     break;
2635:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2636:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2637:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2638:../uvc.c      ****                     sendData = CyTrue;
2639:../uvc.c      ****                     break;
2640:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2641:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2642:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2643:../uvc.c      ****                     sendData = CyTrue;
2644:../uvc.c      ****                     break;
2645:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2646:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2647:../uvc.c      ****                             glEp0Buffer, &readCount);
2648:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2649:../uvc.c      ****                     {
2650:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2651:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2652:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2653:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2654:../uvc.c      **** 
2655:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2656:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2657:../uvc.c      ****                     }
2658:../uvc.c      ****                     break;
2659:../uvc.c      ****                 default:
2660:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2661:../uvc.c      ****                     break;
2662:../uvc.c      ****             }
2663:../uvc.c      **** 
2664:../uvc.c      ****             if (sendData)
2665:../uvc.c      ****             {
2666:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2667:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2668:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2669:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2670:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2671:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2672:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2673:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2674:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2675:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2676:../uvc.c      ****             }
2677:../uvc.c      ****             break;
2678:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2679:../uvc.c      ****         default:
2680:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2681:../uvc.c      ****             break;
2682:../uvc.c      ****     }
2683:../uvc.c      **** #endif
2684:../uvc.c      **** }
2685:../uvc.c      **** 
2686:../uvc.c      **** /*
2687:../uvc.c      ****  * Handler for UVC Interface control requests.
2688:../uvc.c      ****  */
2689:../uvc.c      **** static void
2690:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2691:../uvc.c      ****         void)
2692:../uvc.c      **** {
2693:../uvc.c      **** 
2694:../uvc.c      ****     switch (wValue)
2695:../uvc.c      ****     {
2696:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2697:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2698:../uvc.c      ****     		break;
2699:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2700:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2701:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2702:../uvc.c      ****     		break;
2703:../uvc.c      ****     	default:
2704:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2705:../uvc.c      ****      		break;
2706:../uvc.c      ****     }
2707:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2708:../uvc.c      **** 
2709:../uvc.c      **** }
2710:../uvc.c      **** 
2711:../uvc.c      **** /*
2712:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2713:../uvc.c      ****  */
2714:../uvc.c      **** static void
2715:../uvc.c      **** UVCHandleExtensionUnitRqts (
2716:../uvc.c      ****         void)
2717:../uvc.c      **** {
2718:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2719:../uvc.c      **** 
2720:../uvc.c      **** #ifdef DbgInfo
2721:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2722:../uvc.c      **** #endif
2723:../uvc.c      ****     switch (wValue)
2724:../uvc.c      ****     {
2725:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2726:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2727:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2728:../uvc.c      ****     		break;
2729:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2730:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2731:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2732:../uvc.c      ****     		break;
2733:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2734:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2735:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2736:../uvc.c      ****      		break;
2737:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2738:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2739:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2740:../uvc.c      ****     		break;
2741:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2742:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2743:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2744:../uvc.c      ****     		break;
2745:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2746:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2747:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2748:../uvc.c      ****      		break;
2749:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2750:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2751:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2752:../uvc.c      ****     		break;
2753:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2754:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2755:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2756:../uvc.c      ****     		break;
2757:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2758:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2759:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2760:../uvc.c      ****      		break;
2761:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2762:../uvc.c      ****     		if(CamMode == 1){//only 720p support
2763:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2764:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2765:../uvc.c      ****     		}else/* no support for 1080p camera */
2766:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
2767:../uvc.c      ****     		break;
2768:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2769:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2770:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2771:../uvc.c      ****     		break;
2772:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2773:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2774:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2775:../uvc.c      ****     		break;
2776:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2777:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2778:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2779:../uvc.c      ****     		//break;
2780:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2781:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2782:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2783:../uvc.c      ****     		break;
2784:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2785:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2786:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2787:../uvc.c      ****     		break;
2788:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2789:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID0-EXUAOFFSET][0];
2790:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
2791:../uvc.c      ****     		break;
2792:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2793:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID1-EXUAOFFSET][0];
2794:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
2795:../uvc.c      ****     		break;
2796:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2797:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID2-EXUAOFFSET][0];
2798:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
2799:../uvc.c      ****     		break;
2800:../uvc.c      ****    	default:
2801:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2802:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2803:../uvc.c      ****     		break;
2804:../uvc.c      ****     }
2805:../uvc.c      **** 
2806:../uvc.c      **** }
2807:../uvc.c      **** 
2808:../uvc.c      **** /*
2809:../uvc.c      ****  * Handler for the video streaming control requests.
2810:../uvc.c      ****  */
2811:../uvc.c      **** static void
2812:../uvc.c      **** UVCHandleVideoStreamingRqts (
2813:../uvc.c      ****         void)
2814:../uvc.c      **** {
2815:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2816:../uvc.c      ****     uint16_t readCount;
2817:../uvc.c      **** 
2818:../uvc.c      ****     switch (wValue)
2819:../uvc.c      ****     {
2820:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2821:../uvc.c      ****             switch (bRequest)
2822:../uvc.c      ****             {
2823:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2824:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2825:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2826:../uvc.c      ****                     break;
2827:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2828:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2829:../uvc.c      ****                     glEp0Buffer[1] = 0;
2830:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2831:../uvc.c      ****                     break;
2832:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2833:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2834:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2835:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2836:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2837:../uvc.c      ****                     {
2838:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2839:../uvc.c      ****                     }
2840:../uvc.c      ****                     else
2841:../uvc.c      ****                     {
2842:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2843:../uvc.c      ****                     }
2844:../uvc.c      ****                     break;
2845:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2846:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2847:../uvc.c      ****                             glCommitCtrl, &readCount);
2848:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2849:../uvc.c      ****                     {
2850:../uvc.c      ****                         CyU3PDebugPrint (4, "glProbeCtrl 20 ~25 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x\
2851:../uvc.c      ****                         		glProbeCtrl20[2],
2852:../uvc.c      ****                         		glProbeCtrl20[3],
2853:../uvc.c      ****                         		glProbeCtrl20[18],
2854:../uvc.c      ****                         		glProbeCtrl20[19],
2855:../uvc.c      ****                         		glProbeCtrl20[20],
2856:../uvc.c      ****                         		glProbeCtrl20[21]); //check data
2857:../uvc.c      **** 
2858:../uvc.c      ****                     	if (1 | (usbSpeed == CY_U3P_SUPER_SPEED))
2859:../uvc.c      ****                         {
2860:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2861:../uvc.c      ****                                active data structure. */
2862:../uvc.c      ****                             glProbeCtrl20[2] = glCommitCtrl[2];
2863:../uvc.c      ****                             glProbeCtrl20[3] = glCommitCtrl[3];
2864:../uvc.c      ****                             glProbeCtrl20[18] = glCommitCtrl[18];
2865:../uvc.c      ****                             glProbeCtrl20[19] = glCommitCtrl[19];
2866:../uvc.c      ****                             glProbeCtrl20[20] = glCommitCtrl[20];
2867:../uvc.c      ****                             glProbeCtrl20[21] = glCommitCtrl[21];
2868:../uvc.c      ****                         }
2869:../uvc.c      ****                     }
2870:../uvc.c      ****                     CyU3PDebugPrint (4, "glCommitCtrl 20 ~25 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x\n\r
2871:../uvc.c      ****                     		glCommitCtrl[2],
2872:../uvc.c      ****                     		glCommitCtrl[3],
2873:../uvc.c      ****                     		glCommitCtrl[18],
2874:../uvc.c      ****                     		glCommitCtrl[19],
2875:../uvc.c      ****                     		glCommitCtrl[20],
2876:../uvc.c      ****                     		glCommitCtrl[21]); //check data
2877:../uvc.c      ****                     break;
2878:../uvc.c      ****                 default:
2879:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2880:../uvc.c      ****                     break;
2881:../uvc.c      ****             }
2882:../uvc.c      ****             break;
2883:../uvc.c      **** 
2884:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2885:../uvc.c      ****             switch (bRequest)
2886:../uvc.c      ****             {
2887:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2888:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2889:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2890:../uvc.c      ****                     break;
2891:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2892:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2893:../uvc.c      ****                     glEp0Buffer[1] = 0;
2894:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2895:../uvc.c      ****                     break;
2896:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2897:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2898:../uvc.c      ****                     {
2899:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2900:../uvc.c      ****                     }
2901:../uvc.c      ****                     else
2902:../uvc.c      ****                     {
2903:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2904:../uvc.c      ****                     }
2905:../uvc.c      ****                     break;
2906:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2907:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
2908:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
2909:../uvc.c      ****                        */
2910:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2911:../uvc.c      ****                             glCommitCtrl, &readCount);
2912:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2913:../uvc.c      ****                     {
2914:../uvc.c      **** #if 0
2915:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
2916:../uvc.c      ****                         {
2917:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
2918:../uvc.c      ****                         }
2919:../uvc.c      ****                         else
2920:../uvc.c      ****                         {
2921:../uvc.c      ****                             SensorScaling_VGA ();
2922:../uvc.c      ****                         }
2923:../uvc.c      **** #endif
2924:../uvc.c      ****                         /* We can start streaming video now. */
2925:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
2926:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
2927:../uvc.c      ****                         {
2928:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
2929:../uvc.c      ****                         }
2930:../uvc.c      ****                     }
2931:../uvc.c      ****                     break;
2932:../uvc.c      **** 
2933:../uvc.c      ****                 default:
2934:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2935:../uvc.c      ****                     break;
2936:../uvc.c      ****             }
2937:../uvc.c      ****             break;
2938:../uvc.c      **** 
2939:../uvc.c      **** /* still image streaming handler */
2940:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
2941:../uvc.c      ****                 switch (bRequest)
2942:../uvc.c      ****                 {
2943:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2944:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2945:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2946:../uvc.c      ****                         break;
2947:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2948:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2949:../uvc.c      ****                         glEp0Buffer[1] = 0;
2950:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2951:../uvc.c      ****                         break;
2952:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2953:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
2954:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
2955:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2956:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2957:../uvc.c      ****                         {
2958:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2959:../uvc.c      ****                         }
2960:../uvc.c      ****                         else
2961:../uvc.c      ****                         {
2962:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2963:../uvc.c      ****                         }
2964:../uvc.c      ****                         break;
2965:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2966:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2967:../uvc.c      ****                                 glCommitCtrl, &readCount);
2968:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
2969:../uvc.c      ****                         {
2970:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
2971:../uvc.c      ****                             {
2972:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
2973:../uvc.c      ****                                    active data structure. */
2974:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
2975:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
2976:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
2977:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
2978:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
2979:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
2980:../uvc.c      ****                             }
2981:../uvc.c      ****                         }
2982:../uvc.c      ****                         break;
2983:../uvc.c      ****                     default:
2984:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
2985:../uvc.c      ****                         break;
2986:../uvc.c      ****                 }
2987:../uvc.c      ****                 break;
2988:../uvc.c      **** 
2989:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
2990:../uvc.c      ****                 switch (bRequest)
2991:../uvc.c      ****                 {
2992:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2993:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
2994:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2995:../uvc.c      ****                         break;
2996:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2997:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2998:../uvc.c      ****                         glEp0Buffer[1] = 0;
2999:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3000:../uvc.c      ****                         break;
3001:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3002:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3003:../uvc.c      ****                         {
3004:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3005:../uvc.c      ****                         }
3006:../uvc.c      ****                         else
3007:../uvc.c      ****                         {
3008:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3009:../uvc.c      ****                         }
3010:../uvc.c      ****                         break;
3011:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3012:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3013:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3014:../uvc.c      ****                            */
3015:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3016:../uvc.c      ****                                 glCommitCtrl, &readCount);
3017:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3018:../uvc.c      ****                         {
3019:../uvc.c      ****     #if 0
3020:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3021:../uvc.c      ****                             {
3022:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3023:../uvc.c      ****                             }
3024:../uvc.c      ****                             else
3025:../uvc.c      ****                             {
3026:../uvc.c      ****                                 SensorScaling_VGA ();
3027:../uvc.c      ****                             }
3028:../uvc.c      ****     #endif
3029:../uvc.c      ****                             /* We can start streaming video now. */
3030:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3031:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3032:../uvc.c      ****                             {
3033:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3034:../uvc.c      ****                             }
3035:../uvc.c      ****                         }
3036:../uvc.c      ****                         break;
3037:../uvc.c      **** 
3038:../uvc.c      ****                     default:
3039:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3040:../uvc.c      ****                         break;
3041:../uvc.c      ****                 }
3042:../uvc.c      ****                 break;
3043:../uvc.c      **** 
3044:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3045:../uvc.c      ****                 switch (bRequest)
3046:../uvc.c      ****                 {
3047:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3048:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3049:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3050:../uvc.c      ****                         break;
3051:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3052:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3053:../uvc.c      ****                         glEp0Buffer[1] = 0;
3054:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3055:../uvc.c      ****                         break;
3056:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3057:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3058:../uvc.c      ****                         {
3059:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3060:../uvc.c      ****                         }
3061:../uvc.c      ****                         else
3062:../uvc.c      ****                         {
3063:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3064:../uvc.c      ****                         }
3065:../uvc.c      ****                         break;
3066:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3067:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3068:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3069:../uvc.c      ****                            */
3070:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3071:../uvc.c      ****                                 glCommitCtrl, &readCount);
3072:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3073:../uvc.c      ****                         {
3074:../uvc.c      ****     #if 0
3075:../uvc.c      ****                             /* We can start streaming video now. */
3076:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3077:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3078:../uvc.c      ****                             {
3079:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3080:../uvc.c      ****                             }
3081:../uvc.c      ****     #endif
3082:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
3083:../uvc.c      ****                         }else{
3084:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3085:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3086:../uvc.c      ****                         }
3087:../uvc.c      ****                         break;
3088:../uvc.c      **** 
3089:../uvc.c      ****                     default:
3090:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3091:../uvc.c      ****                         break;
3092:../uvc.c      ****                 }
3093:../uvc.c      ****                 break;
3094:../uvc.c      **** 
3095:../uvc.c      ****         default:
3096:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3097:../uvc.c      ****             break;
3098:../uvc.c      ****     }
3099:../uvc.c      **** }
3100:../uvc.c      **** 
3101:../uvc.c      **** /*
3102:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3103:../uvc.c      ****  */
3104:../uvc.c      **** void
3105:../uvc.c      **** UVCAppEP0Thread_Entry (
3106:../uvc.c      ****         uint32_t input)
3107:../uvc.c      **** {
3108:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3109:../uvc.c      ****     uint32_t eventFlag;
3110:../uvc.c      **** 	CyBool_t value;
3111:../uvc.c      **** 	CyBool_t *valueptr = &value;
3112:../uvc.c      **** 
3113:../uvc.c      **** 
3114:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3115:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3116:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3117:../uvc.c      **** 
3118:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3119:../uvc.c      **** #endif
3120:../uvc.c      **** 
3121:../uvc.c      ****     /* for interrupt status test */
3122:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3123:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3124:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3125:../uvc.c      **** 
3126:../uvc.c      ****     for (;;)
3127:../uvc.c      ****     {
3128:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3129:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3130:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3131:../uvc.c      ****         {
3132:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3133:../uvc.c      ****             if (!isUsbConnected)
3134:../uvc.c      ****             {
3135:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3136:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3137:../uvc.c      ****                 {
3138:../uvc.c      ****                     isUsbConnected = CyTrue;
3139:../uvc.c      ****                 }
3140:../uvc.c      ****             }
3141:../uvc.c      **** //#ifdef DbgInfo
3142:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3143:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3144:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3145:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3146:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3147:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3148:../uvc.c      **** //#endif
3149:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3150:../uvc.c      ****             {
3151:../uvc.c      ****             	switch ((wIndex >> 8))
3152:../uvc.c      ****                 {
3153:../uvc.c      **** 
3154:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3155:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3156:../uvc.c      ****                         break;
3157:../uvc.c      **** 
3158:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3159:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3160:../uvc.c      ****                         break;
3161:../uvc.c      **** 
3162:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3163:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3164:../uvc.c      ****                         break;
3165:../uvc.c      **** 
3166:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3167:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3168:../uvc.c      ****                         break;
3169:../uvc.c      **** 
3170:../uvc.c      ****                     default:
3171:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3172:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3173:../uvc.c      ****                         break;
3174:../uvc.c      ****                 }
3175:../uvc.c      ****             }
3176:../uvc.c      **** 
3177:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3178:../uvc.c      ****             {
3179:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3180:../uvc.c      **** 
3181:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3182:../uvc.c      ****                 {
3183:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3184:../uvc.c      ****                 }
3185:../uvc.c      ****                 else
3186:../uvc.c      ****                 {
3187:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3188:../uvc.c      ****                 }
3189:../uvc.c      ****             }
3190:../uvc.c      **** 
3191:../uvc.c      ****             /* handle interrupt status event */
3192:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3193:../uvc.c      ****             {
3194:../uvc.c      **** 
3195:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3196:../uvc.c      ****             	/** preparing interrupt status data **/
3197:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3198:../uvc.c      **** 
3199:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3200:../uvc.c      **** 
3201:../uvc.c      **** #if 1 //for real button
3202:../uvc.c      **** 				if(value&&(!snapButFlag)){
3203:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3204:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3205:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3206:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3207:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3208:../uvc.c      **** 
3209:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3210:../uvc.c      **** 					interStabuf.size   = 1024;
3211:../uvc.c      **** 					interStabuf.status = 0;
3212:../uvc.c      **** 
3213:../uvc.c      **** 					interStabuf.count = 4;
3214:../uvc.c      **** 
3215:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3216:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3217:../uvc.c      **** 
3218:../uvc.c      **** 					/** send a interrupt status data **/
3219:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3220:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3221:../uvc.c      **** 					{
3222:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3223:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3224:../uvc.c      **** 					}
3225:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3226:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3227:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3228:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3229:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3230:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3231:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3232:../uvc.c      **** 
3233:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3234:../uvc.c      **** 					interStabuf.size   = 1024;
3235:../uvc.c      **** 					interStabuf.status = 0;
3236:../uvc.c      **** 
3237:../uvc.c      **** 					interStabuf.count = 4;
3238:../uvc.c      **** 
3239:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3240:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3241:../uvc.c      **** 
3242:../uvc.c      **** 					/** send a interrupt status data **/
3243:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3244:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3245:../uvc.c      **** 					{
3246:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3247:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3248:../uvc.c      **** 					}
3249:../uvc.c      **** 
3250:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3251:../uvc.c      **** 					stiflag = CyTrue;
3252:../uvc.c      **** 				}
3253:../uvc.c      **** #else			//for botton simulation
3254:../uvc.c      **** 				if(snapButFlag == 0x0f){
3255:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3256:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3257:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3258:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3259:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3260:../uvc.c      **** 
3261:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3262:../uvc.c      **** 					interStabuf.size   = 1024;
3263:../uvc.c      **** 					interStabuf.status = 0;
3264:../uvc.c      **** 
3265:../uvc.c      **** 					interStabuf.count = 4;
3266:../uvc.c      **** 
3267:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3268:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3269:../uvc.c      **** 
3270:../uvc.c      **** 					/** send a interrupt status data **/
3271:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3272:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3273:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3274:../uvc.c      **** 					{
3275:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3276:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3277:../uvc.c      **** 					}
3278:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3279:../uvc.c      **** 
3280:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3281:../uvc.c      **** 				}else if(!snapButFlag){
3282:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3283:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3284:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3285:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3286:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3287:../uvc.c      **** 
3288:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3289:../uvc.c      **** 					interStabuf.size   = 1024;
3290:../uvc.c      **** 					interStabuf.status = 0;
3291:../uvc.c      **** 
3292:../uvc.c      **** 					interStabuf.count = 4;
3293:../uvc.c      **** 
3294:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3295:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3296:../uvc.c      **** 
3297:../uvc.c      **** 					/** send a interrupt status data **/
3298:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3299:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3300:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3301:../uvc.c      **** 					{
3302:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3303:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3304:../uvc.c      **** 					}
3305:../uvc.c      **** 
3306:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3307:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3308:../uvc.c      **** 				}
3309:../uvc.c      **** #endif
3310:../uvc.c      **** 
3311:../uvc.c      ****             }
3312:../uvc.c      **** 
3313:../uvc.c      **** 
3314:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3315:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3316:../uvc.c      ****             {
3317:../uvc.c      ****                 /* Get the command buffer */
3318:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3319:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3320:../uvc.c      ****                 {
3321:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3322:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3323:../uvc.c      ****                 }
3324:../uvc.c      **** 
3325:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3326:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3327:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3328:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3329:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3330:../uvc.c      ****                  * register value high byte and register value low byte.
3331:../uvc.c      ****                  */
3332:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3333:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3334:../uvc.c      ****                 {
3335:../uvc.c      ****                     if (dmaInfo.count == 3)
3336:../uvc.c      ****                     {
3337:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3338:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3339:../uvc.c      ****                         dmaInfo.count = 3;
3340:../uvc.c      ****                     }
3341:../uvc.c      ****                     else if (dmaInfo.count == 4)
3342:../uvc.c      ****                     {
3343:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3344:../uvc.c      ****                         {
3345:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3346:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3347:../uvc.c      ****                         }
3348:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3349:../uvc.c      ****                     }
3350:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3351:../uvc.c      ****                 }
3352:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3353:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3354:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3355:../uvc.c      ****                  */
3356:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3357:../uvc.c      ****                 {
3358:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3359:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3360:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3361:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3362:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3363:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3364:../uvc.c      ****                         	break;
3365:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3366:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3367:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3368:../uvc.c      ****                         	break;*/
3369:../uvc.c      ****                     dmaInfo.count -= 2;
3370:../uvc.c      ****                 }
3371:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3372:../uvc.c      ****                 else
3373:../uvc.c      ****                 {
3374:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3375:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3376:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3377:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3378:../uvc.c      ****                 }
3379:../uvc.c      **** 
3380:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3381:../uvc.c      ****                 dmaInfo.size   = 1024;
3382:../uvc.c      ****                 dmaInfo.status = 0;
3383:../uvc.c      **** 
3384:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3385:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3386:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3387:../uvc.c      ****                 {
3388:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3389:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3390:../uvc.c      ****                 }
3391:../uvc.c      **** 
3392:../uvc.c      ****                 /* Wait until the response has gone out. */
3393:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3394:../uvc.c      **** 
3395:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3396:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3397:../uvc.c      ****                 {
3398:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3399:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3400:../uvc.c      ****                 }
3401:../uvc.c      ****             }
3402:../uvc.c      **** #endif
3403:../uvc.c      ****         }
3404:../uvc.c      ****         /* Allow other ready threads to run. */
3405:../uvc.c      ****         CyU3PThreadRelinquish ();
3406:../uvc.c      ****     }
3407:../uvc.c      **** }
3408:../uvc.c      **** 
3409:../uvc.c      **** /*
3410:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3411:../uvc.c      ****  * added 10/2013
3412:../uvc.c      ****  */
3413:../uvc.c      **** /*
3414:../uvc.c      **** static uint8_t timeDelay[64] = {
3415:../uvc.c      **** 
3416:../uvc.c      **** };
3417:../uvc.c      **** */
3418:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3418 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3419:../uvc.c      **** 
3420:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3421:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3422:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3423:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3424:../uvc.c      **** 	VdstateDes *lcStaDes;
3425:../uvc.c      **** 	uint32_t flag = 0;
3426:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3427:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3428:../uvc.c      **** 	uint8_t i;
3429:../uvc.c      **** 	uint16_t delaytime;
3430:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3431:../uvc.c      **** 
3432:../uvc.c      **** #if 0 //for test the command queue
3433:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3434:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3435:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3436:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3437:../uvc.c      **** 		lcCmdDes += 1;
3438:../uvc.c      **** 	}
3439:../uvc.c      **** #endif
3440:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3441:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3441 0
  36 0004 10229FE5 		ldr	r2, .L22
3425:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3425 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3418:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3418 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3441 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 F8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3425:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3425 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3441 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3442:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3442 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 DC119FE5 		ldr	r1, .L22+8
  71 0044 DC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3443:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3443 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3444:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3444 0
  79 005c BC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3445:../uvc.c      **** 
3446:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3446 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3447:../uvc.c      ****         /* Allow other ready threads to run. */
3448:../uvc.c      **** 
3449:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3449 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3446:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3446 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3450:../uvc.c      **** 	}
3451:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3451 0
  92 0078 A8019FE5 		ldr	r0, .L22+12
  93 007c A8119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 98719FE5 		ldr	r7, .L22+20
  99 0094 98B19FE5 		ldr	fp, .L22+24
3452:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3453:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3454:../uvc.c      **** 	//CyU3PThreadSleep(100);
3455:../uvc.c      **** 	//SetCurCmd();
3456:../uvc.c      **** 	/*********** the loop of the thread ***********/
3457:../uvc.c      **** 	for(;;){
3458:../uvc.c      **** 
3459:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3459 0
 101 0098 0060E0E3 		mvn	r6, #0
3460:../uvc.c      **** /*  // for test GPIO output
3461:../uvc.c      **** 		if(trigger)
3462:../uvc.c      **** 		{
3463:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3464:../uvc.c      **** 			{
3465:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3466:../uvc.c      **** 			}
3467:../uvc.c      **** 
3468:../uvc.c      **** 		}else{
3469:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3470:../uvc.c      **** 			{
3471:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3472:../uvc.c      **** 			}
3473:../uvc.c      **** 
3474:../uvc.c      **** 		}
3475:../uvc.c      **** */
3476:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3477:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3478:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3479:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3480:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3481:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3482:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3483:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3484:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3485:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3486:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3487:../uvc.c      **** #endif
3488:../uvc.c      **** 				}
3489:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3490:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3491:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3492:../uvc.c      **** 			}
3493:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3494:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3495:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3496:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3497:../uvc.c      **** 
3498:../uvc.c      **** 				/*
3499:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3500:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3501:../uvc.c      **** 				*/
3502:../uvc.c      **** 
3503:../uvc.c      **** 				/* find a available command */
3504:../uvc.c      **** 				i = 0;
3505:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3505 0
 103 009c 0090A0E3 		mov	r9, #0
3506:../uvc.c      **** 					i++;
3507:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3508:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3509:../uvc.c      **** 				}
3510:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3511:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
3512:../uvc.c      **** 					i = lcCmdDes->curNum;
3513:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3514:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3515:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3516:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3517:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3518:../uvc.c      **** 						case 20:
3519:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
3520:../uvc.c      **** 							delaytime = 500;
3521:../uvc.c      **** 							break;
3522:../uvc.c      **** 						case 21:
3523:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3524:../uvc.c      **** 							delaytime = 500;
3525:../uvc.c      **** 							break;
3526:../uvc.c      **** 						case 22:
3527:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3528:../uvc.c      **** 							delaytime = 300;
3529:../uvc.c      **** 							break;
3530:../uvc.c      **** 						case 23:
3531:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3532:../uvc.c      **** 							delaytime = 300;
3533:../uvc.c      **** 							break;
3534:../uvc.c      **** 						default:
3535:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3536:../uvc.c      **** 							break;
3537:../uvc.c      **** 					}
3538:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3539:../uvc.c      **** 					/** timer's ticket modify **/
3540:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3541:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3542:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3543:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3544:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3545:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3546:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3547:../uvc.c      **** #endif
3548:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3549:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3550:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3551:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
3552:../uvc.c      **** 						}else{
3553:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3554:../uvc.c      **** 						}
3555:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3556:../uvc.c      **** 					}else{
3557:../uvc.c      **** 						lcCmdDes->curNum ++;
3558:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3558 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3459:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3459 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 80019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3476:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3476 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3493:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3493 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3495:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3495 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3496:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3496 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3505:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3505 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3507:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3507 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3506:../uvc.c      **** 					i++;
 140              		.loc 1 3506 0
 141 00f4 011083E2 		add	r1, r3, #1
3505:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3505 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3506:../uvc.c      **** 					i++;
 144              		.loc 1 3506 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3505:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3505 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3511:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
 154              		.loc 1 3511 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2D00000A 		beq	.L6
 157              	.LVL10:
3513:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3513 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3517:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3517 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3513:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3513 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3517:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3517 0
 166 0128 14C042E2 		sub	ip, r2, #20
3513:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3513 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3514:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3514 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3515:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3515 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3516:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3516 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3517:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3517 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 C0010000 		.word	.L8
 185 014c A4010000 		.word	.L9
 186 0150 58010000 		.word	.L11
 187 0154 58010000 		.word	.L11
 188              	.L11:
3531:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 189              		.loc 1 3531 0
 190 0158 8230A0E3 		mov	r3, #130
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
3533:../uvc.c      **** 							break;
 193              		.loc 1 3533 0
 194 0160 4B1FA0E3 		mov	r1, #300
 195              	.LVL16:
 196              	.L13:
3540:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 3540 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 B0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
3541:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 3541 0
 202 0170 A8009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
3548:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 3548 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
3557:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 3557 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 3558 0
 213 018c 3C808415 		strne	r8, [r4, #60]
3548:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 3548 0
 215 0190 1400000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
3559:../uvc.c      **** 					}
3560:../uvc.c      **** 				}else{
3561:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3562:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3563:../uvc.c      **** 				}
3564:../uvc.c      **** 			}
3565:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 3565 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
3566:../uvc.c      **** /*
3567:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3568:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3569:../uvc.c      **** */
3570:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3571:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3572:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3573:../uvc.c      **** #endif
3574:../uvc.c      **** 
3575:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3576:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3577:../uvc.c      **** #if 0
3578:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3579:../uvc.c      **** 
3580:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3581:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3582:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3583:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3584:../uvc.c      **** 			    i = 0;
3585:../uvc.c      **** 				 switch(cmdCopyIdx)
3586:../uvc.c      **** 				 {
3587:../uvc.c      **** 					 case BrgtCtlID1:
3588:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3589:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3590:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3591:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3592:../uvc.c      **** 							 i++;
3593:../uvc.c      **** 						 }
3594:../uvc.c      **** 						 else{
3595:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3596:../uvc.c      **** 						 }
3597:../uvc.c      **** 
3598:../uvc.c      **** 						 CyU3PBusyWait(500);
3599:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3600:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3601:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3602:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3603:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3604:../uvc.c      **** 						 }
3605:../uvc.c      **** 						 else{
3606:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3607:../uvc.c      **** 						 }
3608:../uvc.c      **** 						 break;
3609:../uvc.c      **** 					 case HueCtlID5:
3610:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3611:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3612:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3613:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3614:../uvc.c      **** 						 }
3615:../uvc.c      **** 						 else{
3616:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3617:../uvc.c      **** 						 }
3618:../uvc.c      **** 						 break;
3619:../uvc.c      **** 					 case SaturCtlID6:
3620:../uvc.c      **** 					 case WBTLevCtlID10:
3621:../uvc.c      **** 					 default:
3622:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3623:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3624:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3625:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3626:../uvc.c      **** 						 }
3627:../uvc.c      **** 						 else{
3628:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3629:../uvc.c      **** 						 }
3630:../uvc.c      **** 						 break;
3631:../uvc.c      **** 				 }
3632:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3633:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3634:../uvc.c      **** 			}
3635:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3636:../uvc.c      **** #endif
3637:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3638:../uvc.c      **** 		/* Allow other ready threads to run. */
3639:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3640:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 3640 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
3641:../uvc.c      **** 		}
 224              		.loc 1 3641 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L9:
3523:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 228              		.loc 1 3523 0
 229 01a4 5230A0E3 		mov	r3, #82
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
3525:../uvc.c      **** 							break;
 232              		.loc 1 3525 0
 233 01ac 7D1FA0E3 		mov	r1, #500
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
3535:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 3535 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
3536:../uvc.c      **** 							break;
 241              		.loc 1 3536 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L8:
3519:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 245              		.loc 1 3519 0
 246 01c0 8230A0E3 		mov	r3, #130
 247 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 248              	.LVL25:
3521:../uvc.c      **** 							break;
 249              		.loc 1 3521 0
 250 01c8 7D1FA0E3 		mov	r1, #500
 251 01cc E4FFFFEA 		b	.L13
 252              	.LVL26:
 253              	.L6:
3561:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 254              		.loc 1 3561 0
 255 01d0 FA1FA0E3 		mov	r1, #1000
 256 01d4 44009FE5 		ldr	r0, .L22+4
 257 01d8 FEFFFFEB 		bl	_txe_timer_change
3562:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 258              		.loc 1 3562 0
 259 01dc 3C009FE5 		ldr	r0, .L22+4
 260 01e0 FEFFFFEB 		bl	_txe_timer_activate
 261 01e4 EAFFFFEA 		b	.L17
 262              	.LVL27:
 263              	.L21:
3550:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 264              		.loc 1 3550 0
 265 01e8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3549:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 266              		.loc 1 3549 0
 267 01ec 3C9084E5 		str	r9, [r4, #60]
3550:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 268              		.loc 1 3550 0
 269 01f0 1F005CE3 		cmp	ip, #31
3551:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 270              		.loc 1 3551 0
 271 01f4 20C04C82 		subhi	ip, ip, #32
 272 01f8 8CC08C80 		addhi	ip, ip, ip, asl #1
3553:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 273              		.loc 1 3553 0
 274 01fc 8CC08C90 		addls	ip, ip, ip, asl #1
3551:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 275              		.loc 1 3551 0
 276 0200 8CC18B80 		addhi	ip, fp, ip, asl #3
3553:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 277              		.loc 1 3553 0
 278 0204 8CC18B90 		addls	ip, fp, ip, asl #3
3551:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 279              		.loc 1 3551 0
 280 0208 1090CC85 		strhib	r9, [ip, #16]
3553:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 281              		.loc 1 3553 0
 282 020c 9091CC95 		strlsb	r9, [ip, #400]
3555:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 283              		.loc 1 3555 0
 284 0210 344094E5 		ldr	r4, [r4, #52]
 285              	.LVL28:
 286 0214 104085E5 		str	r4, [r5, #16]
 287 0218 DDFFFFEA 		b	.L17
 288              	.L23:
 289              		.align	2
 290              	.L22:
 291 021c 00000000 		.word	I2CCmdCb
 292 0220 00000000 		.word	I2CCmdTimer
 293 0224 00000000 		.word	.LC0
 294 0228 00000000 		.word	cmdQu
 295 022c 14000000 		.word	.LC1
 296 0230 00000000 		.word	statQu
 297 0234 00000000 		.word	.LANCHOR1
 298 0238 00000000 		.word	.LANCHOR0
 299              		.cfi_endproc
 300              	.LFE25:
 302              		.align	2
 303              		.global	I2CCmdCb
 305              	I2CCmdCb:
 306              	.LFB17:
2179:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 307              		.loc 1 2179 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311              		@ link register save eliminated.
 312              	.LVL29:
2181:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 313              		.loc 1 2181 0
 314 023c 08009FE5 		ldr	r0, .L25
 315              	.LVL30:
 316 0240 2010A0E3 		mov	r1, #32
 317 0244 0020A0E3 		mov	r2, #0
2182:../uvc.c      **** }
 318              		.loc 1 2182 0
2181:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 319              		.loc 1 2181 0
 320 0248 FEFFFFEA 		b	_txe_event_flags_set
 321              	.L26:
 322              		.align	2
 323              	.L25:
 324 024c 00000000 		.word	.LANCHOR0
 325              		.cfi_endproc
 326              	.LFE17:
 328              		.align	2
 329              		.global	CyFxGpifCB
 331              	CyFxGpifCB:
 332              	.LFB12:
1613:../uvc.c      **** {
 333              		.loc 1 1613 0
 334              		.cfi_startproc
 335              		@ args = 0, pretend = 0, frame = 0
 336              		@ frame_needed = 0, uses_anonymous_args = 0
 337              	.LVL31:
1614:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 338              		.loc 1 1614 0
 339 0250 010050E3 		cmp	r0, #1
1613:../uvc.c      **** {
 340              		.loc 1 1613 0
 341 0254 10402DE9 		stmfd	sp!, {r4, lr}
 342              	.LCFI2:
 343              		.cfi_def_cfa_offset 8
1613:../uvc.c      **** {
 344              		.loc 1 1613 0
 345 0258 0120A0E1 		mov	r2, r1
1614:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 346              		.loc 1 1614 0
 347 025c 1080BD18 		ldmnefd	sp!, {r4, pc}
 348              		.cfi_offset 14, -4
 349              		.cfi_offset 4, -8
1616:../uvc.c      ****         hitFV = CyTrue;
 350              		.loc 1 1616 0
 351 0260 C4109FE5 		ldr	r1, .L43
 352              	.LVL32:
 353              	.LBB12:
 354              	.LBB14:
1512:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 355              		.loc 1 1512 0
 356 0264 2C30D1E5 		ldrb	r3, [r1, #44]	@ zero_extendqisi2
 357              	.LBE14:
 358              	.LBE12:
1616:../uvc.c      ****         hitFV = CyTrue;
 359              		.loc 1 1616 0
 360 0268 280081E5 		str	r0, [r1, #40]
 361              	.LVL33:
 362              	.LBB18:
 363              	.LBB13:
1512:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 364              		.loc 1 1512 0
 365 026c 030053E3 		cmp	r3, #3
 366 0270 0D00000A 		beq	.L42
1537:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 367              		.loc 1 1537 0
 368 0274 020053E3 		cmp	r3, #2
 369 0278 1080BD18 		ldmnefd	sp!, {r4, pc}
1539:../uvc.c      ****         switch (stateId)
 370              		.loc 1 1539 0
 371 027c 0D0052E3 		cmp	r2, #13
 372 0280 1080BD08 		ldmeqfd	sp!, {r4, pc}
 373 0284 2100008A 		bhi	.L37
 374 0288 080052E3 		cmp	r2, #8
 375 028c 0F00000A 		beq	.L31
 376              	.L35:
1585:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 377              		.loc 1 1585 0
 378 0290 98109FE5 		ldr	r1, .L43+4
 379 0294 0100A0E3 		mov	r0, #1
 380              	.LVL34:
 381 0298 FEFFFFEB 		bl	CyU3PDebugPrint
 382              	.LVL35:
 383              	.LBE13:
 384              	.LBE18:
1618:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 385              		.loc 1 1618 0
 386 029c 90109FE5 		ldr	r1, .L43+8
 387 02a0 0400A0E3 		mov	r0, #4
1621:../uvc.c      **** }
 388              		.loc 1 1621 0
 389 02a4 1040BDE8 		ldmfd	sp!, {r4, lr}
1618:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 390              		.loc 1 1618 0
 391 02a8 FEFFFFEA 		b	CyU3PDebugPrint
 392              	.LVL36:
 393              	.L42:
 394              	.LBB19:
 395              	.LBB17:
1514:../uvc.c      ****         switch (stateId)
 396              		.loc 1 1514 0
 397 02ac 0B3042E2 		sub	r3, r2, #11
 398 02b0 030053E3 		cmp	r3, #3
 399 02b4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 400 02b8 F4FFFFEA 		b	.L35
 401              	.L33:
 402 02bc D0020000 		.word	.L31
 403 02c0 08030000 		.word	.L40
 404 02c4 CC020000 		.word	.L27
 405 02c8 CC020000 		.word	.L27
 406              	.LVL37:
 407              	.L27:
 408 02cc 1080BDE8 		ldmfd	sp!, {r4, pc}
 409              	.LVL38:
 410              	.L31:
1523:../uvc.c      ****                 socket = 0;
 411              		.loc 1 1523 0
 412 02d0 0010A0E3 		mov	r1, #0
 413              	.L32:
 414              	.LVL39:
1596:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 415              		.loc 1 1596 0
 416 02d4 5C009FE5 		ldr	r0, .L43+12
 417              	.LVL40:
 418 02d8 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 419              	.LVL41:
1597:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 420              		.loc 1 1597 0
 421 02dc 004050E2 		subs	r4, r0, #0
 422 02e0 F9FFFF0A 		beq	.L27
1599:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 423              		.loc 1 1599 0
 424 02e4 50109FE5 		ldr	r1, .L43+16
 425 02e8 0420A0E1 		mov	r2, r4
 426 02ec 0400A0E3 		mov	r0, #4
 427              	.LVL42:
 428 02f0 FEFFFFEB 		bl	CyU3PDebugPrint
 429              	.LVL43:
 430              	.LBB15:
 431              	.LBB16:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 432              		.loc 1 1214 0
 433 02f4 0400A0E3 		mov	r0, #4
 434 02f8 40109FE5 		ldr	r1, .L43+20
 435 02fc 0420A0E1 		mov	r2, r4
 436 0300 FEFFFFEB 		bl	CyU3PDebugPrint
 437              	.L38:
 438 0304 FEFFFFEA 		b	.L38
 439              	.LVL44:
 440              	.L40:
 441              	.LBE16:
 442              	.LBE15:
1527:../uvc.c      ****                 socket = 1;
 443              		.loc 1 1527 0
 444 0308 0110A0E3 		mov	r1, #1
 445 030c F0FFFFEA 		b	.L32
 446              	.L37:
1539:../uvc.c      ****         switch (stateId)
 447              		.loc 1 1539 0
 448 0310 120052E3 		cmp	r2, #18
 449 0314 0200000A 		beq	.L41
 450 0318 160052E3 		cmp	r2, #22
 451 031c DBFFFF1A 		bne	.L35
 452 0320 1080BDE8 		ldmfd	sp!, {r4, pc}
 453              	.L41:
1553:../uvc.c      ****                 socket = 1;
 454              		.loc 1 1553 0
 455 0324 0010A0E1 		mov	r1, r0
 456 0328 E9FFFFEA 		b	.L32
 457              	.L44:
 458              		.align	2
 459              	.L43:
 460 032c 00000000 		.word	.LANCHOR0
 461 0330 38000000 		.word	.LC2
 462 0334 98000000 		.word	.LC5
 463 0338 00000000 		.word	glChHandleUVCStream
 464 033c 50000000 		.word	.LC3
 465 0340 80000000 		.word	.LC4
 466              	.LBE17:
 467              	.LBE19:
 468              		.cfi_endproc
 469              	.LFE12:
 471              		.align	2
 472              		.global	CyFxUvcApplnDmaCallback
 474              	CyFxUvcApplnDmaCallback:
 475              	.LFB10:
1445:../uvc.c      **** {
 476              		.loc 1 1445 0
 477              		.cfi_startproc
 478              		@ args = 0, pretend = 0, frame = 0
 479              		@ frame_needed = 0, uses_anonymous_args = 0
 480              	.LVL45:
1452:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 481              		.loc 1 1452 0
 482 0344 080051E3 		cmp	r1, #8
1445:../uvc.c      **** {
 483              		.loc 1 1445 0
 484 0348 30402DE9 		stmfd	sp!, {r4, r5, lr}
 485              	.LCFI3:
 486              		.cfi_def_cfa_offset 12
 487 034c 0240A0E1 		mov	r4, r2
 488              		.cfi_offset 14, -4
 489              		.cfi_offset 5, -8
 490              		.cfi_offset 4, -12
 491 0350 0CD04DE2 		sub	sp, sp, #12
 492              	.LCFI4:
 493              		.cfi_def_cfa_offset 24
1452:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 494              		.loc 1 1452 0
 495 0354 0B00000A 		beq	.L50
1485:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 496              		.loc 1 1485 0
 497 0358 100051E3 		cmp	r1, #16
 498 035c 0700001A 		bne	.L45
1487:../uvc.c      ****         consCount++;
 499              		.loc 1 1487 0
 500 0360 18319FE5 		ldr	r3, .L52
1488:../uvc.c      ****         streamingStarted = CyTrue;
 501              		.loc 1 1488 0
 502 0364 0110A0E3 		mov	r1, #1
 503              	.LVL46:
1487:../uvc.c      ****         consCount++;
 504              		.loc 1 1487 0
 505 0368 B8C3D3E1 		ldrh	ip, [r3, #56]
1488:../uvc.c      ****         streamingStarted = CyTrue;
 506              		.loc 1 1488 0
 507 036c 3C1083E5 		str	r1, [r3, #60]
1487:../uvc.c      ****         consCount++;
 508              		.loc 1 1487 0
 509 0370 01008CE0 		add	r0, ip, r1
 510              	.LVL47:
 511 0374 0028A0E1 		mov	r2, r0, asl #16
 512              	.LVL48:
 513 0378 2218A0E1 		mov	r1, r2, lsr #16
 514 037c B813C3E1 		strh	r1, [r3, #56]	@ movhi
 515              	.L45:
1492:../uvc.c      **** }
 516              		.loc 1 1492 0
 517 0380 0CD08DE2 		add	sp, sp, #12
 518 0384 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 519              	.LVL49:
 520              	.L50:
1454:../uvc.c      ****             if (input->buffer_p.count == 0xB70/*CY_FX_UVC_BUF_FULL_SIZE*/)
 521              		.loc 1 1454 0
 522 0388 B430D2E1 		ldrh	r3, [r2, #4]
 523 038c B70E53E3 		cmp	r3, #2928
 524 0390 2D00000A 		beq	.L51
1463:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 525              		.loc 1 1463 0
 526 0394 005092E5 		ldr	r5, [r2, #0]
 527              	.LVL50:
 528              	.LBB24:
 529              	.LBB25:
1189:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 530              		.loc 1 1189 0
 531 0398 E4109FE5 		ldr	r1, .L52+4
 532              	.LVL51:
 533 039c 0C0045E2 		sub	r0, r5, #12
 534              	.LVL52:
 535 03a0 0C20A0E3 		mov	r2, #12
 536 03a4 FEFFFFEB 		bl	CyU3PMemCopy
 537              	.LVL53:
1194:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 538              		.loc 1 1194 0
 539 03a8 0B2055E5 		ldrb	r2, [r5, #-11]	@ zero_extendqisi2
 540              	.LBE25:
 541              	.LBE24:
1464:../uvc.c      ****                 pb++;
 542              		.loc 1 1464 0
 543 03ac CC309FE5 		ldr	r3, .L52
 544              	.LBB27:
 545              	.LBB26:
1194:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 546              		.loc 1 1194 0
 547 03b0 021082E3 		orr	r1, r2, #2
 548 03b4 0B1045E5 		strb	r1, [r5, #-11]
 549              	.LBE26:
 550              	.LBE27:
1464:../uvc.c      ****                 pb++;
 551              		.loc 1 1464 0
 552 03b8 B203D3E1 		ldrh	r0, [r3, #50]
1465:../uvc.c      ****                 pbc = input->buffer_p.count;
 553              		.loc 1 1465 0
 554 03bc B410D4E1 		ldrh	r1, [r4, #4]
1464:../uvc.c      ****                 pb++;
 555              		.loc 1 1464 0
 556 03c0 012080E2 		add	r2, r0, #1
1466:../uvc.c      ****                 takeFull = 0;
 557              		.loc 1 1466 0
 558 03c4 00C0A0E3 		mov	ip, #0	@ movhi
 559 03c8 B0C3C3E1 		strh	ip, [r3, #48]	@ movhi
1464:../uvc.c      ****                 pb++;
 560              		.loc 1 1464 0
 561 03cc B223C3E1 		strh	r2, [r3, #50]	@ movhi
1465:../uvc.c      ****                 pbc = input->buffer_p.count;
 562              		.loc 1 1465 0
 563 03d0 B413C3E1 		strh	r1, [r3, #52]	@ movhi
 564              	.LVL54:
 565              	.L48:
1473:../uvc.c      ****             prodCount++;
 566              		.loc 1 1473 0
 567 03d4 B6E3D3E1 		ldrh	lr, [r3, #54]
1474:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 568              		.loc 1 1474 0
 569 03d8 0C0081E2 		add	r0, r1, #12
1473:../uvc.c      ****             prodCount++;
 570              		.loc 1 1473 0
 571 03dc 01208EE2 		add	r2, lr, #1
 572 03e0 02C8A0E1 		mov	ip, r2, asl #16
1474:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 573              		.loc 1 1474 0
 574 03e4 0018A0E1 		mov	r1, r0, asl #16
1473:../uvc.c      ****             prodCount++;
 575              		.loc 1 1473 0
 576 03e8 2CE8A0E1 		mov	lr, ip, lsr #16
1474:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 577              		.loc 1 1474 0
 578 03ec 2118A0E1 		mov	r1, r1, lsr #16
 579 03f0 0020A0E3 		mov	r2, #0
 580 03f4 8C009FE5 		ldr	r0, .L52+8
1473:../uvc.c      ****             prodCount++;
 581              		.loc 1 1473 0
 582 03f8 B6E3C3E1 		strh	lr, [r3, #54]	@ movhi
1474:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 583              		.loc 1 1474 0
 584 03fc FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 585              	.LVL55:
1473:../uvc.c      ****             prodCount++;
 586              		.loc 1 1473 0
 587 0400 78109FE5 		ldr	r1, .L52
1477:../uvc.c      ****             if (1 & (status != CY_U3P_SUCCESS))
 588              		.loc 1 1477 0
 589 0404 002050E2 		subs	r2, r0, #0
 590 0408 DCFFFF0A 		beq	.L45
1479:../uvc.c      ****                 prodCount--;
 591              		.loc 1 1479 0
 592 040c B6C3D1E1 		ldrh	ip, [r1, #54]
1480:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 593              		.loc 1 1480 0
 594 0410 B430D4E1 		ldrh	r3, [r4, #4]
1479:../uvc.c      ****                 prodCount--;
 595              		.loc 1 1479 0
 596 0414 01004CE2 		sub	r0, ip, #1
 597              	.LVL56:
 598 0418 00E8A0E1 		mov	lr, r0, asl #16
 599 041c 2EC8A0E1 		mov	ip, lr, lsr #16
 600 0420 B6C3C1E1 		strh	ip, [r1, #54]	@ movhi
1480:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 601              		.loc 1 1480 0
 602 0424 B6E3D1E1 		ldrh	lr, [r1, #54]
 603 0428 B803D1E1 		ldrh	r0, [r1, #56]
 604 042c B0C3D1E1 		ldrh	ip, [r1, #48]
 605 0430 0EE060E0 		rsb	lr, r0, lr
 606 0434 50109FE5 		ldr	r1, .L52+12
 607 0438 0400A0E3 		mov	r0, #4
 608 043c 00E08DE5 		str	lr, [sp, #0]
 609 0440 04C08DE5 		str	ip, [sp, #4]
 610 0444 FEFFFFEB 		bl	CyU3PDebugPrint
 611              	.LVL57:
 612 0448 CCFFFFEA 		b	.L45
 613              	.LVL58:
 614              	.L51:
1456:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 615              		.loc 1 1456 0
 616 044c 00E092E5 		ldr	lr, [r2, #0]
 617              	.LBB28:
 618              	.LBB29:
1189:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 619              		.loc 1 1189 0
 620 0450 2C109FE5 		ldr	r1, .L52+4
 621              	.LVL59:
 622 0454 0C004EE2 		sub	r0, lr, #12
 623              	.LVL60:
 624 0458 0C20A0E3 		mov	r2, #12
 625 045c FEFFFFEB 		bl	CyU3PMemCopy
 626              	.LVL61:
 627              	.LBE29:
 628              	.LBE28:
1457:../uvc.c      ****                 fb++;
 629              		.loc 1 1457 0
 630 0460 18309FE5 		ldr	r3, .L52
1458:../uvc.c      ****                 takeFull = 1;
 631              		.loc 1 1458 0
 632 0464 0100A0E3 		mov	r0, #1	@ movhi
1457:../uvc.c      ****                 fb++;
 633              		.loc 1 1457 0
 634 0468 BEC2D3E1 		ldrh	ip, [r3, #46]
1458:../uvc.c      ****                 takeFull = 1;
 635              		.loc 1 1458 0
 636 046c B410D4E1 		ldrh	r1, [r4, #4]
1457:../uvc.c      ****                 fb++;
 637              		.loc 1 1457 0
 638 0470 01208CE2 		add	r2, ip, #1
1458:../uvc.c      ****                 takeFull = 1;
 639              		.loc 1 1458 0
 640 0474 B003C3E1 		strh	r0, [r3, #48]	@ movhi
1457:../uvc.c      ****                 fb++;
 641              		.loc 1 1457 0
 642 0478 BE22C3E1 		strh	r2, [r3, #46]	@ movhi
 643 047c D4FFFFEA 		b	.L48
 644              	.L53:
 645              		.align	2
 646              	.L52:
 647 0480 00000000 		.word	.LANCHOR0
 648 0484 80040000 		.word	.LANCHOR1+1152
 649 0488 00000000 		.word	glChHandleUVCStream
 650 048c AC000000 		.word	.LC6
 651              		.cfi_endproc
 652              	.LFE10:
 654              		.align	2
 656              	CyFxUVCApplnUSBEventCB:
 657              	.LFB8:
1244:../uvc.c      **** {
 658              		.loc 1 1244 0
 659              		.cfi_startproc
 660              		@ args = 0, pretend = 0, frame = 8
 661              		@ frame_needed = 0, uses_anonymous_args = 0
 662              	.LVL62:
1245:../uvc.c      ****     switch (evtype)
 663              		.loc 1 1245 0
 664 0490 020050E3 		cmp	r0, #2
1244:../uvc.c      **** {
 665              		.loc 1 1244 0
 666 0494 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 667              	.LCFI5:
 668              		.cfi_def_cfa_offset 16
 669 0498 0130A0E1 		mov	r3, r1
 670 049c 10D04DE2 		sub	sp, sp, #16
 671              	.LCFI6:
 672              		.cfi_def_cfa_offset 32
1244:../uvc.c      **** {
 673              		.loc 1 1244 0
 674 04a0 0040A0E1 		mov	r4, r0
 675              		.cfi_offset 14, -4
 676              		.cfi_offset 6, -8
 677              		.cfi_offset 5, -12
 678              		.cfi_offset 4, -16
1245:../uvc.c      ****     switch (evtype)
 679              		.loc 1 1245 0
 680 04a4 3600000A 		beq	.L57
 681 04a8 040050E3 		cmp	r0, #4
 682 04ac 1F00000A 		beq	.L58
 683 04b0 010050E3 		cmp	r0, #1
 684 04b4 0100000A 		beq	.L60
 685              	.LVL63:
 686              	.L54:
1281:../uvc.c      **** }
 687              		.loc 1 1281 0
 688 04b8 10D08DE2 		add	sp, sp, #16
 689 04bc 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 690              	.LVL64:
 691              	.L60:
1266:../uvc.c      ****             gpif_initialized = 0;
 692              		.loc 1 1266 0
 693 04c0 28519FE5 		ldr	r5, .L61
1264:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 694              		.loc 1 1264 0
 695 04c4 0020A0E1 		mov	r2, r0
 696 04c8 24119FE5 		ldr	r1, .L61+4
 697              	.LVL65:
 698 04cc 0400A0E3 		mov	r0, #4
 699              	.LVL66:
 700 04d0 FEFFFFEB 		bl	CyU3PDebugPrint
1265:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 701              		.loc 1 1265 0
 702 04d4 0400A0E1 		mov	r0, r4
 703 04d8 FEFFFFEB 		bl	CyU3PGpifDisable
1266:../uvc.c      ****             gpif_initialized = 0;
 704              		.loc 1 1266 0
 705 04dc 00C0A0E3 		mov	ip, #0
 706              	.LBB36:
 707              	.LBB37:
1228:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 708              		.loc 1 1228 0
 709 04e0 0410A0E1 		mov	r1, r4
 710 04e4 0500A0E1 		mov	r0, r5
 711 04e8 0220A0E3 		mov	r2, #2
 712 04ec 0C308DE2 		add	r3, sp, #12
 713              	.LBE37:
 714              	.LBE36:
1266:../uvc.c      ****             gpif_initialized = 0;
 715              		.loc 1 1266 0
 716 04f0 40C085E5 		str	ip, [r5, #64]
1267:../uvc.c      ****             isUsbConnected = CyFalse;
 717              		.loc 1 1267 0
 718 04f4 44C085E5 		str	ip, [r5, #68]
1268:../uvc.c      ****             streamingStarted = CyFalse;
 719              		.loc 1 1268 0
 720 04f8 3CC085E5 		str	ip, [r5, #60]
 721              	.LBB39:
 722              	.LBB38:
1228:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 723              		.loc 1 1228 0
 724 04fc 00C08DE5 		str	ip, [sp, #0]
 725 0500 FEFFFFEB 		bl	_txe_event_flags_get
 726 0504 004050E2 		subs	r4, r0, #0
 727 0508 EAFFFF1A 		bne	.L54
1231:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 728              		.loc 1 1231 0
 729 050c 0110E0E3 		mvn	r1, #1
 730 0510 0220A0E3 		mov	r2, #2
 731 0514 0500A0E1 		mov	r0, r5
 732              	.L59:
 733 0518 FEFFFFEB 		bl	_txe_event_flags_set
1234:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 734              		.loc 1 1234 0
 735 051c 0500A0E1 		mov	r0, r5
 736 0520 0210A0E3 		mov	r1, #2
 737 0524 0420A0E1 		mov	r2, r4
 738 0528 FEFFFFEB 		bl	_txe_event_flags_set
 739 052c E1FFFFEA 		b	.L54
 740              	.LVL67:
 741              	.L58:
 742              	.LBE38:
 743              	.LBE39:
1250:../uvc.c      ****             gpif_initialized = 0;
 744              		.loc 1 1250 0
 745 0530 B8509FE5 		ldr	r5, .L61
1248:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 746              		.loc 1 1248 0
 747 0534 BC109FE5 		ldr	r1, .L61+8
 748              	.LVL68:
 749 0538 0020A0E1 		mov	r2, r0
 750 053c FEFFFFEB 		bl	CyU3PDebugPrint
 751              	.LVL69:
1249:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 752              		.loc 1 1249 0
 753 0540 0100A0E3 		mov	r0, #1
 754 0544 FEFFFFEB 		bl	CyU3PGpifDisable
1250:../uvc.c      ****             gpif_initialized = 0;
 755              		.loc 1 1250 0
 756 0548 00C0A0E3 		mov	ip, #0
 757              	.LBB40:
 758              	.LBB41:
1228:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 759              		.loc 1 1228 0
 760 054c 0110A0E3 		mov	r1, #1
 761 0550 0220A0E3 		mov	r2, #2
 762 0554 0500A0E1 		mov	r0, r5
 763 0558 0C308DE2 		add	r3, sp, #12
 764              	.LBE41:
 765              	.LBE40:
1250:../uvc.c      ****             gpif_initialized = 0;
 766              		.loc 1 1250 0
 767 055c 40C085E5 		str	ip, [r5, #64]
1251:../uvc.c      ****             streamingStarted = CyFalse;
 768              		.loc 1 1251 0
 769 0560 3CC085E5 		str	ip, [r5, #60]
 770              	.LBB43:
 771              	.LBB42:
1228:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 772              		.loc 1 1228 0
 773 0564 00C08DE5 		str	ip, [sp, #0]
 774 0568 FEFFFFEB 		bl	_txe_event_flags_get
 775 056c 004050E2 		subs	r4, r0, #0
1231:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 776              		.loc 1 1231 0
 777 0570 0500A001 		moveq	r0, r5
 778 0574 0110E003 		mvneq	r1, #1
 779 0578 0220A003 		moveq	r2, #2
1228:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 780              		.loc 1 1228 0
 781 057c CDFFFF1A 		bne	.L54
 782 0580 E4FFFFEA 		b	.L59
 783              	.LVL70:
 784              	.L57:
 785              	.LBE42:
 786              	.LBE43:
1258:../uvc.c      ****             gpif_initialized = 0;
 787              		.loc 1 1258 0
 788 0584 64509FE5 		ldr	r5, .L61
1256:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 789              		.loc 1 1256 0
 790 0588 0020A0E1 		mov	r2, r0
 791 058c 68109FE5 		ldr	r1, .L61+12
 792              	.LVL71:
 793 0590 0400A0E3 		mov	r0, #4
 794              	.LVL72:
 795 0594 FEFFFFEB 		bl	CyU3PDebugPrint
1257:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 796              		.loc 1 1257 0
 797 0598 0100A0E3 		mov	r0, #1
 798 059c FEFFFFEB 		bl	CyU3PGpifDisable
1258:../uvc.c      ****             gpif_initialized = 0;
 799              		.loc 1 1258 0
 800 05a0 0060A0E3 		mov	r6, #0
 801              	.LBB44:
 802              	.LBB45:
1228:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 803              		.loc 1 1228 0
 804 05a4 0500A0E1 		mov	r0, r5
 805 05a8 0110A0E3 		mov	r1, #1
 806 05ac 0420A0E1 		mov	r2, r4
 807 05b0 0C308DE2 		add	r3, sp, #12
 808              	.LBE45:
 809              	.LBE44:
1258:../uvc.c      ****             gpif_initialized = 0;
 810              		.loc 1 1258 0
 811 05b4 406085E5 		str	r6, [r5, #64]
1259:../uvc.c      ****             streamingStarted = CyFalse;
 812              		.loc 1 1259 0
 813 05b8 3C6085E5 		str	r6, [r5, #60]
 814              	.LBB47:
 815              	.LBB46:
1228:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 816              		.loc 1 1228 0
 817 05bc 00608DE5 		str	r6, [sp, #0]
 818 05c0 FEFFFFEB 		bl	_txe_event_flags_get
 819 05c4 006050E2 		subs	r6, r0, #0
 820 05c8 BAFFFF1A 		bne	.L54
1231:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 821              		.loc 1 1231 0
 822 05cc 0420A0E1 		mov	r2, r4
 823 05d0 0500A0E1 		mov	r0, r5
 824 05d4 0110E0E3 		mvn	r1, #1
 825 05d8 FEFFFFEB 		bl	_txe_event_flags_set
1234:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 826              		.loc 1 1234 0
 827 05dc 0500A0E1 		mov	r0, r5
 828 05e0 0410A0E1 		mov	r1, r4
 829 05e4 0620A0E1 		mov	r2, r6
 830 05e8 FEFFFFEB 		bl	_txe_event_flags_set
 831 05ec B1FFFFEA 		b	.L54
 832              	.L62:
 833              		.align	2
 834              	.L61:
 835 05f0 00000000 		.word	.LANCHOR0
 836 05f4 40010000 		.word	.LC9
 837 05f8 FC000000 		.word	.LC7
 838 05fc 1C010000 		.word	.LC8
 839              	.LBE46:
 840              	.LBE47:
 841              		.cfi_endproc
 842              	.LFE8:
 844              		.align	2
 846              	CyFxUVCApplnUSBSetupCB:
 847              	.LFB9:
1289:../uvc.c      **** {
 848              		.loc 1 1289 0
 849              		.cfi_startproc
 850              		@ args = 0, pretend = 0, frame = 8
 851              		@ frame_needed = 0, uses_anonymous_args = 0
 852              	.LVL73:
 853 0600 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 854              	.LCFI7:
 855              		.cfi_def_cfa_offset 28
1294:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 856              		.loc 1 1294 0
 857 0604 E4229FE5 		ldr	r2, .L94
 858 0608 FF4000E2 		and	r4, r0, #255
 859              		.cfi_offset 14, -4
 860              		.cfi_offset 10, -8
 861              		.cfi_offset 8, -12
 862              		.cfi_offset 7, -16
 863              		.cfi_offset 6, -20
 864              		.cfi_offset 5, -24
 865              		.cfi_offset 4, -28
1295:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 866              		.loc 1 1295 0
 867 060c FFAC00E2 		and	sl, r0, #65280
1296:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 868              		.loc 1 1296 0
 869 0610 2068A0E1 		mov	r6, r0, lsr #16
 870 0614 D8729FE5 		ldr	r7, .L94+4
1297:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 871              		.loc 1 1297 0
 872 0618 D8829FE5 		ldr	r8, .L94+8
1295:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 873              		.loc 1 1295 0
 874 061c D8029FE5 		ldr	r0, .L94+12
 875              	.LVL74:
1298:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 876              		.loc 1 1298 0
 877 0620 D8329FE5 		ldr	r3, .L94+16
1297:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 878              		.loc 1 1297 0
 879 0624 0158A0E1 		mov	r5, r1, asl #16
1295:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 880              		.loc 1 1295 0
 881 0628 2AA4A0E1 		mov	sl, sl, lsr #8
1297:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 882              		.loc 1 1297 0
 883 062c 2558A0E1 		mov	r5, r5, lsr #16
1298:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 884              		.loc 1 1298 0
 885 0630 2118A0E1 		mov	r1, r1, lsr #16
 886              	.LVL75:
1301:../uvc.c      ****     switch (bmReqType)
 887              		.loc 1 1301 0
 888 0634 020054E3 		cmp	r4, #2
1289:../uvc.c      **** {
 889              		.loc 1 1289 0
 890 0638 14D04DE2 		sub	sp, sp, #20
 891              	.LCFI8:
 892              		.cfi_def_cfa_offset 48
1294:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 893              		.loc 1 1294 0
 894 063c 0040C2E5 		strb	r4, [r2, #0]
1295:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 895              		.loc 1 1295 0
 896 0640 00A0C0E5 		strb	sl, [r0, #0]
1296:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 897              		.loc 1 1296 0
 898 0644 B060C7E1 		strh	r6, [r7, #0]	@ movhi
1297:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 899              		.loc 1 1297 0
 900 0648 B050C8E1 		strh	r5, [r8, #0]	@ movhi
1298:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 901              		.loc 1 1298 0
 902 064c B010C3E1 		strh	r1, [r3, #0]	@ movhi
1301:../uvc.c      ****     switch (bmReqType)
 903              		.loc 1 1301 0
 904 0650 2200000A 		beq	.L66
 905 0654 0700009A 		bls	.L89
 906 0658 210054E3 		cmp	r4, #33
 907 065c 1500000A 		beq	.L67
 908 0660 A10054E3 		cmp	r4, #161
 909 0664 1300000A 		beq	.L67
 910              	.L84:
1290:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 911              		.loc 1 1290 0
 912 0668 0050A0E3 		mov	r5, #0
 913              	.LVL76:
 914              	.L64:
1432:../uvc.c      **** }
 915              		.loc 1 1432 0
 916 066c 0500A0E1 		mov	r0, r5
 917 0670 14D08DE2 		add	sp, sp, #20
 918 0674 F085BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, sl, pc}
 919              	.LVL77:
 920              	.L89:
1301:../uvc.c      ****     switch (bmReqType)
 921              		.loc 1 1301 0
 922 0678 010054E3 		cmp	r4, #1
 923 067c F9FFFF1A 		bne	.L84
1341:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 924              		.loc 1 1341 0
 925 0680 0B005AE3 		cmp	sl, #11
 926 0684 F7FFFF1A 		bne	.L84
1345:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 927              		.loc 1 1345 0
 928 0688 010055E3 		cmp	r5, #1
 929 068c F5FFFF1A 		bne	.L84
1345:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 930              		.loc 1 1345 0 is_stmt 0 discriminator 1
 931 0690 000056E3 		cmp	r6, #0
1290:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 932              		.loc 1 1290 0 is_stmt 1 discriminator 1
 933 0694 0050A013 		movne	r5, #0
1345:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 934              		.loc 1 1345 0 discriminator 1
 935 0698 3400000A 		beq	.L90
 936              	.LVL78:
 937              	.L71:
1372:../uvc.c      ****                 if((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue != 0))
 938              		.loc 1 1372 0 discriminator 1
 939 069c B020D7E1 		ldrh	r2, [r7, #0]
 940 06a0 000052E3 		cmp	r2, #0
 941 06a4 F0FFFF0A 		beq	.L64
1374:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting %d..\r\n", wValue);
 942              		.loc 1 1374 0
 943 06a8 54129FE5 		ldr	r1, .L94+20
 944 06ac 0400A0E3 		mov	r0, #4
 945 06b0 FEFFFFEB 		bl	CyU3PDebugPrint
 946 06b4 ECFFFFEA 		b	.L64
 947              	.LVL79:
 948              	.L67:
1306:../uvc.c      ****             switch (wIndex & 0xFF)
 949              		.loc 1 1306 0
 950 06b8 FF5015E2 		ands	r5, r5, #255
 951 06bc 1200001A 		bne	.L91
 952              	.LVL80:
1311:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 953              		.loc 1 1311 0
 954 06c0 0520A0E1 		mov	r2, r5
 955 06c4 3C029FE5 		ldr	r0, .L94+24
 956 06c8 0410A0E3 		mov	r1, #4
 957 06cc FEFFFFEB 		bl	_txe_event_flags_set
 958              	.LVL81:
1313:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 959              		.loc 1 1313 0
 960 06d0 002050E2 		subs	r2, r0, #0
 961 06d4 1C00001A 		bne	.L92
1372:../uvc.c      ****                 if((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue != 0))
 962              		.loc 1 1372 0
 963 06d8 0150A0E3 		mov	r5, #1
 964 06dc E2FFFFEA 		b	.L64
 965              	.LVL82:
 966              	.L66:
1380:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 967              		.loc 1 1380 0
 968 06e0 01005AE3 		cmp	sl, #1
 969 06e4 DFFFFF1A 		bne	.L84
1382:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 970              		.loc 1 1382 0
 971 06e8 830055E3 		cmp	r5, #131
 972 06ec DDFFFF1A 		bne	.L84
1388:../uvc.c      ****                     if (streamingStarted == CyTrue)
 973              		.loc 1 1388 0
 974 06f0 10729FE5 		ldr	r7, .L94+24
 975 06f4 3C6097E5 		ldr	r6, [r7, #60]
 976 06f8 010056E3 		cmp	r6, #1
 977 06fc 4C00000A 		beq	.L93
 978              	.LVL83:
1420:../uvc.c      ****                         CyU3PUsbAckSetup ();
 979              		.loc 1 1420 0
 980 0700 FEFFFFEB 		bl	CyU3PUsbAckSetup
1419:../uvc.c      ****                         uvcHandleReq = CyTrue;
 981              		.loc 1 1419 0
 982 0704 0A50A0E1 		mov	r5, sl
 983 0708 D7FFFFEA 		b	.L64
 984              	.LVL84:
 985              	.L91:
1306:../uvc.c      ****             switch (wIndex & 0xFF)
 986              		.loc 1 1306 0
 987 070c 010055E3 		cmp	r5, #1
 988 0710 D4FFFF1A 		bne	.L84
 989              	.LVL85:
1324:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 990              		.loc 1 1324 0
 991 0714 0020A0E3 		mov	r2, #0
 992 0718 E8019FE5 		ldr	r0, .L94+24
 993 071c 0810A0E3 		mov	r1, #8
 994 0720 FEFFFFEB 		bl	_txe_event_flags_set
 995              	.LVL86:
1326:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 996              		.loc 1 1326 0
 997 0724 002050E2 		subs	r2, r0, #0
 998 0728 CFFFFF0A 		beq	.L64
1329:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 999              		.loc 1 1329 0
 1000 072c D8119FE5 		ldr	r1, .L94+28
 1001 0730 0400A0E3 		mov	r0, #4
 1002              	.LVL87:
 1003 0734 FEFFFFEB 		bl	CyU3PDebugPrint
 1004              	.LVL88:
1330:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1005              		.loc 1 1330 0
 1006 0738 0000A0E3 		mov	r0, #0
 1007 073c 0510A0E1 		mov	r1, r5
 1008 0740 0020A0E1 		mov	r2, r0
 1009 0744 FEFFFFEB 		bl	CyU3PUsbStall
 1010 0748 C7FFFFEA 		b	.L64
 1011              	.LVL89:
 1012              	.L92:
1315:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 1013              		.loc 1 1315 0
 1014 074c BC119FE5 		ldr	r1, .L94+32
 1015 0750 0400A0E3 		mov	r0, #4
 1016              	.LVL90:
 1017 0754 FEFFFFEB 		bl	CyU3PDebugPrint
 1018              	.LVL91:
1316:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1019              		.loc 1 1316 0
 1020 0758 0500A0E1 		mov	r0, r5
 1021 075c 0520A0E1 		mov	r2, r5
 1022 0760 0110A0E3 		mov	r1, #1
 1023 0764 FEFFFFEB 		bl	CyU3PUsbStall
1310:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1024              		.loc 1 1310 0
 1025 0768 0150A0E3 		mov	r5, #1
 1026 076c BEFFFFEA 		b	.L64
 1027              	.LVL92:
 1028              	.L90:
1350:../uvc.c      ****                     gpif_initialized = 0;
 1029              		.loc 1 1350 0
 1030 0770 90419FE5 		ldr	r4, .L94+24
1348:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 1031              		.loc 1 1348 0
 1032 0774 98119FE5 		ldr	r1, .L94+36
 1033 0778 0400A0E3 		mov	r0, #4
 1034 077c FEFFFFEB 		bl	CyU3PDebugPrint
1349:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 1035              		.loc 1 1349 0
 1036 0780 0500A0E1 		mov	r0, r5
 1037 0784 FEFFFFEB 		bl	CyU3PGpifDisable
1353:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1038              		.loc 1 1353 0
 1039 0788 0510A0E1 		mov	r1, r5
 1040 078c 8300A0E3 		mov	r0, #131
1350:../uvc.c      ****                     gpif_initialized = 0;
 1041              		.loc 1 1350 0
 1042 0790 406084E5 		str	r6, [r4, #64]
1351:../uvc.c      ****                     streamingStarted = CyFalse;
 1043              		.loc 1 1351 0
 1044 0794 3C6084E5 		str	r6, [r4, #60]
1353:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1045              		.loc 1 1353 0
 1046 0798 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1354:../uvc.c      ****                     CyU3PBusyWait (100);
 1047              		.loc 1 1354 0
 1048 079c 6400A0E3 		mov	r0, #100
 1049 07a0 FEFFFFEB 		bl	CyU3PBusyWait
1357:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1050              		.loc 1 1357 0
 1051 07a4 6C019FE5 		ldr	r0, .L94+40
 1052 07a8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1358:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1053              		.loc 1 1358 0
 1054 07ac 8300A0E3 		mov	r0, #131
 1055 07b0 FEFFFFEB 		bl	CyU3PUsbFlushEp
1359:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1056              		.loc 1 1359 0
 1057 07b4 0610A0E1 		mov	r1, r6
 1058 07b8 8300A0E3 		mov	r0, #131
 1059 07bc FEFFFFEB 		bl	CyU3PUsbSetEpNak
1360:../uvc.c      ****                     CyU3PBusyWait (100);
 1060              		.loc 1 1360 0
 1061 07c0 6400A0E3 		mov	r0, #100
 1062 07c4 FEFFFFEB 		bl	CyU3PBusyWait
1363:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1063              		.loc 1 1363 0
 1064 07c8 0520A0E1 		mov	r2, r5
 1065 07cc 0610A0E1 		mov	r1, r6
 1066 07d0 8300A0E3 		mov	r0, #131
 1067 07d4 FEFFFFEB 		bl	CyU3PUsbStall
 1068              	.LVL93:
1366:../uvc.c      ****                     CyU3PUsbAckSetup ();
 1069              		.loc 1 1366 0
 1070 07d8 FEFFFFEB 		bl	CyU3PUsbAckSetup
1368:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 1071              		.loc 1 1368 0
 1072 07dc 485084E5 		str	r5, [r4, #72]
 1073              	.LBB52:
 1074              	.LBB53:
1228:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1075              		.loc 1 1228 0
 1076 07e0 0510A0E1 		mov	r1, r5
 1077 07e4 0400A0E1 		mov	r0, r4
 1078 07e8 0220A0E3 		mov	r2, #2
 1079 07ec 0C308DE2 		add	r3, sp, #12
 1080 07f0 00608DE5 		str	r6, [sp, #0]
 1081 07f4 FEFFFFEB 		bl	_txe_event_flags_get
 1082 07f8 005050E2 		subs	r5, r0, #0
 1083 07fc 0700001A 		bne	.L87
1231:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1084              		.loc 1 1231 0
 1085 0800 0110E0E3 		mvn	r1, #1
 1086 0804 0220A0E3 		mov	r2, #2
 1087 0808 0400A0E1 		mov	r0, r4
 1088 080c FEFFFFEB 		bl	_txe_event_flags_set
1234:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1089              		.loc 1 1234 0
 1090 0810 0400A0E1 		mov	r0, r4
 1091 0814 0210A0E3 		mov	r1, #2
 1092 0818 0520A0E1 		mov	r2, r5
 1093 081c FEFFFFEB 		bl	_txe_event_flags_set
 1094              	.L87:
 1095 0820 B050D8E1 		ldrh	r5, [r8, #0]
 1096              	.LBE53:
 1097              	.LBE52:
1372:../uvc.c      ****                 if((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue != 0))
 1098              		.loc 1 1372 0
 1099 0824 010055E3 		cmp	r5, #1
 1100 0828 9BFFFF0A 		beq	.L71
 1101 082c 0150A0E3 		mov	r5, #1
 1102 0830 8DFFFFEA 		b	.L64
 1103              	.LVL94:
 1104              	.L93:
1390:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1105              		.loc 1 1390 0
 1106 0834 E0109FE5 		ldr	r1, .L94+44
 1107 0838 0400A0E3 		mov	r0, #4
 1108 083c FEFFFFEB 		bl	CyU3PDebugPrint
1394:../uvc.c      ****                         gpif_initialized = 0;
 1109              		.loc 1 1394 0
 1110 0840 0080A0E3 		mov	r8, #0
1393:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1111              		.loc 1 1393 0
 1112 0844 0600A0E1 		mov	r0, r6
 1113 0848 FEFFFFEB 		bl	CyU3PGpifDisable
1398:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1114              		.loc 1 1398 0
 1115 084c 0610A0E1 		mov	r1, r6
 1116 0850 0500A0E1 		mov	r0, r5
1394:../uvc.c      ****                         gpif_initialized = 0;
 1117              		.loc 1 1394 0
 1118 0854 408087E5 		str	r8, [r7, #64]
1395:../uvc.c      ****                         streamingStarted = CyFalse;
 1119              		.loc 1 1395 0
 1120 0858 3C8087E5 		str	r8, [r7, #60]
1398:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1121              		.loc 1 1398 0
 1122 085c FEFFFFEB 		bl	CyU3PUsbSetEpNak
1399:../uvc.c      ****                         CyU3PBusyWait (100);
 1123              		.loc 1 1399 0
 1124 0860 6400A0E3 		mov	r0, #100
 1125 0864 FEFFFFEB 		bl	CyU3PBusyWait
1402:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1126              		.loc 1 1402 0
 1127 0868 A8009FE5 		ldr	r0, .L94+40
 1128 086c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1403:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1129              		.loc 1 1403 0
 1130 0870 0500A0E1 		mov	r0, r5
 1131 0874 FEFFFFEB 		bl	CyU3PUsbFlushEp
1404:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1132              		.loc 1 1404 0
 1133 0878 0810A0E1 		mov	r1, r8
 1134 087c 0500A0E1 		mov	r0, r5
 1135 0880 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1405:../uvc.c      ****                         CyU3PBusyWait (100);
 1136              		.loc 1 1405 0
 1137 0884 6400A0E3 		mov	r0, #100
 1138 0888 FEFFFFEB 		bl	CyU3PBusyWait
1408:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1139              		.loc 1 1408 0
 1140 088c 0810A0E1 		mov	r1, r8
 1141 0890 0620A0E1 		mov	r2, r6
 1142 0894 0500A0E1 		mov	r0, r5
 1143 0898 FEFFFFEB 		bl	CyU3PUsbStall
 1144              	.LVL95:
1412:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1145              		.loc 1 1412 0
 1146 089c FEFFFFEB 		bl	CyU3PUsbAckSetup
1414:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1147              		.loc 1 1414 0
 1148 08a0 486087E5 		str	r6, [r7, #72]
 1149              	.LBB54:
 1150              	.LBB55:
1228:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1151              		.loc 1 1228 0
 1152 08a4 0700A0E1 		mov	r0, r7
 1153 08a8 0610A0E1 		mov	r1, r6
 1154 08ac 0420A0E1 		mov	r2, r4
 1155 08b0 0C308DE2 		add	r3, sp, #12
 1156 08b4 00808DE5 		str	r8, [sp, #0]
 1157 08b8 FEFFFFEB 		bl	_txe_event_flags_get
 1158 08bc 005050E2 		subs	r5, r0, #0
1410:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1159              		.loc 1 1410 0
 1160 08c0 0650A011 		movne	r5, r6
1228:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1161              		.loc 1 1228 0
 1162 08c4 68FFFF1A 		bne	.L64
1231:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1163              		.loc 1 1231 0
 1164 08c8 0110E0E3 		mvn	r1, #1
 1165 08cc 0420A0E1 		mov	r2, r4
 1166 08d0 0700A0E1 		mov	r0, r7
 1167 08d4 FEFFFFEB 		bl	_txe_event_flags_set
1234:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1168              		.loc 1 1234 0
 1169 08d8 0520A0E1 		mov	r2, r5
 1170 08dc 0700A0E1 		mov	r0, r7
 1171 08e0 0410A0E1 		mov	r1, r4
 1172 08e4 FEFFFFEB 		bl	_txe_event_flags_set
1410:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1173              		.loc 1 1410 0
 1174 08e8 0650A0E1 		mov	r5, r6
 1175 08ec 5EFFFFEA 		b	.L64
 1176              	.L95:
 1177              		.align	2
 1178              	.L94:
 1179 08f0 00000000 		.word	bmReqType
 1180 08f4 00000000 		.word	wValue
 1181 08f8 00000000 		.word	wIndex
 1182 08fc 00000000 		.word	bRequest
 1183 0900 00000000 		.word	wLength
 1184 0904 E4010000 		.word	.LC13
 1185 0908 00000000 		.word	.LANCHOR0
 1186 090c 98010000 		.word	.LC11
 1187 0910 60010000 		.word	.LC10
 1188 0914 CC010000 		.word	.LC12
 1189 0918 00000000 		.word	glChHandleUVCStream
 1190 091c 00020000 		.word	.LC14
 1191              	.LBE55:
 1192              	.LBE54:
 1193              		.cfi_endproc
 1194              	.LFE9:
 1196              		.align	2
 1197              		.global	I2CCmdHandler
 1199              	I2CCmdHandler:
 1200              	.LFB0:
 311:../uvc.c      **** void I2CCmdHandler(){
 1201              		.loc 1 311 0
 1202              		.cfi_startproc
 1203              		@ args = 0, pretend = 0, frame = 16
 1204              		@ frame_needed = 0, uses_anonymous_args = 0
 1205 0920 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1206              	.LCFI9:
 1207              		.cfi_def_cfa_offset 36
 314:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1208              		.loc 1 314 0
 1209 0924 50419FE5 		ldr	r4, .L107
 1210              		.cfi_offset 14, -4
 1211              		.cfi_offset 11, -8
 1212              		.cfi_offset 10, -12
 1213              		.cfi_offset 9, -16
 1214              		.cfi_offset 8, -20
 1215              		.cfi_offset 7, -24
 1216              		.cfi_offset 6, -28
 1217              		.cfi_offset 5, -32
 1218              		.cfi_offset 4, -36
 311:../uvc.c      **** void I2CCmdHandler(){
 1219              		.loc 1 311 0
 1220 0928 3CD04DE2 		sub	sp, sp, #60
 1221              	.LCFI10:
 1222              		.cfi_def_cfa_offset 96
 319:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1223              		.loc 1 319 0
 1224 092c 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 314:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1225              		.loc 1 314 0
 1226 0930 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1227              	.LVL96:
 319:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1228              		.loc 1 319 0
 1229 0934 4D30D4E5 		ldrb	r3, [r4, #77]	@ zero_extendqisi2
 316:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1230              		.loc 1 316 0
 1231 0938 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1232              	.LVL97:
 319:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1233              		.loc 1 319 0
 1234 093c 4E70D4E5 		ldrb	r7, [r4, #78]	@ zero_extendqisi2
 1235 0940 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1236 0944 5080D4E5 		ldrb	r8, [r4, #80]	@ zero_extendqisi2
 1237 0948 51A0D4E5 		ldrb	sl, [r4, #81]	@ zero_extendqisi2
 1238 094c 5290D4E5 		ldrb	r9, [r4, #82]	@ zero_extendqisi2
 1239 0950 53B0D4E5 		ldrb	fp, [r4, #83]	@ zero_extendqisi2
 1240 0954 1C208DE5 		str	r2, [sp, #28]
 1241 0958 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1242 095c 0400A0E3 		mov	r0, #4
 1243 0960 18119FE5 		ldr	r1, .L107+4
 1244 0964 0520A0E1 		mov	r2, r5
 1245 0968 80408DE8 		stmia	sp, {r7, lr}	@ phole stm
 1246 096c 08808DE5 		str	r8, [sp, #8]
 1247 0970 0CA08DE5 		str	sl, [sp, #12]
 1248 0974 10908DE5 		str	r9, [sp, #16]
 1249 0978 14B08DE5 		str	fp, [sp, #20]
 1250 097c 18608DE5 		str	r6, [sp, #24]
 1251 0980 20C08DE5 		str	ip, [sp, #32]
 1252 0984 FEFFFFEB 		bl	CyU3PDebugPrint
 1253              	.LVL98:
 323:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1254              		.loc 1 323 0
 1255 0988 000055E3 		cmp	r5, #0
 1256 098c 1000000A 		beq	.L104
 348:../uvc.c      **** 	}else if(CmdType == 1){
 1257              		.loc 1 348 0
 1258 0990 010055E3 		cmp	r5, #1
 1259 0994 0100000A 		beq	.L105
 1260              	.LVL99:
 1261              	.L96:
 361:../uvc.c      **** }
 1262              		.loc 1 361 0
 1263 0998 3CD08DE2 		add	sp, sp, #60
 1264 099c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1265              	.LVL100:
 1266              	.L105:
 350:../uvc.c      **** 			if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1267              		.loc 1 350 0
 1268 09a0 4F20D4E5 		ldrb	r2, [r4, #79]	@ zero_extendqisi2
 1269 09a4 FE1002E2 		and	r1, r2, #254
 1270 09a8 820051E3 		cmp	r1, #130
 353:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 1271              		.loc 1 353 0
 1272 09ac 5050D415 		ldrneb	r5, [r4, #80]	@ zero_extendqisi2
 1273              	.LVL101:
 350:../uvc.c      **** 			if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1274              		.loc 1 350 0
 1275 09b0 1A00000A 		beq	.L106
 1276              	.L103:
 353:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 1277              		.loc 1 353 0
 1278 09b4 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1279              	.L102:
 355:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1280              		.loc 1 355 0
 1281 09b8 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1282 09bc 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1283 09c0 0520A0E1 		mov	r2, r5
 1284 09c4 FE0000E2 		and	r0, r0, #254
 1285 09c8 00E08DE5 		str	lr, [sp, #0]
 1286 09cc FEFFFFEB 		bl	SensorWrite2B
 1287 09d0 F0FFFFEA 		b	.L96
 1288              	.LVL102:
 1289              	.L104:
 339:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1290              		.loc 1 339 0
 1291 09d4 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1292 09d8 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 325:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1293              		.loc 1 325 0
 1294 09dc 0FE0A0E3 		mov	lr, #15
 339:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1295              		.loc 1 339 0
 1296 09e0 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1297 09e4 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 325:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1298              		.loc 1 325 0
 1299 09e8 57E0C4E5 		strb	lr, [r4, #87]
 339:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1300              		.loc 1 339 0
 1301 09ec 34C08DE2 		add	ip, sp, #52
 1302 09f0 010080E3 		orr	r0, r0, #1
 1303 09f4 011081E3 		orr	r1, r1, #1
 1304 09f8 00C08DE5 		str	ip, [sp, #0]
 1305 09fc FEFFFFEB 		bl	SensorRead2B
 340:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1306              		.loc 1 340 0
 1307 0a00 3400DDE5 		ldrb	r0, [sp, #52]	@ zero_extendqisi2
 341:../uvc.c      **** 			if(CmdDataLen == 2){
 1308              		.loc 1 341 0
 1309 0a04 020056E3 		cmp	r6, #2
 340:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1310              		.loc 1 340 0
 1311 0a08 5500C4E5 		strb	r0, [r4, #85]
 342:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1312              		.loc 1 342 0
 1313 0a0c 3500DD05 		ldreqb	r0, [sp, #53]	@ zero_extendqisi2
 344:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1314              		.loc 1 344 0
 1315 0a10 0030E0E3 		mvn	r3, #0
 342:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1316              		.loc 1 342 0
 1317 0a14 5600C405 		streqb	r0, [r4, #86]
 344:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1318              		.loc 1 344 0
 1319 0a18 5730C4E5 		strb	r3, [r4, #87]
 1320 0a1c DDFFFFEA 		b	.L96
 1321              	.LVL103:
 1322              	.L106:
 350:../uvc.c      **** 			if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1323              		.loc 1 350 0 discriminator 1
 1324 0a20 5050D4E5 		ldrb	r5, [r4, #80]	@ zero_extendqisi2
 1325 0a24 300055E3 		cmp	r5, #48
 1326 0a28 E1FFFF1A 		bne	.L103
 1327 0a2c 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1328 0a30 100053E3 		cmp	r3, #16
 1329 0a34 DFFFFF1A 		bne	.L102
 351:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1330              		.loc 1 351 0
 1331 0a38 44409FE5 		ldr	r4, .L107+8
 1332 0a3c 0010E0E3 		mvn	r1, #0
 1333 0a40 1C0094E5 		ldr	r0, [r4, #28]
 1334 0a44 2C308DE5 		str	r3, [sp, #44]
 1335 0a48 FEFFFFEB 		bl	_txe_mutex_get
 352:../uvc.c      **** 				cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1336              		.loc 1 352 0
 1337 0a4c 2C309DE5 		ldr	r3, [sp, #44]
 1338 0a50 00C0A0E3 		mov	ip, #0
 1339 0a54 0320A0E1 		mov	r2, r3
 1340 0a58 0400A0E1 		mov	r0, r4
 1341 0a5c 1710A0E3 		mov	r1, #23
 1342 0a60 0530A0E1 		mov	r3, r5
 1343 0a64 00C08DE5 		str	ip, [sp, #0]
 1344 0a68 04C08DE5 		str	ip, [sp, #4]
 1345 0a6c FEFFFFEB 		bl	cmdSet
 353:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 1346              		.loc 1 353 0
 1347 0a70 1C0094E5 		ldr	r0, [r4, #28]
 1348 0a74 FEFFFFEB 		bl	_txe_mutex_put
 1349 0a78 C6FFFFEA 		b	.L96
 1350              	.L108:
 1351              		.align	2
 1352              	.L107:
 1353 0a7c 00000000 		.word	.LANCHOR0
 1354 0a80 24020000 		.word	.LC15
 1355 0a84 00000000 		.word	cmdQu
 1356              		.cfi_endproc
 1357              	.LFE0:
 1359              		.align	2
 1360              		.global	setIrisauto
 1362              	setIrisauto:
 1363              	.LFB1:
 367:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1364              		.loc 1 367 0
 1365              		.cfi_startproc
 1366              		@ args = 0, pretend = 0, frame = 0
 1367              		@ frame_needed = 0, uses_anonymous_args = 0
 1368              	.LVL104:
 1369 0a88 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1370              	.LCFI11:
 1371              		.cfi_def_cfa_offset 16
 1372 0a8c 0160A0E1 		mov	r6, r1
 1373              		.cfi_offset 14, -4
 1374              		.cfi_offset 6, -8
 1375              		.cfi_offset 5, -12
 1376              		.cfi_offset 4, -16
 1377 0a90 08D04DE2 		sub	sp, sp, #8
 1378              	.LCFI12:
 1379              		.cfi_def_cfa_offset 24
 371:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1380              		.loc 1 371 0
 1381 0a94 0050A0E3 		mov	r5, #0
 367:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1382              		.loc 1 367 0
 1383 0a98 0040A0E1 		mov	r4, r0
 370:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1384              		.loc 1 370 0
 1385 0a9c 0010E0E3 		mvn	r1, #0
 1386              	.LVL105:
 1387 0aa0 1C0090E5 		ldr	r0, [r0, #28]
 1388              	.LVL106:
 1389 0aa4 FEFFFFEB 		bl	_txe_mutex_get
 371:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1390              		.loc 1 371 0
 1391 0aa8 060065E0 		rsb	r0, r5, r6
 1392 0aac 00C070E2 		rsbs	ip, r0, #0
 1393 0ab0 00C0ACE0 		adc	ip, ip, r0
 1394 0ab4 1410A0E3 		mov	r1, #20
 1395 0ab8 2720A0E3 		mov	r2, #39
 1396 0abc 3030A0E3 		mov	r3, #48
 1397 0ac0 0400A0E1 		mov	r0, r4
 1398 0ac4 00C08DE5 		str	ip, [sp, #0]
 1399 0ac8 04508DE5 		str	r5, [sp, #4]
 1400 0acc FEFFFFEB 		bl	cmdSet
 372:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 1401              		.loc 1 372 0
 1402 0ad0 050056E1 		cmp	r6, r5
 1403 0ad4 0260A003 		moveq	r6, #2
 1404 0ad8 0560A011 		movne	r6, r5
 1405 0adc 0400A0E1 		mov	r0, r4
 1406 0ae0 1510A0E3 		mov	r1, #21
 1407 0ae4 2520A0E3 		mov	r2, #37
 1408 0ae8 3030A0E3 		mov	r3, #48
 1409 0aec 00608DE5 		str	r6, [sp, #0]
 1410 0af0 04508DE5 		str	r5, [sp, #4]
 1411 0af4 FEFFFFEB 		bl	cmdSet
 373:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1412              		.loc 1 373 0
 1413 0af8 1C0094E5 		ldr	r0, [r4, #28]
 374:../uvc.c      **** }
 1414              		.loc 1 374 0
 1415 0afc 08D08DE2 		add	sp, sp, #8
 1416 0b00 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 373:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1417              		.loc 1 373 0
 1418 0b04 FEFFFFEA 		b	_txe_mutex_put
 1419              		.cfi_endproc
 1420              	.LFE1:
 1422              		.align	2
 1423              		.global	ControlHandle
 1425              	ControlHandle:
 1426              	.LFB2:
 376:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1427              		.loc 1 376 0
 1428              		.cfi_startproc
 1429              		@ args = 0, pretend = 0, frame = 24
 1430              		@ frame_needed = 0, uses_anonymous_args = 0
 1431              	.LVL107:
 1432 0b08 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1433              	.LCFI13:
 1434              		.cfi_def_cfa_offset 36
 383:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1435              		.loc 1 383 0
 1436 0b0c 1F0050E3 		cmp	r0, #31
 382:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1437              		.loc 1 382 0
 1438 0b10 207040E2 		sub	r7, r0, #32
 1439              		.cfi_offset 14, -4
 1440              		.cfi_offset 11, -8
 1441              		.cfi_offset 10, -12
 1442              		.cfi_offset 9, -16
 1443              		.cfi_offset 8, -20
 1444              		.cfi_offset 7, -24
 1445              		.cfi_offset 6, -28
 1446              		.cfi_offset 5, -32
 1447              		.cfi_offset 4, -36
 376:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1448              		.loc 1 376 0
 1449 0b14 2CD04DE2 		sub	sp, sp, #44
 1450              	.LCFI14:
 1451              		.cfi_def_cfa_offset 80
 376:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1452              		.loc 1 376 0
 1453 0b18 0040A0E1 		mov	r4, r0
 382:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1454              		.loc 1 382 0
 1455 0b1c FF7007E2 		and	r7, r7, #255
 1456              	.LVL108:
 383:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1457              		.loc 1 383 0
 1458 0b20 2300009A 		bls	.L113
 384:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1459              		.loc 1 384 0
 1460 0b24 C06E9FE5 		ldr	r6, .L221
 1461 0b28 872087E0 		add	r2, r7, r7, asl #1
 1462 0b2c 8221A0E1 		mov	r2, r2, asl #3
 1463 0b30 023086E0 		add	r3, r6, r2
 385:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1464              		.loc 1 385 0
 1465 0b34 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 386:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1466              		.loc 1 386 0
 1467 0b38 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 387:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1468              		.loc 1 387 0
 1469 0b3c 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 398:../uvc.c      ****     reqData = bRequest;
 1470              		.loc 1 398 0
 1471 0b40 A83E9FE5 		ldr	r3, .L221+4
 384:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1472              		.loc 1 384 0
 1473 0b44 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1474              	.LVL109:
 398:../uvc.c      ****     reqData = bRequest;
 1475              		.loc 1 398 0
 1476 0b48 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1477              	.LVL110:
 406:../uvc.c      ****     switch (bRequest)
 1478              		.loc 1 406 0
 1479 0b4c 830055E3 		cmp	r5, #131
 1480 0b50 2200000A 		beq	.L119
 1481              	.LVL111:
 1482              	.L216:
 1483 0b54 2B00009A 		bls	.L214
 1484 0b58 850055E3 		cmp	r5, #133
 1485 0b5c 8400000A 		beq	.L121
 1486 0b60 7200003A 		bcc	.L120
 1487 0b64 860055E3 		cmp	r5, #134
 1488 0b68 BD00000A 		beq	.L122
 1489 0b6c 870055E3 		cmp	r5, #135
 1490 0b70 B100000A 		beq	.L215
 1491              	.L115:
 864:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1492              		.loc 1 864 0
 1493 0b74 0000A0E3 		mov	r0, #0
 1494 0b78 0110A0E3 		mov	r1, #1
 1495 0b7c 0020A0E1 		mov	r2, r0
 1496 0b80 FEFFFFEB 		bl	CyU3PUsbStall
 865:../uvc.c      **** 			  break;
 1497              		.loc 1 865 0
 1498 0b84 FFE0A0E3 		mov	lr, #255
 1499 0b88 0E40A0E1 		mov	r4, lr
 1500 0b8c 0EC0A0E1 		mov	ip, lr
 1501 0b90 0E30A0E1 		mov	r3, lr
 1502              	.LVL112:
 1503              	.L125:
 867:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1504              		.loc 1 867 0
 1505 0b94 581E9FE5 		ldr	r1, .L221+8
 1506 0b98 0520A0E1 		mov	r2, r5
 1507 0b9c 0400A0E3 		mov	r0, #4
 1508 0ba0 00C08DE5 		str	ip, [sp, #0]
 1509 0ba4 10408DE9 		stmib	sp, {r4, lr}	@ phole stm
 1510 0ba8 FEFFFFEB 		bl	CyU3PDebugPrint
 868:../uvc.c      **** }
 1511              		.loc 1 868 0
 1512 0bac 2CD08DE2 		add	sp, sp, #44
 1513 0bb0 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1514              	.LVL113:
 1515              	.L113:
 389:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1516              		.loc 1 389 0
 1517 0bb4 306E9FE5 		ldr	r6, .L221
 398:../uvc.c      ****     reqData = bRequest;
 1518              		.loc 1 398 0
 1519 0bb8 303E9FE5 		ldr	r3, .L221+4
 389:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1520              		.loc 1 389 0
 1521 0bbc 805080E0 		add	r5, r0, r0, asl #1
 1522 0bc0 850186E0 		add	r0, r6, r5, asl #3
 1523              	.LVL114:
 398:../uvc.c      ****     reqData = bRequest;
 1524              		.loc 1 398 0
 1525 0bc4 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 389:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1526              		.loc 1 389 0
 1527 0bc8 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1528              	.LVL115:
 406:../uvc.c      ****     switch (bRequest)
 1529              		.loc 1 406 0
 1530 0bcc 830055E3 		cmp	r5, #131
 390:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1531              		.loc 1 390 0
 1532 0bd0 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1533              	.LVL116:
 391:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1534              		.loc 1 391 0
 1535 0bd4 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1536              	.LVL117:
 392:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1537              		.loc 1 392 0
 1538 0bd8 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1539              	.LVL118:
 406:../uvc.c      ****     switch (bRequest)
 1540              		.loc 1 406 0
 1541 0bdc DCFFFF1A 		bne	.L216
 1542              	.LVL119:
 1543              	.L119:
 529:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1544              		.loc 1 529 0
 1545 0be0 1F0054E3 		cmp	r4, #31
 1546 0be4 BC00009A 		bls	.L150
 530:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1547              		.loc 1 530 0
 1548 0be8 877087E0 		add	r7, r7, r7, asl #1
 1549              	.LVL120:
 1550 0bec 876186E0 		add	r6, r6, r7, asl #3
 1551 0bf0 00AE9FE5 		ldr	sl, .L221+12
 1552 0bf4 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 531:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1553              		.loc 1 531 0
 1554 0bf8 06C0D6E5 		ldrb	ip, [r6, #6]	@ zero_extendqisi2
 530:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1555              		.loc 1 530 0
 1556 0bfc 5800CAE5 		strb	r0, [sl, #88]
 531:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1557              		.loc 1 531 0
 1558 0c00 59C0CAE5 		strb	ip, [sl, #89]
 1559 0c04 0B0000EA 		b	.L158
 1560              	.LVL121:
 1561              	.L214:
 406:../uvc.c      ****     switch (bRequest)
 1562              		.loc 1 406 0
 1563 0c08 810055E3 		cmp	r5, #129
 1564 0c0c 6400000A 		beq	.L117
 1565 0c10 1000009A 		bls	.L217
 510:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1566              		.loc 1 510 0
 1567 0c14 1F0054E3 		cmp	r4, #31
 1568 0c18 A300009A 		bls	.L147
 511:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1569              		.loc 1 511 0
 1570 0c1c 877087E0 		add	r7, r7, r7, asl #1
 1571              	.LVL122:
 1572 0c20 876186E0 		add	r6, r6, r7, asl #3
 1573 0c24 CCAD9FE5 		ldr	sl, .L221+12
 1574 0c28 0340D6E5 		ldrb	r4, [r6, #3]	@ zero_extendqisi2
 512:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1575              		.loc 1 512 0
 1576 0c2c 04E0D6E5 		ldrb	lr, [r6, #4]	@ zero_extendqisi2
 511:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1577              		.loc 1 511 0
 1578 0c30 5840CAE5 		strb	r4, [sl, #88]
 512:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1579              		.loc 1 512 0
 1580 0c34 59E0CAE5 		strb	lr, [sl, #89]
 1581              	.L158:
 588:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1582              		.loc 1 588 0
 1583 0c38 0800A0E1 		mov	r0, r8
 1584 0c3c B81D9FE5 		ldr	r1, .L221+16
 1585 0c40 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1586              	.LVL123:
 590:../uvc.c      **** 			  break;
 1587              		.loc 1 590 0
 1588 0c44 FFE0A0E3 		mov	lr, #255
 588:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1589              		.loc 1 588 0
 1590 0c48 5840DAE5 		ldrb	r4, [sl, #88]	@ zero_extendqisi2
 590:../uvc.c      **** 			  break;
 1591              		.loc 1 590 0
 1592 0c4c 0EC0A0E1 		mov	ip, lr
 1593 0c50 0E30A0E1 		mov	r3, lr
 1594 0c54 CEFFFFEA 		b	.L125
 1595              	.LVL124:
 1596              	.L217:
 406:../uvc.c      ****     switch (bRequest)
 1597              		.loc 1 406 0
 1598 0c58 010055E3 		cmp	r5, #1
 1599 0c5c C4FFFF1A 		bne	.L115
 592:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1600              		.loc 1 592 0
 1601 0c60 901D9FE5 		ldr	r1, .L221+12
 1602 0c64 26208DE2 		add	r2, sp, #38
 1603 0c68 2000A0E3 		mov	r0, #32
 1604 0c6c 581081E2 		add	r1, r1, #88
 1605 0c70 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1606              	.LVL125:
 594:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1607              		.loc 1 594 0
 1608 0c74 002050E2 		subs	r2, r0, #0
 1609 0c78 2003001A 		bne	.L160
 596:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1610              		.loc 1 596 0
 1611 0c7c 74ED9FE5 		ldr	lr, .L221+12
 1612 0c80 5830DEE5 		ldrb	r3, [lr, #88]	@ zero_extendqisi2
 597:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1613              		.loc 1 597 0
 1614 0c84 6CED9FE5 		ldr	lr, .L221+12
 596:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1615              		.loc 1 596 0
 1616 0c88 18308DE5 		str	r3, [sp, #24]
 1617              	.LVL126:
 599:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1618              		.loc 1 599 0
 1619 0c8c 5A00DEE5 		ldrb	r0, [lr, #90]	@ zero_extendqisi2
 1620              	.LVL127:
 597:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1621              		.loc 1 597 0
 1622 0c90 59C0DEE5 		ldrb	ip, [lr, #89]	@ zero_extendqisi2
 1623              	.LVL128:
 599:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1624              		.loc 1 599 0
 1625 0c94 1C008DE5 		str	r0, [sp, #28]
 1626              	.LVL129:
 603:../uvc.c      **** 				  switch(CtrlID)
 1627              		.loc 1 603 0
 1628 0c98 220054E3 		cmp	r4, #34
 1629 0c9c 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1630 0ca0 FD0200EA 		b	.L161
 1631              	.L176:
 1632 0ca4 4C180000 		.word	.L162
 1633 0ca8 90170000 		.word	.L163
 1634 0cac 9C180000 		.word	.L161
 1635 0cb0 9C180000 		.word	.L161
 1636 0cb4 2C170000 		.word	.L164
 1637 0cb8 E8150000 		.word	.L165
 1638 0cbc 68150000 		.word	.L166
 1639 0cc0 9C180000 		.word	.L161
 1640 0cc4 9C180000 		.word	.L161
 1641 0cc8 9C180000 		.word	.L161
 1642 0ccc 9C180000 		.word	.L161
 1643 0cd0 E4140000 		.word	.L167
 1644 0cd4 9C180000 		.word	.L161
 1645 0cd8 9C180000 		.word	.L161
 1646 0cdc 9C180000 		.word	.L161
 1647 0ce0 9C180000 		.word	.L161
 1648 0ce4 EC130000 		.word	.L168
 1649 0ce8 9C180000 		.word	.L161
 1650 0cec 9C180000 		.word	.L161
 1651 0cf0 9C180000 		.word	.L161
 1652 0cf4 9C180000 		.word	.L161
 1653 0cf8 9C180000 		.word	.L161
 1654 0cfc 9C180000 		.word	.L161
 1655 0d00 9C180000 		.word	.L161
 1656 0d04 9C180000 		.word	.L161
 1657 0d08 30130000 		.word	.L169
 1658 0d0c 9C180000 		.word	.L161
 1659 0d10 9C180000 		.word	.L161
 1660 0d14 74140000 		.word	.L170
 1661 0d18 9C180000 		.word	.L161
 1662 0d1c D4120000 		.word	.L171
 1663 0d20 50120000 		.word	.L172
 1664 0d24 B8110000 		.word	.L173
 1665 0d28 A0110000 		.word	.L174
 1666 0d2c 3C110000 		.word	.L175
 1667              	.LVL130:
 1668              	.L120:
 547:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1669              		.loc 1 547 0
 1670 0d30 1F0054E3 		cmp	r4, #31
 548:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1671              		.loc 1 548 0
 1672 0d34 87708780 		addhi	r7, r7, r7, asl #1
 1673              	.LVL131:
 554:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1674              		.loc 1 554 0
 1675 0d38 84408490 		addls	r4, r4, r4, asl #1
 548:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1676              		.loc 1 548 0
 1677 0d3c 87618680 		addhi	r6, r6, r7, asl #3
 554:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1678              		.loc 1 554 0
 1679 0d40 84618690 		addls	r6, r6, r4, asl #3
 548:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1680              		.loc 1 548 0
 1681 0d44 ACAC9F85 		ldrhi	sl, .L221+12
 554:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1682              		.loc 1 554 0
 1683 0d48 A8AC9F95 		ldrls	sl, .L221+12
 548:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1684              		.loc 1 548 0
 1685 0d4c 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 549:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1686              		.loc 1 549 0
 1687 0d50 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 554:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1688              		.loc 1 554 0
 1689 0d54 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 555:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1690              		.loc 1 555 0
 1691 0d58 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 556:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1692              		.loc 1 556 0
 1693 0d5c 0030A0E3 		mov	r3, #0
 554:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1694              		.loc 1 554 0
 1695 0d60 5810CAE5 		strb	r1, [sl, #88]
 555:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1696              		.loc 1 555 0
 1697 0d64 5920CAE5 		strb	r2, [sl, #89]
 556:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1698              		.loc 1 556 0
 1699 0d68 5A30CAE5 		strb	r3, [sl, #90]
 557:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1700              		.loc 1 557 0
 1701 0d6c 5B30CAE5 		strb	r3, [sl, #91]
 1702 0d70 B0FFFFEA 		b	.L158
 1703              	.LVL132:
 1704              	.L121:
 410:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1705              		.loc 1 410 0
 1706 0d74 7C4C9FE5 		ldr	r4, .L221+12
 411:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1707              		.loc 1 411 0
 1708 0d78 00C0A0E3 		mov	ip, #0
 1709 0d7c 59C0C4E5 		strb	ip, [r4, #89]
 412:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1710              		.loc 1 412 0
 1711 0d80 581084E2 		add	r1, r4, #88
 410:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1712              		.loc 1 410 0
 1713 0d84 5880C4E5 		strb	r8, [r4, #88]
 412:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1714              		.loc 1 412 0
 1715 0d88 0200A0E3 		mov	r0, #2
 1716 0d8c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1717              	.LVL133:
 414:../uvc.c      **** 			  break;
 1718              		.loc 1 414 0
 1719 0d90 FFE0A0E3 		mov	lr, #255
 412:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1720              		.loc 1 412 0
 1721 0d94 5840D4E5 		ldrb	r4, [r4, #88]	@ zero_extendqisi2
 414:../uvc.c      **** 			  break;
 1722              		.loc 1 414 0
 1723 0d98 0EC0A0E1 		mov	ip, lr
 1724 0d9c 0E30A0E1 		mov	r3, lr
 1725 0da0 7BFFFFEA 		b	.L125
 1726              	.LVL134:
 1727              	.L117:
 417:../uvc.c      **** 			 switch(CtrlID)
 1728              		.loc 1 417 0
 1729 0da4 011044E2 		sub	r1, r4, #1
 1730 0da8 210051E3 		cmp	r1, #33
 1731 0dac 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1732 0db0 D80000EA 		b	.L126
 1733              	.L134:
 1734 0db4 D4100000 		.word	.L127
 1735 0db8 18110000 		.word	.L126
 1736 0dbc 18110000 		.word	.L126
 1737 0dc0 18110000 		.word	.L126
 1738 0dc4 B4100000 		.word	.L128
 1739 0dc8 18110000 		.word	.L126
 1740 0dcc 18110000 		.word	.L126
 1741 0dd0 18110000 		.word	.L126
 1742 0dd4 18110000 		.word	.L126
 1743 0dd8 18110000 		.word	.L126
 1744 0ddc 90100000 		.word	.L129
 1745 0de0 18110000 		.word	.L126
 1746 0de4 18110000 		.word	.L126
 1747 0de8 18110000 		.word	.L126
 1748 0dec 18110000 		.word	.L126
 1749 0df0 18110000 		.word	.L126
 1750 0df4 18110000 		.word	.L126
 1751 0df8 18110000 		.word	.L126
 1752 0dfc 18110000 		.word	.L126
 1753 0e00 18110000 		.word	.L126
 1754 0e04 18110000 		.word	.L126
 1755 0e08 18110000 		.word	.L126
 1756 0e0c 18110000 		.word	.L126
 1757 0e10 18110000 		.word	.L126
 1758 0e14 54100000 		.word	.L130
 1759 0e18 18110000 		.word	.L126
 1760 0e1c 18110000 		.word	.L126
 1761 0e20 2C100000 		.word	.L131
 1762 0e24 18110000 		.word	.L126
 1763 0e28 18110000 		.word	.L126
 1764 0e2c 900F0000 		.word	.L132
 1765 0e30 580F0000 		.word	.L133
 1766 0e34 580F0000 		.word	.L133
 1767 0e38 580F0000 		.word	.L133
 1768              	.L215:
 574:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1769              		.loc 1 574 0
 1770 0e3c 1F0054E3 		cmp	r4, #31
 1771 0e40 3100009A 		bls	.L157
 575:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1772              		.loc 1 575 0
 1773 0e44 877087E0 		add	r7, r7, r7, asl #1
 1774              	.LVL135:
 1775 0e48 876186E0 		add	r6, r6, r7, asl #3
 1776 0e4c A4AB9FE5 		ldr	sl, .L221+12
 1777 0e50 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 576:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1778              		.loc 1 576 0
 1779 0e54 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
 575:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1780              		.loc 1 575 0
 1781 0e58 5820CAE5 		strb	r2, [sl, #88]
 576:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1782              		.loc 1 576 0
 1783 0e5c 5910CAE5 		strb	r1, [sl, #89]
 1784 0e60 74FFFFEA 		b	.L158
 1785              	.LVL136:
 1786              	.L122:
 563:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1787              		.loc 1 563 0
 1788 0e64 1F0054E3 		cmp	r4, #31
 567:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1789              		.loc 1 567 0
 1790 0e68 84408490 		addls	r4, r4, r4, asl #1
 564:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1791              		.loc 1 564 0
 1792 0e6c 87708780 		addhi	r7, r7, r7, asl #1
 1793              	.LVL137:
 567:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1794              		.loc 1 567 0
 1795 0e70 84618690 		addls	r6, r6, r4, asl #3
 564:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1796              		.loc 1 564 0
 1797 0e74 87618680 		addhi	r6, r6, r7, asl #3
 1798 0e78 788B9F85 		ldrhi	r8, .L221+12
 1799 0e7c 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 567:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1800              		.loc 1 567 0
 1801 0e80 708B9F95 		ldrls	r8, .L221+12
 1802 0e84 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 569:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1803              		.loc 1 569 0
 1804 0e88 0100A0E3 		mov	r0, #1
 567:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1805              		.loc 1 567 0
 1806 0e8c 5830C8E5 		strb	r3, [r8, #88]
 569:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1807              		.loc 1 569 0
 1808 0e90 641B9FE5 		ldr	r1, .L221+16
 1809 0e94 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1810              	.LVL138:
 572:../uvc.c      **** 			  break;
 1811              		.loc 1 572 0
 1812 0e98 FFE0A0E3 		mov	lr, #255
 569:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1813              		.loc 1 569 0
 1814 0e9c 5840D8E5 		ldrb	r4, [r8, #88]	@ zero_extendqisi2
 572:../uvc.c      **** 			  break;
 1815              		.loc 1 572 0
 1816 0ea0 0EC0A0E1 		mov	ip, lr
 1817 0ea4 0E30A0E1 		mov	r3, lr
 1818 0ea8 39FFFFEA 		b	.L125
 1819              	.LVL139:
 1820              	.L147:
 515:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1821              		.loc 1 515 0
 1822 0eac 0B0054E3 		cmp	r4, #11
 522:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1823              		.loc 1 522 0
 1824 0eb0 84408410 		addne	r4, r4, r4, asl #1
 1825 0eb4 84618610 		addne	r6, r6, r4, asl #3
 1826 0eb8 38AB9F15 		ldrne	sl, .L221+12
 516:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1827              		.loc 1 516 0
 1828 0ebc 34AB9F05 		ldreq	sl, .L221+12
 1829 0ec0 383B9F05 		ldreq	r3, .L221+20
 522:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1830              		.loc 1 522 0
 1831 0ec4 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 523:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1832              		.loc 1 523 0
 1833 0ec8 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 516:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1834              		.loc 1 516 0
 1835 0ecc 58308A05 		streq	r3, [sl, #88]
 522:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1836              		.loc 1 522 0
 1837 0ed0 5820CA15 		strneb	r2, [sl, #88]
 523:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1838              		.loc 1 523 0
 1839 0ed4 5930CA15 		strneb	r3, [sl, #89]
 1840 0ed8 56FFFFEA 		b	.L158
 1841              	.L150:
 533:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1842              		.loc 1 533 0
 1843 0edc 0B0054E3 		cmp	r4, #11
 540:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1844              		.loc 1 540 0
 1845 0ee0 84408410 		addne	r4, r4, r4, asl #1
 1846 0ee4 84618610 		addne	r6, r6, r4, asl #3
 1847 0ee8 08AB9F15 		ldrne	sl, .L221+12
 534:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1848              		.loc 1 534 0
 1849 0eec 04AB9F05 		ldreq	sl, .L221+12
 1850 0ef0 0C3B9F05 		ldreq	r3, .L221+24
 540:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1851              		.loc 1 540 0
 1852 0ef4 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 541:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1853              		.loc 1 541 0
 1854 0ef8 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 534:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1855              		.loc 1 534 0
 1856 0efc 58308A05 		streq	r3, [sl, #88]
 540:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1857              		.loc 1 540 0
 1858 0f00 5820CA15 		strneb	r2, [sl, #88]
 541:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1859              		.loc 1 541 0
 1860 0f04 5930CA15 		strneb	r3, [sl, #89]
 1861 0f08 4AFFFFEA 		b	.L158
 1862              	.L157:
 579:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1863              		.loc 1 579 0
 1864 0f0c 0B0054E3 		cmp	r4, #11
 1865 0f10 0700000A 		beq	.L218
 585:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1866              		.loc 1 585 0
 1867 0f14 84A084E0 		add	sl, r4, r4, asl #1
 1868 0f18 8A6186E0 		add	r6, r6, sl, asl #3
 1869 0f1c 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1870 0f20 D0AA9FE5 		ldr	sl, .L221+12
 586:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1871              		.loc 1 586 0
 1872 0f24 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 585:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1873              		.loc 1 585 0
 1874 0f28 5830CAE5 		strb	r3, [sl, #88]
 586:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1875              		.loc 1 586 0
 1876 0f2c 5900CAE5 		strb	r0, [sl, #89]
 1877 0f30 40FFFFEA 		b	.L158
 1878              	.L218:
 580:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1879              		.loc 1 580 0
 1880 0f34 BCAA9FE5 		ldr	sl, .L221+12
 1881 0f38 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 582:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1882              		.loc 1 582 0
 1883 0f3c 9442D6E5 		ldrb	r4, [r6, #660]	@ zero_extendqisi2
 581:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1884              		.loc 1 581 0
 1885 0f40 00E0A0E3 		mov	lr, #0
 580:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1886              		.loc 1 580 0
 1887 0f44 58C0CAE5 		strb	ip, [sl, #88]
 581:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1888              		.loc 1 581 0
 1889 0f48 59E0CAE5 		strb	lr, [sl, #89]
 582:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1890              		.loc 1 582 0
 1891 0f4c 5A40CAE5 		strb	r4, [sl, #90]
 583:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1892              		.loc 1 583 0
 1893 0f50 5BE0CAE5 		strb	lr, [sl, #91]
 1894 0f54 37FFFFEA 		b	.L158
 1895              	.L133:
 423:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1896              		.loc 1 423 0
 1897 0f58 877087E0 		add	r7, r7, r7, asl #1
 1898              	.LVL140:
 1899 0f5c 876186E0 		add	r6, r6, r7, asl #3
 1900 0f60 90EA9FE5 		ldr	lr, .L221+12
 1901 0f64 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 424:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1902              		.loc 1 424 0
 1903 0f68 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 423:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1904              		.loc 1 423 0
 1905 0f6c 5840CEE5 		strb	r4, [lr, #88]
 424:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1906              		.loc 1 424 0
 1907 0f70 5960CEE5 		strb	r6, [lr, #89]
 1908              	.LVL141:
 1909              	.L137:
 503:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1910              		.loc 1 503 0
 1911 0f74 0800A0E1 		mov	r0, r8
 1912 0f78 7C1A9FE5 		ldr	r1, .L221+16
 1913 0f7c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 508:../uvc.c      **** 			  break;
 1914              		.loc 1 508 0
 1915 0f80 FFC0A0E3 		mov	ip, #255
 503:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1916              		.loc 1 503 0
 1917 0f84 06E0A0E1 		mov	lr, r6
 508:../uvc.c      **** 			  break;
 1918              		.loc 1 508 0
 1919 0f88 0C30A0E1 		mov	r3, ip
 1920 0f8c 00FFFFEA 		b	.L125
 1921              	.LVL142:
 1922              	.L132:
 444:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1923              		.loc 1 444 0 discriminator 1
 1924 0f90 000058E3 		cmp	r8, #0
 1925 0f94 8D02000A 		beq	.L210
 442:../uvc.c      **** 					 break;
 1926              		.loc 1 442 0
 1927 0f98 28E1A0E1 		mov	lr, r8, lsr #2
 1928 0f9c 00005EE3 		cmp	lr, #0
 1929 0fa0 03005813 		cmpne	r8, #3
 1930 0fa4 0020A083 		movhi	r2, #0
 1931 0fa8 0120A093 		movls	r2, #1
 376:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1932              		.loc 1 376 0
 1933 0fac 0E31A0E1 		mov	r3, lr, asl #2
 442:../uvc.c      **** 					 break;
 1934              		.loc 1 442 0
 1935 0fb0 8A02009A 		bls	.L197
 1936 0fb4 401A9FE5 		ldr	r1, .L221+16
 1937 0fb8 0C0041E2 		sub	r0, r1, #12
 1938              	.LVL143:
 1939              	.L142:
 445:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1940              		.loc 1 445 0 discriminator 2
 1941 0fbc 044090E4 		ldr	r4, [r0], #4
 1942 0fc0 01C082E2 		add	ip, r2, #1
 1943 0fc4 FF200CE2 		and	r2, ip, #255
 1944 0fc8 02005EE1 		cmp	lr, r2
 1945 0fcc 044081E4 		str	r4, [r1], #4
 1946 0fd0 F9FFFF8A 		bhi	.L142
 445:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1947              		.loc 1 445 0 is_stmt 0
 1948 0fd4 030058E1 		cmp	r8, r3
 1949 0fd8 180A9F15 		ldrne	r0, .L221+12
 1950 0fdc 7B02000A 		beq	.L210
 1951              	.L202:
 1952 0fe0 03E080E0 		add	lr, r0, r3
 1953 0fe4 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 444:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1954              		.loc 1 444 0 is_stmt 1
 1955 0fe8 016083E2 		add	r6, r3, #1
 1956 0fec FF3006E2 		and	r3, r6, #255
 1957              	.LVL144:
 1958 0ff0 030058E1 		cmp	r8, r3
 445:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1959              		.loc 1 445 0
 1960 0ff4 5810CEE5 		strb	r1, [lr, #88]
 444:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1961              		.loc 1 444 0
 1962 0ff8 F8FFFF8A 		bhi	.L202
 1963              	.LVL145:
 1964              	.L136:
 454:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1965              		.loc 1 454 0
 1966 0ffc 5720D0E5 		ldrb	r2, [r0, #87]	@ zero_extendqisi2
 447:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1967              		.loc 1 447 0
 1968 1000 F0399FE5 		ldr	r3, .L221+12
 454:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1969              		.loc 1 454 0
 1970 1004 FF0052E3 		cmp	r2, #255
 447:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1971              		.loc 1 447 0
 1972 1008 6140D0E5 		ldrb	r4, [r0, #97]	@ zero_extendqisi2
 1973              	.LVL146:
 448:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1974              		.loc 1 448 0
 1975 100c 6260D0E5 		ldrb	r6, [r0, #98]	@ zero_extendqisi2
 1976              	.LVL147:
 454:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1977              		.loc 1 454 0
 1978 1010 D7FFFF0A 		beq	.L137
 456:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 1979              		.loc 1 456 0
 1980 1014 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 1981 1018 E8199FE5 		ldr	r1, .L221+28
 1982 101c 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 1983 1020 0400A0E3 		mov	r0, #4
 1984 1024 FEFFFFEB 		bl	CyU3PDebugPrint
 1985 1028 D1FFFFEA 		b	.L137
 1986              	.LVL148:
 1987              	.L131:
 431:../uvc.c      **** 					 if(CamMode == 1){//720p
 1988              		.loc 1 431 0
 1989 102c C4799FE5 		ldr	r7, .L221+12
 1990              	.LVL149:
 430:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 1991              		.loc 1 430 0
 1992 1030 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 1993              	.LVL150:
 431:../uvc.c      **** 					 if(CamMode == 1){//720p
 1994              		.loc 1 431 0
 1995 1034 7820D7E5 		ldrb	r2, [r7, #120]	@ zero_extendqisi2
 1996 1038 010052E3 		cmp	r2, #1
 1997 103c 3702000A 		beq	.L219
 1998              	.LVL151:
 1999              	.L138:
 441:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2000              		.loc 1 441 0
 2001 1040 0000A0E3 		mov	r0, #0
 440:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 2002              		.loc 1 440 0
 2003 1044 5840C7E5 		strb	r4, [r7, #88]
 441:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2004              		.loc 1 441 0
 2005 1048 5900C7E5 		strb	r0, [r7, #89]
 394:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2006              		.loc 1 394 0
 2007 104c FF60A0E3 		mov	r6, #255
 442:../uvc.c      **** 					 break;
 2008              		.loc 1 442 0
 2009 1050 C7FFFFEA 		b	.L137
 2010              	.LVL152:
 2011              	.L130:
 460:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2012              		.loc 1 460 0
 2013 1054 E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 2014 1058 98C99FE5 		ldr	ip, .L221+12
 462:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2015              		.loc 1 462 0
 2016 105c E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 461:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2017              		.loc 1 461 0
 2018 1060 00E0A0E3 		mov	lr, #0
 460:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2019              		.loc 1 460 0
 2020 1064 5840CCE5 		strb	r4, [ip, #88]
 461:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2021              		.loc 1 461 0
 2022 1068 59E0CCE5 		strb	lr, [ip, #89]
 462:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2023              		.loc 1 462 0
 2024 106c 5A60CCE5 		strb	r6, [ip, #90]
 463:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2025              		.loc 1 463 0
 2026 1070 5BE0CCE5 		strb	lr, [ip, #91]
 2027              	.LVL153:
 466:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2028              		.loc 1 466 0
 2029 1074 90199FE5 		ldr	r1, .L221+32
 2030 1078 0420A0E1 		mov	r2, r4
 2031 107c 0E30A0E1 		mov	r3, lr
 2032 1080 0400A0E3 		mov	r0, #4
 2033 1084 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 2034 1088 FEFFFFEB 		bl	CyU3PDebugPrint
 467:../uvc.c      **** 					 break;
 2035              		.loc 1 467 0
 2036 108c B8FFFFEA 		b	.L137
 2037              	.LVL154:
 2038              	.L129:
 488:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2039              		.loc 1 488 0
 2040 1090 60099FE5 		ldr	r0, .L221+12
 2041 1094 8C44D6E5 		ldrb	r4, [r6, #1164]	@ zero_extendqisi2
 490:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2042              		.loc 1 490 0
 2043 1098 8E64D6E5 		ldrb	r6, [r6, #1166]	@ zero_extendqisi2
 489:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2044              		.loc 1 489 0
 2045 109c 00C0A0E3 		mov	ip, #0
 488:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2046              		.loc 1 488 0
 2047 10a0 5840C0E5 		strb	r4, [r0, #88]
 489:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2048              		.loc 1 489 0
 2049 10a4 59C0C0E5 		strb	ip, [r0, #89]
 490:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2050              		.loc 1 490 0
 2051 10a8 5A60C0E5 		strb	r6, [r0, #90]
 491:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2052              		.loc 1 491 0
 2053 10ac 5BC0C0E5 		strb	ip, [r0, #91]
 2054              	.LVL155:
 494:../uvc.c      **** 					 break;
 2055              		.loc 1 494 0
 2056 10b0 AFFFFFEA 		b	.L137
 2057              	.LVL156:
 2058              	.L128:
 483:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2059              		.loc 1 483 0
 2060 10b4 0542D6E5 		ldrb	r4, [r6, #517]	@ zero_extendqisi2
 2061 10b8 38E99FE5 		ldr	lr, .L221+12
 2062 10bc 804024E2 		eor	r4, r4, #128
 484:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2063              		.loc 1 484 0
 2064 10c0 0020A0E3 		mov	r2, #0
 483:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2065              		.loc 1 483 0
 2066 10c4 5840CEE5 		strb	r4, [lr, #88]
 484:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2067              		.loc 1 484 0
 2068 10c8 5920CEE5 		strb	r2, [lr, #89]
 2069              	.LVL157:
 394:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2070              		.loc 1 394 0
 2071 10cc FF60A0E3 		mov	r6, #255
 486:../uvc.c      **** 					 break;
 2072              		.loc 1 486 0
 2073 10d0 A7FFFFEA 		b	.L137
 2074              	.LVL158:
 2075              	.L127:
 472:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2076              		.loc 1 472 0
 2077 10d4 A611D6E5 		ldrb	r1, [r6, #422]	@ zero_extendqisi2
 470:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2078              		.loc 1 470 0
 2079 10d8 A561D6E5 		ldrb	r6, [r6, #421]	@ zero_extendqisi2
 2080              	.LVL159:
 472:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2081              		.loc 1 472 0
 2082 10dc 020011E3 		tst	r1, #2
 475:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2083              		.loc 1 475 0
 2084 10e0 2661A001 		moveq	r6, r6, lsr #2
 2085              	.LVL160:
 2086 10e4 866CE001 		mvneq	r6, r6, asl #25
 2087 10e8 A66CE001 		mvneq	r6, r6, lsr #25
 477:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2088              		.loc 1 477 0
 2089 10ec 04399FE5 		ldr	r3, .L221+12
 473:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2090              		.loc 1 473 0
 2091 10f0 0113A011 		movne	r1, r1, asl #6
 2092 10f4 40400112 		andne	r4, r1, #64
 475:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2093              		.loc 1 475 0
 2094 10f8 01138601 		orreq	r1, r6, r1, asl #6
 473:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2095              		.loc 1 473 0
 2096 10fc 26418411 		orrne	r4, r4, r6, lsr #2
 2097              	.LVL161:
 475:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2098              		.loc 1 475 0
 2099 1100 FF400102 		andeq	r4, r1, #255
 2100              	.LVL162:
 478:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2101              		.loc 1 478 0
 2102 1104 0000A0E3 		mov	r0, #0
 477:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2103              		.loc 1 477 0
 2104 1108 5840C3E5 		strb	r4, [r3, #88]
 478:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2105              		.loc 1 478 0
 2106 110c 5900C3E5 		strb	r0, [r3, #89]
 2107              	.LVL163:
 394:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2108              		.loc 1 394 0
 2109 1110 FF60A0E3 		mov	r6, #255
 480:../uvc.c      **** 					 break;
 2110              		.loc 1 480 0
 2111 1114 96FFFFEA 		b	.L137
 2112              	.LVL164:
 2113              	.L126:
 497:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2114              		.loc 1 497 0
 2115 1118 842084E0 		add	r2, r4, r4, asl #1
 2116 111c 826186E0 		add	r6, r6, r2, asl #3
 2117 1120 D0389FE5 		ldr	r3, .L221+12
 2118 1124 8D41D6E5 		ldrb	r4, [r6, #397]	@ zero_extendqisi2
 498:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2119              		.loc 1 498 0
 2120 1128 0010A0E3 		mov	r1, #0
 394:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2121              		.loc 1 394 0
 2122 112c FF60A0E3 		mov	r6, #255
 497:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2123              		.loc 1 497 0
 2124 1130 5840C3E5 		strb	r4, [r3, #88]
 498:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2125              		.loc 1 498 0
 2126 1134 5910C3E5 		strb	r1, [r3, #89]
 2127              	.LVL165:
 500:../uvc.c      **** 					 break;
 2128              		.loc 1 500 0
 2129 1138 8DFFFFEA 		b	.L137
 2130              	.LVL166:
 2131              	.L175:
 734:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2132              		.loc 1 734 0
 2133 113c CC489FE5 		ldr	r4, .L221+36
 2134 1140 0010E0E3 		mvn	r1, #0
 2135 1144 1C0094E5 		ldr	r0, [r4, #28]
 2136 1148 FEFFFFEB 		bl	_txe_mutex_get
 2137              	.LVL167:
 735:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2138              		.loc 1 735 0
 2139 114c 2210A0E3 		mov	r1, #34
 2140              	.L213:
 2141 1150 18C09DE5 		ldr	ip, [sp, #24]
 2142 1154 00E0A0E3 		mov	lr, #0
 2143 1158 0A30A0E1 		mov	r3, sl
 2144 115c 0920A0E1 		mov	r2, r9
 2145 1160 0400A0E1 		mov	r0, r4
 2146 1164 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2147 1168 FEFFFFEB 		bl	cmdSet
 736:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2148              		.loc 1 736 0
 2149 116c 1C0094E5 		ldr	r0, [r4, #28]
 2150 1170 FEFFFFEB 		bl	_txe_mutex_put
 737:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2151              		.loc 1 737 0
 2152 1174 18109DE5 		ldr	r1, [sp, #24]
 2153 1178 877087E0 		add	r7, r7, r7, asl #1
 2154              	.LVL168:
 2155 117c 876186E0 		add	r6, r6, r7, asl #3
 738:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2156              		.loc 1 738 0
 2157 1180 0130A0E3 		mov	r3, #1
 739:../uvc.c      **** 							 break;
 2158              		.loc 1 739 0
 2159 1184 FFE0A0E3 		mov	lr, #255
 738:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2160              		.loc 1 738 0
 2161 1188 1030C6E5 		strb	r3, [r6, #16]
 737:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2162              		.loc 1 737 0
 2163 118c 0D10C6E5 		strb	r1, [r6, #13]
 738:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2164              		.loc 1 738 0
 2165 1190 0130A0E1 		mov	r3, r1
 2166 1194 1CC09DE5 		ldr	ip, [sp, #28]
 739:../uvc.c      **** 							 break;
 2167              		.loc 1 739 0
 2168 1198 0E40A0E1 		mov	r4, lr
 2169 119c 7CFEFFEA 		b	.L125
 2170              	.LVL169:
 2171              	.L174:
 726:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2172              		.loc 1 726 0
 2173 11a0 68489FE5 		ldr	r4, .L221+36
 2174 11a4 0010E0E3 		mvn	r1, #0
 2175 11a8 1C0094E5 		ldr	r0, [r4, #28]
 2176 11ac FEFFFFEB 		bl	_txe_mutex_get
 2177              	.LVL170:
 727:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2178              		.loc 1 727 0
 2179 11b0 2110A0E3 		mov	r1, #33
 2180 11b4 E5FFFFEA 		b	.L213
 2181              	.LVL171:
 2182              	.L173:
 712:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2183              		.loc 1 712 0
 2184 11b8 50489FE5 		ldr	r4, .L221+36
 2185 11bc 0010E0E3 		mvn	r1, #0
 2186 11c0 1C0094E5 		ldr	r0, [r4, #28]
 2187 11c4 14C08DE5 		str	ip, [sp, #20]
 2188 11c8 FEFFFFEB 		bl	_txe_mutex_get
 2189              	.LVL172:
 711:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2190              		.loc 1 711 0
 2191 11cc 18209DE5 		ldr	r2, [sp, #24]
 714:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2192              		.loc 1 714 0
 2193 11d0 00E0A0E3 		mov	lr, #0
 711:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2194              		.loc 1 711 0
 2195 11d4 7F8002E2 		and	r8, r2, #127
 2196 11d8 1C808DE5 		str	r8, [sp, #28]
 2197              	.LVL173:
 714:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2198              		.loc 1 714 0
 2199 11dc 1CC09DE5 		ldr	ip, [sp, #28]
 2200 11e0 2010A0E3 		mov	r1, #32
 2201 11e4 0920A0E1 		mov	r2, r9
 2202 11e8 0A30A0E1 		mov	r3, sl
 2203 11ec 0400A0E1 		mov	r0, r4
 2204 11f0 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2205 11f4 FEFFFFEB 		bl	cmdSet
 2206              	.LVL174:
 716:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2207              		.loc 1 716 0
 2208 11f8 14C09DE5 		ldr	ip, [sp, #20]
 2209 11fc 0A30A0E1 		mov	r3, sl
 2210 1200 0180A0E3 		mov	r8, #1
 2211 1204 2010A0E3 		mov	r1, #32
 2212 1208 0B20A0E1 		mov	r2, fp
 2213 120c 0400A0E1 		mov	r0, r4
 2214 1210 00C08DE5 		str	ip, [sp, #0]
 2215 1214 04808DE5 		str	r8, [sp, #4]
 2216 1218 FEFFFFEB 		bl	cmdSet
 717:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2217              		.loc 1 717 0
 2218 121c 1C0094E5 		ldr	r0, [r4, #28]
 2219 1220 FEFFFFEB 		bl	_txe_mutex_put
 2220              	.LVL175:
 720:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2221              		.loc 1 720 0
 2222 1224 1C009DE5 		ldr	r0, [sp, #28]
 2223 1228 877087E0 		add	r7, r7, r7, asl #1
 2224              	.LVL176:
 2225 122c 876186E0 		add	r6, r6, r7, asl #3
 2226 1230 0D00C6E5 		strb	r0, [r6, #13]
 721:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2227              		.loc 1 721 0
 2228 1234 14C09DE5 		ldr	ip, [sp, #20]
 723:../uvc.c      **** 							 break;
 2229              		.loc 1 723 0
 2230 1238 FFE0A0E3 		mov	lr, #255
 721:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2231              		.loc 1 721 0
 2232 123c 0EC0C6E5 		strb	ip, [r6, #14]
 722:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2233              		.loc 1 722 0
 2234 1240 1080C6E5 		strb	r8, [r6, #16]
 2235 1244 18309DE5 		ldr	r3, [sp, #24]
 723:../uvc.c      **** 							 break;
 2236              		.loc 1 723 0
 2237 1248 0E40A0E1 		mov	r4, lr
 2238 124c 50FEFFEA 		b	.L125
 2239              	.LVL177:
 2240              	.L172:
 683:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2241              		.loc 1 683 0 discriminator 1
 2242 1250 000058E3 		cmp	r8, #0
 2243 1254 1800000A 		beq	.L178
 681:../uvc.c      **** 							 break;
 2244              		.loc 1 681 0
 2245 1258 28E1A0E1 		mov	lr, r8, lsr #2
 2246 125c 00005EE3 		cmp	lr, #0
 2247 1260 03005813 		cmpne	r8, #3
 2248 1264 0020A083 		movhi	r2, #0
 2249 1268 0120A093 		movls	r2, #1
 2250              	.LVL178:
 376:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2251              		.loc 1 376 0
 2252 126c 0E31A0E1 		mov	r3, lr, asl #2
 681:../uvc.c      **** 							 break;
 2253              		.loc 1 681 0
 2254 1270 D801009A 		bls	.L198
 2255 1274 98179FE5 		ldr	r1, .L221+40
 2256 1278 0C0081E2 		add	r0, r1, #12
 2257              	.LVL179:
 2258              	.L189:
 684:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2259              		.loc 1 684 0 discriminator 2
 2260 127c 044090E4 		ldr	r4, [r0], #4
 2261 1280 012082E2 		add	r2, r2, #1
 2262 1284 FF2002E2 		and	r2, r2, #255
 2263 1288 02005EE1 		cmp	lr, r2
 2264 128c 044081E4 		str	r4, [r1], #4
 2265 1290 F9FFFF8A 		bhi	.L189
 684:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2266              		.loc 1 684 0 is_stmt 0
 2267 1294 030058E1 		cmp	r8, r3
 2268 1298 0700000A 		beq	.L178
 2269              	.LVL180:
 2270              	.L203:
 2271 129c 54C79FE5 		ldr	ip, .L221+12
 2272 12a0 03E08CE0 		add	lr, ip, r3
 2273 12a4 5810DEE5 		ldrb	r1, [lr, #88]	@ zero_extendqisi2
 683:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2274              		.loc 1 683 0 is_stmt 1
 2275 12a8 013083E2 		add	r3, r3, #1
 2276 12ac FF3003E2 		and	r3, r3, #255
 2277              	.LVL181:
 2278 12b0 030058E1 		cmp	r8, r3
 684:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2279              		.loc 1 684 0
 2280 12b4 4C10CEE5 		strb	r1, [lr, #76]
 683:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2281              		.loc 1 683 0
 2282 12b8 F7FFFF8A 		bhi	.L203
 2283              	.LVL182:
 2284              	.L178:
 686:../uvc.c      **** 					 		I2CCmdHandler();
 2285              		.loc 1 686 0
 2286 12bc FEFFFFEB 		bl	I2CCmdHandler
 687:../uvc.c      **** 							 break;
 2287              		.loc 1 687 0
 2288 12c0 FFE0A0E3 		mov	lr, #255
 686:../uvc.c      **** 					 		I2CCmdHandler();
 2289              		.loc 1 686 0
 2290 12c4 18309DE5 		ldr	r3, [sp, #24]
 2291 12c8 1CC09DE5 		ldr	ip, [sp, #28]
 687:../uvc.c      **** 							 break;
 2292              		.loc 1 687 0
 2293 12cc 0E40A0E1 		mov	r4, lr
 2294 12d0 2FFEFFEA 		b	.L125
 2295              	.LVL183:
 2296              	.L171:
 677:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2297              		.loc 1 677 0
 2298 12d4 34479FE5 		ldr	r4, .L221+36
 2299 12d8 0010E0E3 		mvn	r1, #0
 2300 12dc 1C0094E5 		ldr	r0, [r4, #28]
 2301 12e0 FEFFFFEB 		bl	_txe_mutex_get
 2302              	.LVL184:
 678:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2303              		.loc 1 678 0
 2304 12e4 18009DE5 		ldr	r0, [sp, #24]
 2305 12e8 00E0A0E3 		mov	lr, #0
 2306 12ec 01C070E2 		rsbs	ip, r0, #1
 2307 12f0 00C0A033 		movcc	ip, #0
 2308 12f4 0A30A0E1 		mov	r3, sl
 2309 12f8 1E10A0E3 		mov	r1, #30
 2310 12fc 0920A0E1 		mov	r2, r9
 2311 1300 0400A0E1 		mov	r0, r4
 2312 1304 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2313 1308 FEFFFFEB 		bl	cmdSet
 679:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2314              		.loc 1 679 0
 2315 130c 1C0094E5 		ldr	r0, [r4, #28]
 2316 1310 FEFFFFEB 		bl	_txe_mutex_put
 680:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2317              		.loc 1 680 0
 2318 1314 0130A0E3 		mov	r3, #1
 681:../uvc.c      **** 							 break;
 2319              		.loc 1 681 0
 2320 1318 FFE0A0E3 		mov	lr, #255
 680:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2321              		.loc 1 680 0
 2322 131c 6034C6E5 		strb	r3, [r6, #1120]
 2323 1320 1CC09DE5 		ldr	ip, [sp, #28]
 2324 1324 18309DE5 		ldr	r3, [sp, #24]
 681:../uvc.c      **** 							 break;
 2325              		.loc 1 681 0
 2326 1328 0E40A0E1 		mov	r4, lr
 2327 132c 18FEFFEA 		b	.L125
 2328              	.LVL185:
 2329              	.L169:
 644:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2330              		.loc 1 644 0
 2331 1330 D8469FE5 		ldr	r4, .L221+36
 640:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2332              		.loc 1 640 0
 2333 1334 E533C6E5 		strb	r3, [r6, #997]
 641:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2334              		.loc 1 641 0
 2335 1338 1C309DE5 		ldr	r3, [sp, #28]
 642:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2336              		.loc 1 642 0
 2337 133c 0170A0E3 		mov	r7, #1
 2338              	.LVL186:
 644:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2339              		.loc 1 644 0
 2340 1340 0010E0E3 		mvn	r1, #0
 641:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2341              		.loc 1 641 0
 2342 1344 E633C6E5 		strb	r3, [r6, #998]
 644:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2343              		.loc 1 644 0
 2344 1348 1C0094E5 		ldr	r0, [r4, #28]
 642:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2345              		.loc 1 642 0
 2346 134c E873C6E5 		strb	r7, [r6, #1000]
 2347              	.LVL187:
 644:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2348              		.loc 1 644 0
 2349 1350 FEFFFFEB 		bl	_txe_mutex_get
 2350              	.LVL188:
 645:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2351              		.loc 1 645 0
 2352 1354 18C09DE5 		ldr	ip, [sp, #24]
 2353 1358 0400A0E1 		mov	r0, r4
 2354 135c 00C08DE5 		str	ip, [sp, #0]
 2355 1360 1910A0E3 		mov	r1, #25
 2356 1364 00C0A0E3 		mov	ip, #0
 2357 1368 0920A0E1 		mov	r2, r9
 2358 136c 0A30A0E1 		mov	r3, sl
 2359 1370 04C08DE5 		str	ip, [sp, #4]
 2360 1374 FEFFFFEB 		bl	cmdSet
 646:../uvc.c      **** 							 if(getData != 0){
 2361              		.loc 1 646 0
 2362 1378 18009DE5 		ldr	r0, [sp, #24]
 2363 137c 000050E3 		cmp	r0, #0
 2364 1380 0700000A 		beq	.L185
 2365              	.LVL189:
 648:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2366              		.loc 1 648 0
 2367 1384 1CE09DE5 		ldr	lr, [sp, #28]
 2368 1388 0400A0E1 		mov	r0, r4
 2369 138c 1910A0E3 		mov	r1, #25
 2370 1390 0B20A0E1 		mov	r2, fp
 2371 1394 0A30A0E1 		mov	r3, sl
 2372 1398 00E08DE5 		str	lr, [sp, #0]
 2373 139c 04708DE5 		str	r7, [sp, #4]
 2374 13a0 FEFFFFEB 		bl	cmdSet
 2375              	.LVL190:
 2376              	.L185:
 650:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2377              		.loc 1 650 0
 2378 13a4 1C0094E5 		ldr	r0, [r4, #28]
 2379 13a8 FEFFFFEB 		bl	_txe_mutex_put
 651:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2380              		.loc 1 651 0
 2381 13ac 44069FE5 		ldr	r0, .L221+12
 2382 13b0 40169FE5 		ldr	r1, .L221+12
 2383 13b4 5AC0D0E5 		ldrb	ip, [r0, #90]	@ zero_extendqisi2
 2384 13b8 5B40D1E5 		ldrb	r4, [r1, #91]	@ zero_extendqisi2
 2385 13bc 5930D0E5 		ldrb	r3, [r0, #89]	@ zero_extendqisi2
 2386 13c0 5820D0E5 		ldrb	r2, [r0, #88]	@ zero_extendqisi2
 2387 13c4 4C169FE5 		ldr	r1, .L221+44
 2388 13c8 0400A0E3 		mov	r0, #4
 2389 13cc 00C08DE5 		str	ip, [sp, #0]
 2390 13d0 04408DE5 		str	r4, [sp, #4]
 2391 13d4 FEFFFFEB 		bl	CyU3PDebugPrint
 652:../uvc.c      **** 							 break;
 2392              		.loc 1 652 0
 2393 13d8 FFE0A0E3 		mov	lr, #255
 651:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2394              		.loc 1 651 0
 2395 13dc 18309DE5 		ldr	r3, [sp, #24]
 2396 13e0 1CC09DE5 		ldr	ip, [sp, #28]
 652:../uvc.c      **** 							 break;
 2397              		.loc 1 652 0
 2398 13e4 0E40A0E1 		mov	r4, lr
 2399 13e8 E9FDFFEA 		b	.L125
 2400              	.LVL191:
 2401              	.L168:
 607:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2402              		.loc 1 607 0
 2403 13ec 001053E2 		subs	r1, r3, #0
 606:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2404              		.loc 1 606 0
 2405 13f0 0D13C6E5 		strb	r1, [r6, #781]
 2406 13f4 F0359FE5 		ldr	r3, .L221
 607:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2407              		.loc 1 607 0
 2408 13f8 5501001A 		bne	.L179
 608:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2409              		.loc 1 608 0
 2410 13fc B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2411              	.LVL192:
 2412 1400 020052E3 		cmp	r2, #2
 2413 1404 08005213 		cmpne	r2, #8
 2414 1408 0300000A 		beq	.L180
 609:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2415              		.loc 1 609 0
 2416 140c 010052E3 		cmp	r2, #1
 610:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2417              		.loc 1 610 0
 2418 1410 07208202 		addeq	r2, r2, #7
 612:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2419              		.loc 1 612 0
 2420 1414 0220A013 		movne	r2, #2
 2421 1418 B524C3E5 		strb	r2, [r3, #1205]
 2422              	.LVL193:
 2423              	.L180:
 634:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2424              		.loc 1 634 0
 2425 141c EC459FE5 		ldr	r4, .L221+36
 632:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2426              		.loc 1 632 0
 2427 1420 0120A0E3 		mov	r2, #1
 634:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2428              		.loc 1 634 0
 2429 1424 0010E0E3 		mvn	r1, #0
 632:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2430              		.loc 1 632 0
 2431 1428 1023C6E5 		strb	r2, [r6, #784]
 2432              	.LVL194:
 634:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2433              		.loc 1 634 0
 2434 142c 1C0094E5 		ldr	r0, [r4, #28]
 2435 1430 FEFFFFEB 		bl	_txe_mutex_get
 635:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2436              		.loc 1 635 0
 2437 1434 18C09DE5 		ldr	ip, [sp, #24]
 2438 1438 1010A0E3 		mov	r1, #16
 2439 143c 00C08DE5 		str	ip, [sp, #0]
 2440 1440 0920A0E1 		mov	r2, r9
 2441 1444 0A30A0E1 		mov	r3, sl
 2442 1448 0400A0E1 		mov	r0, r4
 2443 144c 00C0A0E3 		mov	ip, #0
 2444              	.LVL195:
 2445              	.L212:
 840:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2446              		.loc 1 840 0
 2447 1450 04C08DE5 		str	ip, [sp, #4]
 2448 1454 FEFFFFEB 		bl	cmdSet
 841:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2449              		.loc 1 841 0
 2450 1458 1C0094E5 		ldr	r0, [r4, #28]
 2451 145c FEFFFFEB 		bl	_txe_mutex_put
 843:../uvc.c      **** 					 		 break;
 2452              		.loc 1 843 0
 2453 1460 FFE0A0E3 		mov	lr, #255
 841:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2454              		.loc 1 841 0
 2455 1464 18309DE5 		ldr	r3, [sp, #24]
 2456 1468 1CC09DE5 		ldr	ip, [sp, #28]
 843:../uvc.c      **** 					 		 break;
 2457              		.loc 1 843 0
 2458 146c 0E40A0E1 		mov	r4, lr
 2459 1470 C7FDFFEA 		b	.L125
 2460              	.LVL196:
 2461              	.L170:
 655:../uvc.c      **** 							 if(Data0 <= 3){
 2462              		.loc 1 655 0
 2463 1474 030053E3 		cmp	r3, #3
 656:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2464              		.loc 1 656 0
 2465 1478 78259F95 		ldrls	r2, .L221+12
 2466              	.LVL197:
 659:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2467              		.loc 1 659 0
 2468 147c 74E59F85 		ldrhi	lr, .L221+12
 2469 1480 0340A0E1 		mov	r4, r3
 2470              	.LVL198:
 656:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2471              		.loc 1 656 0
 2472 1484 0030A093 		movls	r3, #0
 2473 1488 7830C295 		strlsb	r3, [r2, #120]
 2474              	.LVL199:
 659:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2475              		.loc 1 659 0
 2476 148c 0120A083 		movhi	r2, #1
 2477 1490 18209D95 		ldrls	r2, [sp, #24]
 656:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2478              		.loc 1 656 0
 2479 1494 0430A091 		movls	r3, r4
 659:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2480              		.loc 1 659 0
 2481 1498 7820CE85 		strhib	r2, [lr, #120]
 2482 149c 0420A081 		movhi	r2, r4
 665:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2483              		.loc 1 665 0
 2484 14a0 68459FE5 		ldr	r4, .L221+36
 660:../uvc.c      **** 								 Data1 = Data0-4;
 2485              		.loc 1 660 0
 2486 14a4 04304382 		subhi	r3, r3, #4
 2487              	.LVL200:
 662:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2488              		.loc 1 662 0
 2489 14a8 2D24C6E5 		strb	r2, [r6, #1069]
 664:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2490              		.loc 1 664 0
 2491 14ac 0120A0E3 		mov	r2, #1
 665:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2492              		.loc 1 665 0
 2493 14b0 0010E0E3 		mvn	r1, #0
 663:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 2494              		.loc 1 663 0
 2495 14b4 8D31C6E5 		strb	r3, [r6, #397]
 664:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2496              		.loc 1 664 0
 2497 14b8 3024C6E5 		strb	r2, [r6, #1072]
 665:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2498              		.loc 1 665 0
 2499 14bc 1C0094E5 		ldr	r0, [r4, #28]
 2500 14c0 FEFFFFEB 		bl	_txe_mutex_get
 2501              	.LVL201:
 666:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2502              		.loc 1 666 0
 2503 14c4 18C09DE5 		ldr	ip, [sp, #24]
 2504 14c8 1C10A0E3 		mov	r1, #28
 2505 14cc 00C08DE5 		str	ip, [sp, #0]
 2506 14d0 0920A0E1 		mov	r2, r9
 2507 14d4 0A30A0E1 		mov	r3, sl
 2508 14d8 0400A0E1 		mov	r0, r4
 2509 14dc 00C0A0E3 		mov	ip, #0
 2510 14e0 DAFFFFEA 		b	.L212
 2511              	.LVL202:
 2512              	.L167:
 800:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2513              		.loc 1 800 0
 2514 14e4 24459FE5 		ldr	r4, .L221+36
 2515 14e8 0010E0E3 		mvn	r1, #0
 2516 14ec 1C0094E5 		ldr	r0, [r4, #28]
 2517 14f0 FEFFFFEB 		bl	_txe_mutex_get
 2518              	.LVL203:
 801:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2519              		.loc 1 801 0
 2520 14f4 18C09DE5 		ldr	ip, [sp, #24]
 2521 14f8 0B10A0E3 		mov	r1, #11
 2522 14fc 0920A0E1 		mov	r2, r9
 2523 1500 0A30A0E1 		mov	r3, sl
 2524 1504 0400A0E1 		mov	r0, r4
 2525 1508 00C08DE5 		str	ip, [sp, #0]
 2526 150c 00C0A0E3 		mov	ip, #0
 2527 1510 04C08DE5 		str	ip, [sp, #4]
 2528 1514 FEFFFFEB 		bl	cmdSet
 2529              	.LVL204:
 803:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2530              		.loc 1 803 0
 2531 1518 1CE09DE5 		ldr	lr, [sp, #28]
 2532 151c 0B20A0E1 		mov	r2, fp
 2533 1520 0A30A0E1 		mov	r3, sl
 2534 1524 0170A0E3 		mov	r7, #1
 2535              	.LVL205:
 2536 1528 0B10A0E3 		mov	r1, #11
 2537 152c 0400A0E1 		mov	r0, r4
 2538 1530 00E08DE5 		str	lr, [sp, #0]
 2539 1534 04708DE5 		str	r7, [sp, #4]
 2540 1538 FEFFFFEB 		bl	cmdSet
 804:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2541              		.loc 1 804 0
 2542 153c 1C0094E5 		ldr	r0, [r4, #28]
 2543 1540 FEFFFFEB 		bl	_txe_mutex_put
 807:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2544              		.loc 1 807 0
 2545 1544 1C209DE5 		ldr	r2, [sp, #28]
 806:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2546              		.loc 1 806 0
 2547 1548 18309DE5 		ldr	r3, [sp, #24]
 809:../uvc.c      **** 							 break;
 2548              		.loc 1 809 0
 2549 154c FFE0A0E3 		mov	lr, #255
 806:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2550              		.loc 1 806 0
 2551 1550 8C34C6E5 		strb	r3, [r6, #1164]
 807:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2552              		.loc 1 807 0
 2553 1554 8E24C6E5 		strb	r2, [r6, #1166]
 808:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2554              		.loc 1 808 0
 2555 1558 9872C6E5 		strb	r7, [r6, #664]
 2556 155c 02C0A0E1 		mov	ip, r2
 809:../uvc.c      **** 							 break;
 2557              		.loc 1 809 0
 2558 1560 0E40A0E1 		mov	r4, lr
 2559 1564 8AFDFFEA 		b	.L125
 2560              	.LVL206:
 2561              	.L166:
 786:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2562              		.loc 1 786 0
 2563 1568 A0449FE5 		ldr	r4, .L221+36
 2564 156c 0010E0E3 		mvn	r1, #0
 2565 1570 1C0094E5 		ldr	r0, [r4, #28]
 2566 1574 FEFFFFEB 		bl	_txe_mutex_get
 2567              	.LVL207:
 787:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2568              		.loc 1 787 0
 2569 1578 18C09DE5 		ldr	ip, [sp, #24]
 2570 157c 0610A0E3 		mov	r1, #6
 2571 1580 0920A0E1 		mov	r2, r9
 2572 1584 0A30A0E1 		mov	r3, sl
 2573 1588 0400A0E1 		mov	r0, r4
 2574 158c 00C08DE5 		str	ip, [sp, #0]
 2575 1590 00C0A0E3 		mov	ip, #0
 2576 1594 04C08DE5 		str	ip, [sp, #4]
 2577 1598 FEFFFFEB 		bl	cmdSet
 2578              	.LVL208:
 789:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2579              		.loc 1 789 0
 2580 159c 18E09DE5 		ldr	lr, [sp, #24]
 2581 15a0 0A30A0E1 		mov	r3, sl
 2582 15a4 0170A0E3 		mov	r7, #1
 2583              	.LVL209:
 2584 15a8 0610A0E3 		mov	r1, #6
 2585 15ac 0B20A0E1 		mov	r2, fp
 2586 15b0 0400A0E1 		mov	r0, r4
 2587 15b4 00E08DE5 		str	lr, [sp, #0]
 2588 15b8 04708DE5 		str	r7, [sp, #4]
 2589 15bc FEFFFFEB 		bl	cmdSet
 790:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2590              		.loc 1 790 0
 2591 15c0 1C0094E5 		ldr	r0, [r4, #28]
 2592 15c4 FEFFFFEB 		bl	_txe_mutex_put
 791:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2593              		.loc 1 791 0
 2594 15c8 18409DE5 		ldr	r4, [sp, #24]
 793:../uvc.c      **** 							 break;
 2595              		.loc 1 793 0
 2596 15cc FFE0A0E3 		mov	lr, #255
 791:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2597              		.loc 1 791 0
 2598 15d0 1D42C6E5 		strb	r4, [r6, #541]
 792:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2599              		.loc 1 792 0
 2600 15d4 0430A0E1 		mov	r3, r4
 2601 15d8 2072C6E5 		strb	r7, [r6, #544]
 2602 15dc 1CC09DE5 		ldr	ip, [sp, #28]
 793:../uvc.c      **** 							 break;
 2603              		.loc 1 793 0
 2604 15e0 0E40A0E1 		mov	r4, lr
 2605 15e4 6AFDFFEA 		b	.L125
 2606              	.LVL210:
 2607              	.L165:
 766:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2608              		.loc 1 766 0
 2609 15e8 20449FE5 		ldr	r4, .L221+36
 2610 15ec 0010E0E3 		mvn	r1, #0
 2611 15f0 1C0094E5 		ldr	r0, [r4, #28]
 2612 15f4 FEFFFFEB 		bl	_txe_mutex_get
 2613              	.LVL211:
 767:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2614              		.loc 1 767 0
 2615 15f8 18109DE5 		ldr	r1, [sp, #24]
 2616 15fc 00E0A0E3 		mov	lr, #0
 2617 1600 802041E2 		sub	r2, r1, #128
 2618 1604 FFC002E2 		and	ip, r2, #255
 2619 1608 0510A0E3 		mov	r1, #5
 2620 160c 0920A0E1 		mov	r2, r9
 2621 1610 0A30A0E1 		mov	r3, sl
 2622 1614 0400A0E1 		mov	r0, r4
 2623 1618 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2624 161c FEFFFFEB 		bl	cmdSet
 2625              	.LVL212:
 769:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2626              		.loc 1 769 0
 2627 1620 18009DE5 		ldr	r0, [sp, #24]
 2628 1624 0510A0E3 		mov	r1, #5
 2629 1628 767040E2 		sub	r7, r0, #118
 2630              	.LVL213:
 2631 162c FFC007E2 		and	ip, r7, #255
 2632 1630 DC20A0E3 		mov	r2, #220
 2633 1634 0170A0E3 		mov	r7, #1
 2634 1638 0A30A0E1 		mov	r3, sl
 2635 163c 0400A0E1 		mov	r0, r4
 2636 1640 00C08DE5 		str	ip, [sp, #0]
 2637 1644 04708DE5 		str	r7, [sp, #4]
 2638 1648 FEFFFFEB 		bl	cmdSet
 2639              	.LVL214:
 771:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2640              		.loc 1 771 0
 2641 164c 18309DE5 		ldr	r3, [sp, #24]
 2642 1650 DE20A0E3 		mov	r2, #222
 2643 1654 7E1083E2 		add	r1, r3, #126
 2644 1658 FFC001E2 		and	ip, r1, #255
 2645 165c 0A30A0E1 		mov	r3, sl
 2646 1660 0510A0E3 		mov	r1, #5
 2647 1664 0400A0E1 		mov	r0, r4
 2648 1668 00C08DE5 		str	ip, [sp, #0]
 2649 166c 02C0A0E3 		mov	ip, #2
 2650 1670 04C08DE5 		str	ip, [sp, #4]
 2651 1674 FEFFFFEB 		bl	cmdSet
 2652              	.LVL215:
 773:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2653              		.loc 1 773 0
 2654 1678 18209DE5 		ldr	r2, [sp, #24]
 2655 167c 0510A0E3 		mov	r1, #5
 2656 1680 720082E2 		add	r0, r2, #114
 2657 1684 FFC000E2 		and	ip, r0, #255
 2658 1688 E020A0E3 		mov	r2, #224
 2659 168c 0A30A0E1 		mov	r3, sl
 2660 1690 0400A0E1 		mov	r0, r4
 2661 1694 00C08DE5 		str	ip, [sp, #0]
 2662 1698 03C0A0E3 		mov	ip, #3
 2663 169c 04C08DE5 		str	ip, [sp, #4]
 2664 16a0 FEFFFFEB 		bl	cmdSet
 2665              	.LVL216:
 775:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2666              		.loc 1 775 0
 2667 16a4 18309DE5 		ldr	r3, [sp, #24]
 2668 16a8 DD20A0E3 		mov	r2, #221
 2669 16ac 6F1043E2 		sub	r1, r3, #111
 2670 16b0 FFC001E2 		and	ip, r1, #255
 2671 16b4 0A30A0E1 		mov	r3, sl
 2672 16b8 0510A0E3 		mov	r1, #5
 2673 16bc 0400A0E1 		mov	r0, r4
 2674 16c0 00C08DE5 		str	ip, [sp, #0]
 2675 16c4 04C0A0E3 		mov	ip, #4
 2676 16c8 04C08DE5 		str	ip, [sp, #4]
 2677 16cc FEFFFFEB 		bl	cmdSet
 2678              	.LVL217:
 777:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2679              		.loc 1 777 0
 2680 16d0 20239FE5 		ldr	r2, .L221+12
 2681 16d4 05E0A0E3 		mov	lr, #5
 2682 16d8 5800D2E5 		ldrb	r0, [r2, #88]	@ zero_extendqisi2
 2683 16dc 0E10A0E1 		mov	r1, lr
 2684 16e0 7F3080E2 		add	r3, r0, #127
 2685 16e4 FFC003E2 		and	ip, r3, #255
 2686 16e8 0B20A0E1 		mov	r2, fp
 2687 16ec 0A30A0E1 		mov	r3, sl
 2688 16f0 0400A0E1 		mov	r0, r4
 2689 16f4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2690 16f8 FEFFFFEB 		bl	cmdSet
 778:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2691              		.loc 1 778 0
 2692 16fc 1C0094E5 		ldr	r0, [r4, #28]
 2693 1700 FEFFFFEB 		bl	_txe_mutex_put
 780:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2694              		.loc 1 780 0
 2695 1704 EC129FE5 		ldr	r1, .L221+12
 782:../uvc.c      **** 							 break;
 2696              		.loc 1 782 0
 2697 1708 FFE0A0E3 		mov	lr, #255
 780:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2698              		.loc 1 780 0
 2699 170c 58C0D1E5 		ldrb	ip, [r1, #88]	@ zero_extendqisi2
 781:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2700              		.loc 1 781 0
 2701 1710 0872C6E5 		strb	r7, [r6, #520]
 780:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2702              		.loc 1 780 0
 2703 1714 80204CE2 		sub	r2, ip, #128
 2704 1718 0522C6E5 		strb	r2, [r6, #517]
 781:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2705              		.loc 1 781 0
 2706 171c 18309DE5 		ldr	r3, [sp, #24]
 2707 1720 1CC09DE5 		ldr	ip, [sp, #28]
 782:../uvc.c      **** 							 break;
 2708              		.loc 1 782 0
 2709 1724 0E40A0E1 		mov	r4, lr
 2710 1728 19FDFFEA 		b	.L125
 2711              	.LVL218:
 2712              	.L164:
 818:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2713              		.loc 1 818 0
 2714 172c DC429FE5 		ldr	r4, .L221+36
 812:../uvc.c      **** 							 Data0 = Data0 - 1;
 2715              		.loc 1 812 0
 2716 1730 017043E2 		sub	r7, r3, #1
 2717              	.LVL219:
 2718 1734 FF7007E2 		and	r7, r7, #255
 2719              	.LVL220:
 816:../uvc.c      **** 								 Data0 = 1;
 2720              		.loc 1 816 0
 2721 1738 020057E3 		cmp	r7, #2
 818:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2722              		.loc 1 818 0
 2723 173c 0010E0E3 		mvn	r1, #0
 2724 1740 1C0094E5 		ldr	r0, [r4, #28]
 816:../uvc.c      **** 								 Data0 = 1;
 2725              		.loc 1 816 0
 2726 1744 0170A083 		movhi	r7, #1
 2727              	.LVL221:
 818:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2728              		.loc 1 818 0
 2729 1748 FEFFFFEB 		bl	_txe_mutex_get
 2730              	.LVL222:
 819:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2731              		.loc 1 819 0
 2732 174c 00C0A0E3 		mov	ip, #0
 2733 1750 0A30A0E1 		mov	r3, sl
 2734 1754 0410A0E3 		mov	r1, #4
 2735 1758 0920A0E1 		mov	r2, r9
 2736 175c 0400A0E1 		mov	r0, r4
 2737 1760 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2738 1764 FEFFFFEB 		bl	cmdSet
 820:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2739              		.loc 1 820 0
 2740 1768 1C0094E5 		ldr	r0, [r4, #28]
 2741 176c FEFFFFEB 		bl	_txe_mutex_put
 824:../uvc.c      **** 							 break;
 2742              		.loc 1 824 0
 2743 1770 FFE0A0E3 		mov	lr, #255
 823:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2744              		.loc 1 823 0
 2745 1774 0100A0E3 		mov	r0, #1
 822:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2746              		.loc 1 822 0
 2747 1778 ED71C6E5 		strb	r7, [r6, #493]
 823:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2748              		.loc 1 823 0
 2749 177c F001C6E5 		strb	r0, [r6, #496]
 2750 1780 18309DE5 		ldr	r3, [sp, #24]
 2751 1784 1CC09DE5 		ldr	ip, [sp, #28]
 824:../uvc.c      **** 							 break;
 2752              		.loc 1 824 0
 2753 1788 0E40A0E1 		mov	r4, lr
 2754 178c 00FDFFEA 		b	.L125
 2755              	.LVL223:
 2756              	.L163:
 742:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2757              		.loc 1 742 0
 2758 1790 78729FE5 		ldr	r7, .L221+36
 2759              	.LVL224:
 2760 1794 0010E0E3 		mvn	r1, #0
 2761 1798 1C0097E5 		ldr	r0, [r7, #28]
 2762 179c FEFFFFEB 		bl	_txe_mutex_get
 2763              	.LVL225:
 744:../uvc.c      **** 							  if(Data0&0x80){
 2764              		.loc 1 744 0
 2765 17a0 18809DE5 		ldr	r8, [sp, #24]
 745:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2766              		.loc 1 745 0
 2767 17a4 A601D6E5 		ldrb	r0, [r6, #422]	@ zero_extendqisi2
 744:../uvc.c      **** 							  if(Data0&0x80){
 2768              		.loc 1 744 0
 2769 17a8 800018E3 		tst	r8, #128
 747:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2770              		.loc 1 747 0
 2771 17ac 2843A001 		moveq	r4, r8, lsr #6
 745:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2772              		.loc 1 745 0
 2773 17b0 884CA011 		movne	r4, r8, asl #25
 747:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2774              		.loc 1 747 0
 2775 17b4 02408403 		orreq	r4, r4, #2
 745:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2776              		.loc 1 745 0
 2777 17b8 0300C013 		bicne	r0, r0, #3
 747:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2778              		.loc 1 747 0
 2779 17bc 0300C003 		biceq	r0, r0, #3
 745:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2780              		.loc 1 745 0
 2781 17c0 A44F8011 		orrne	r4, r0, r4, lsr #31
 747:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2782              		.loc 1 747 0
 2783 17c4 00408401 		orreq	r4, r4, r0
 2784              	.LVL226:
 749:../uvc.c      **** 							 Data1 |= ~0x03;
 2785              		.loc 1 749 0
 2786 17c8 043FE0E1 		mvn	r3, r4, asl #30
 2787 17cc 231FE0E1 		mvn	r1, r3, lsr #30
 2788              	.LVL227:
 750:../uvc.c      **** 							 Data1 &= 0xC7;
 2789              		.loc 1 750 0
 2790 17d0 C7C001E2 		and	ip, r1, #199
 2791              	.LVL228:
 751:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2792              		.loc 1 751 0
 2793 17d4 00E0A0E3 		mov	lr, #0
 2794 17d8 0110A0E3 		mov	r1, #1
 2795 17dc 0B20A0E1 		mov	r2, fp
 2796 17e0 0A30A0E1 		mov	r3, sl
 2797 17e4 24029FE5 		ldr	r0, .L221+36
 755:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2798              		.loc 1 755 0
 2799 17e8 0140A0E1 		mov	r4, r1
 751:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2800              		.loc 1 751 0
 2801 17ec 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2802 17f0 14C08DE5 		str	ip, [sp, #20]
 2803 17f4 FEFFFFEB 		bl	cmdSet
 2804              	.LVL229:
 754:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2805              		.loc 1 754 0
 2806 17f8 18209DE5 		ldr	r2, [sp, #24]
 755:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2807              		.loc 1 755 0
 2808 17fc 0410A0E1 		mov	r1, r4
 754:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2809              		.loc 1 754 0
 2810 1800 0281A0E1 		mov	r8, r2, asl #2
 755:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2811              		.loc 1 755 0
 2812 1804 0A30A0E1 		mov	r3, sl
 754:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2813              		.loc 1 754 0
 2814 1808 FF8008E2 		and	r8, r8, #255
 2815              	.LVL230:
 755:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2816              		.loc 1 755 0
 2817 180c 0920A0E1 		mov	r2, r9
 2818 1810 F8019FE5 		ldr	r0, .L221+36
 2819 1814 04408DE5 		str	r4, [sp, #4]
 2820 1818 00808DE5 		str	r8, [sp, #0]
 2821 181c FEFFFFEB 		bl	cmdSet
 756:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2822              		.loc 1 756 0
 2823 1820 1C0097E5 		ldr	r0, [r7, #28]
 2824 1824 FEFFFFEB 		bl	_txe_mutex_put
 758:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2825              		.loc 1 758 0
 2826 1828 A581C6E5 		strb	r8, [r6, #421]
 759:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2827              		.loc 1 759 0
 2828 182c 14009DE5 		ldr	r0, [sp, #20]
 762:../uvc.c      **** 							 break;
 2829              		.loc 1 762 0
 2830 1830 FFE0A0E3 		mov	lr, #255
 760:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2831              		.loc 1 760 0
 2832 1834 A841C6E5 		strb	r4, [r6, #424]
 759:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2833              		.loc 1 759 0
 2834 1838 A601C6E5 		strb	r0, [r6, #422]
 760:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2835              		.loc 1 760 0
 2836 183c 18309DE5 		ldr	r3, [sp, #24]
 2837 1840 1CC09DE5 		ldr	ip, [sp, #28]
 762:../uvc.c      **** 							 break;
 2838              		.loc 1 762 0
 2839 1844 0E40A0E1 		mov	r4, lr
 2840 1848 D1FCFFEA 		b	.L125
 2841              	.LVL231:
 2842              	.L162:
 828:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2843              		.loc 1 828 0
 2844 184c A4219FE5 		ldr	r2, .L221+12
 2845              	.LVL232:
 827:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2846              		.loc 1 827 0
 2847 1850 0110A0E3 		mov	r1, #1
 828:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2848              		.loc 1 828 0
 2849 1854 7820D2E5 		ldrb	r2, [r2, #120]	@ zero_extendqisi2
 826:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2850              		.loc 1 826 0
 2851 1858 8D31C6E5 		strb	r3, [r6, #397]
 828:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2852              		.loc 1 828 0
 2853 185c 010052E3 		cmp	r2, #1
 827:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2854              		.loc 1 827 0
 2855 1860 9011C6E5 		strb	r1, [r6, #400]
 2856 1864 0370A011 		movne	r7, r3
 2857              	.LVL233:
 828:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2858              		.loc 1 828 0
 2859 1868 4E00000A 		beq	.L220
 2860              	.LVL234:
 2861              	.L195:
 839:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2862              		.loc 1 839 0
 2863 186c 9C419FE5 		ldr	r4, .L221+36
 2864 1870 0010E0E3 		mvn	r1, #0
 2865 1874 1C0094E5 		ldr	r0, [r4, #28]
 837:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 2866              		.loc 1 837 0
 2867 1878 2D74C6E5 		strb	r7, [r6, #1069]
 2868              	.LVL235:
 839:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2869              		.loc 1 839 0
 2870 187c FEFFFFEB 		bl	_txe_mutex_get
 840:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2871              		.loc 1 840 0
 2872 1880 00C0A0E3 		mov	ip, #0
 2873 1884 0C10A0E1 		mov	r1, ip
 2874 1888 0920A0E1 		mov	r2, r9
 2875 188c 0A30A0E1 		mov	r3, sl
 2876 1890 0400A0E1 		mov	r0, r4
 2877 1894 00708DE5 		str	r7, [sp, #0]
 2878 1898 ECFEFFEA 		b	.L212
 2879              	.LVL236:
 2880              	.L161:
 847:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2881              		.loc 1 847 0
 2882 189c 6C719FE5 		ldr	r7, .L221+36
 2883              	.LVL237:
 2884 18a0 0010E0E3 		mvn	r1, #0
 2885 18a4 1C0097E5 		ldr	r0, [r7, #28]
 2886 18a8 FEFFFFEB 		bl	_txe_mutex_get
 2887              	.LVL238:
 848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2888              		.loc 1 848 0
 2889 18ac 18C09DE5 		ldr	ip, [sp, #24]
 2890 18b0 00E0A0E3 		mov	lr, #0
 2891 18b4 0410A0E1 		mov	r1, r4
 2892 18b8 0A30A0E1 		mov	r3, sl
 2893 18bc 0920A0E1 		mov	r2, r9
 2894 18c0 0700A0E1 		mov	r0, r7
 2895 18c4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2896 18c8 FEFFFFEB 		bl	cmdSet
 849:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2897              		.loc 1 849 0
 2898 18cc 1C0097E5 		ldr	r0, [r7, #28]
 2899 18d0 FEFFFFEB 		bl	_txe_mutex_put
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2900              		.loc 1 851 0
 2901 18d4 18009DE5 		ldr	r0, [sp, #24]
 2902 18d8 844084E0 		add	r4, r4, r4, asl #1
 2903 18dc 846186E0 		add	r6, r6, r4, asl #3
 852:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2904              		.loc 1 852 0
 2905 18e0 0130A0E3 		mov	r3, #1
 853:../uvc.c      **** 							 break;
 2906              		.loc 1 853 0
 2907 18e4 FFE0A0E3 		mov	lr, #255
 852:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2908              		.loc 1 852 0
 2909 18e8 9031C6E5 		strb	r3, [r6, #400]
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2910              		.loc 1 851 0
 2911 18ec 8D01C6E5 		strb	r0, [r6, #397]
 852:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2912              		.loc 1 852 0
 2913 18f0 0030A0E1 		mov	r3, r0
 2914 18f4 1CC09DE5 		ldr	ip, [sp, #28]
 853:../uvc.c      **** 							 break;
 2915              		.loc 1 853 0
 2916 18f8 0E40A0E1 		mov	r4, lr
 2917 18fc A4FCFFEA 		b	.L125
 2918              	.LVL239:
 2919              	.L160:
 856:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2920              		.loc 1 856 0
 2921 1900 0400A0E3 		mov	r0, #4
 2922              	.LVL240:
 2923 1904 10119FE5 		ldr	r1, .L221+48
 2924 1908 FEFFFFEB 		bl	CyU3PDebugPrint
 2925              	.LVL241:
 2926 190c FFE0A0E3 		mov	lr, #255
 2927 1910 0E40A0E1 		mov	r4, lr
 2928 1914 0EC0A0E1 		mov	ip, lr
 2929 1918 0E30A0E1 		mov	r3, lr
 2930 191c 9CFCFFEA 		b	.L125
 2931              	.LVL242:
 2932              	.L219:
 432:../uvc.c      **** 						if(sendData >= 3){
 2933              		.loc 1 432 0
 2934 1920 020054E3 		cmp	r4, #2
 2935 1924 04408492 		addls	r4, r4, #4
 2936              	.LVL243:
 2937 1928 FF400492 		andls	r4, r4, #255
 2938 192c C3FDFF9A 		bls	.L138
 433:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 2939              		.loc 1 433 0
 2940 1930 0430A0E1 		mov	r3, r4
 2941 1934 0400A0E3 		mov	r0, #4
 2942 1938 E0109FE5 		ldr	r1, .L221+52
 2943 193c FEFFFFEB 		bl	CyU3PDebugPrint
 2944              	.LVL244:
 435:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 2945              		.loc 1 435 0
 2946 1940 A4309FE5 		ldr	r3, .L221
 2947 1944 0020A0E3 		mov	r2, #0
 2948 1948 0440A0E3 		mov	r4, #4
 2949 194c 2D24C3E5 		strb	r2, [r3, #1069]
 2950              	.LVL245:
 2951 1950 BAFDFFEA 		b	.L138
 2952              	.LVL246:
 2953              	.L179:
 617:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2954              		.loc 1 617 0
 2955 1954 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2956              	.LVL247:
 616:../uvc.c      **** 								 Data1 = Data0 - 1;
 2957              		.loc 1 616 0
 2958 1958 014041E2 		sub	r4, r1, #1
 617:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2959              		.loc 1 617 0
 2960 195c 040052E3 		cmp	r2, #4
 2961 1960 01005213 		cmpne	r2, #1
 616:../uvc.c      **** 								 Data1 = Data0 - 1;
 2962              		.loc 1 616 0
 2963 1964 FF1004E2 		and	r1, r4, #255
 2964              	.LVL248:
 617:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2965              		.loc 1 617 0
 2966 1968 0300000A 		beq	.L182
 618:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2967              		.loc 1 618 0
 2968 196c 080052E3 		cmp	r2, #8
 619:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2969              		.loc 1 619 0
 2970 1970 0120A003 		moveq	r2, #1
 621:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 2971              		.loc 1 621 0
 2972 1974 0420A013 		movne	r2, #4
 2973 1978 B524C3E5 		strb	r2, [r3, #1205]
 2974              	.L182:
 624:../uvc.c      **** 								 if(Data1 < 8){
 2975              		.loc 1 624 0
 2976 197c 070051E3 		cmp	r1, #7
 625:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2977              		.loc 1 625 0
 2978 1980 9C309F95 		ldrls	r3, .L221+56
 628:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2979              		.loc 1 628 0
 2980 1984 0130A083 		movhi	r3, #1
 626:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2981              		.loc 1 626 0
 2982 1988 81008390 		addls	r0, r3, r1, asl #1
 625:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2983              		.loc 1 625 0
 2984 198c 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 626:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2985              		.loc 1 626 0
 2986 1990 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 628:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2987              		.loc 1 628 0
 2988 1994 E534C685 		strhib	r3, [r6, #1253]
 629:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2989              		.loc 1 629 0
 2990 1998 0030A083 		movhi	r3, #0
 625:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2991              		.loc 1 625 0
 2992 199c E524C695 		strlsb	r2, [r6, #1253]
 629:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2993              		.loc 1 629 0
 2994 19a0 E634C6E5 		strb	r3, [r6, #1254]
 2995 19a4 9CFEFFEA 		b	.L180
 2996              	.LVL249:
 2997              	.L220:
 830:../uvc.c      **** 								 if(Data0 < 3){
 2998              		.loc 1 830 0
 2999 19a8 020053E3 		cmp	r3, #2
 831:../uvc.c      **** 					 				 Data0 += 4;
 3000              		.loc 1 831 0
 3001 19ac 04708392 		addls	r7, r3, #4
 3002 19b0 FF700792 		andls	r7, r7, #255
 830:../uvc.c      **** 								 if(Data0 < 3){
 3003              		.loc 1 830 0
 3004 19b4 ACFFFF9A 		bls	.L195
 833:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 3005              		.loc 1 833 0
 3006 19b8 0400A0E3 		mov	r0, #4
 3007 19bc 5C109FE5 		ldr	r1, .L221+52
 3008 19c0 18309DE5 		ldr	r3, [sp, #24]
 3009 19c4 FEFFFFEB 		bl	CyU3PDebugPrint
 3010              	.LVL250:
 834:../uvc.c      **** 									Data0 = 4; //set to default.
 3011              		.loc 1 834 0
 3012 19c8 0470A0E3 		mov	r7, #4
 3013 19cc A6FFFFEA 		b	.L195
 3014              	.LVL251:
 3015              	.L210:
 3016 19d0 20009FE5 		ldr	r0, .L221+12
 3017 19d4 88FDFFEA 		b	.L136
 3018              	.LVL252:
 3019              	.L198:
 376:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 3020              		.loc 1 376 0
 3021 19d8 0030A0E3 		mov	r3, #0
 3022 19dc 2EFEFFEA 		b	.L203
 3023              	.LVL253:
 3024              	.L197:
 3025 19e0 10009FE5 		ldr	r0, .L221+12
 3026 19e4 0030A0E3 		mov	r3, #0
 3027 19e8 7CFDFFEA 		b	.L202
 3028              	.L222:
 3029              		.align	2
 3030              	.L221:
 3031 19ec 00000000 		.word	.LANCHOR1
 3032 19f0 00000000 		.word	bRequest
 3033 19f4 68030000 		.word	.LC21
 3034 19f8 00000000 		.word	.LANCHOR0
 3035 19fc 58000000 		.word	.LANCHOR0+88
 3036 1a00 01000100 		.word	65537
 3037 1a04 FF00FF00 		.word	16711935
 3038 1a08 A8020000 		.word	.LC17
 3039 1a0c E4020000 		.word	.LC18
 3040 1a10 00000000 		.word	cmdQu
 3041 1a14 4C000000 		.word	.LANCHOR0+76
 3042 1a18 0C030000 		.word	.LC19
 3043 1a1c 38030000 		.word	.LC20
 3044 1a20 70020000 		.word	.LC16
 3045 1a24 00000000 		.word	.LANCHOR2
 3046              		.cfi_endproc
 3047              	.LFE2:
 3049              		.align	2
 3050              		.global	CTControlHandle
 3052              	CTControlHandle:
 3053              	.LFB3:
 872:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3054              		.loc 1 872 0
 3055              		.cfi_startproc
 3056              		@ args = 0, pretend = 0, frame = 64
 3057              		@ frame_needed = 0, uses_anonymous_args = 0
 3058              	.LVL254:
 3059 1a28 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3060              	.LCFI15:
 3061              		.cfi_def_cfa_offset 36
 891:../uvc.c      ****     reqData = bRequest;
 3062              		.loc 1 891 0
 3063 1a2c 60A99FE5 		ldr	sl, .L308
 3064              		.cfi_offset 14, -4
 3065              		.cfi_offset 11, -8
 3066              		.cfi_offset 10, -12
 3067              		.cfi_offset 9, -16
 3068              		.cfi_offset 8, -20
 3069              		.cfi_offset 7, -24
 3070              		.cfi_offset 6, -28
 3071              		.cfi_offset 5, -32
 3072              		.cfi_offset 4, -36
 883:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3073              		.loc 1 883 0
 3074 1a30 60899FE5 		ldr	r8, .L308+4
 891:../uvc.c      ****     reqData = bRequest;
 3075              		.loc 1 891 0
 3076 1a34 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 883:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3077              		.loc 1 883 0
 3078 1a38 8090A0E1 		mov	r9, r0, asl #1
 3079 1a3c 002089E0 		add	r2, r9, r0
 3080 1a40 822188E0 		add	r2, r8, r2, asl #3
 893:../uvc.c      ****     switch (bRequest)
 3081              		.loc 1 893 0
 3082 1a44 830055E3 		cmp	r5, #131
 872:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3083              		.loc 1 872 0
 3084 1a48 5CD04DE2 		sub	sp, sp, #92
 3085              	.LCFI16:
 3086              		.cfi_def_cfa_offset 128
 872:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3087              		.loc 1 872 0
 3088 1a4c 0060A0E1 		mov	r6, r0
 883:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3089              		.loc 1 883 0
 3090 1a50 9F34D2E5 		ldrb	r3, [r2, #1183]	@ zero_extendqisi2
 3091              	.LVL255:
 884:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3092              		.loc 1 884 0
 3093 1a54 90B4D2E5 		ldrb	fp, [r2, #1168]	@ zero_extendqisi2
 3094              	.LVL256:
 886:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3095              		.loc 1 886 0
 3096 1a58 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3097              	.LVL257:
 893:../uvc.c      ****     switch (bRequest)
 3098              		.loc 1 893 0
 3099 1a5c 7600000A 		beq	.L228
 3100 1a60 2100009A 		bls	.L303
 3101 1a64 850055E3 		cmp	r5, #133
 3102 1a68 5900000A 		beq	.L230
 3103 1a6c 4E00003A 		bcc	.L229
 3104 1a70 860055E3 		cmp	r5, #134
 3105 1a74 8000000A 		beq	.L231
 3106 1a78 870055E3 		cmp	r5, #135
 3107 1a7c 7600000A 		beq	.L304
 3108              	.L224:
1100:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3109              		.loc 1 1100 0
 3110 1a80 0000A0E3 		mov	r0, #0
 3111              	.LVL258:
 3112 1a84 0110A0E3 		mov	r1, #1
 3113 1a88 0020A0E1 		mov	r2, r0
 3114 1a8c FEFFFFEB 		bl	CyU3PUsbStall
 3115              	.LVL259:
 3116 1a90 04499FE5 		ldr	r4, .L308+8
1101:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3117              		.loc 1 1101 0
 3118 1a94 0620A0E1 		mov	r2, r6
 3119 1a98 0400A0E3 		mov	r0, #4
 3120 1a9c FC189FE5 		ldr	r1, .L308+12
 3121 1aa0 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3122 1aa4 FEFFFFEB 		bl	CyU3PDebugPrint
1102:../uvc.c      **** 			  break;
 3123              		.loc 1 1102 0
 3124 1aa8 FFC0A0E3 		mov	ip, #255
 3125 1aac 0C60A0E1 		mov	r6, ip
 3126 1ab0 0C80A0E1 		mov	r8, ip
 3127              	.LVL260:
 3128              	.L234:
1106:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3129              		.loc 1 1106 0
 3130 1ab4 5AE0D4E5 		ldrb	lr, [r4, #90]	@ zero_extendqisi2
 3131 1ab8 08C08DE5 		str	ip, [sp, #8]
 3132 1abc E0189FE5 		ldr	r1, .L308+16
 3133 1ac0 FFC0A0E3 		mov	ip, #255
 3134 1ac4 0520A0E1 		mov	r2, r5
 3135 1ac8 0830A0E1 		mov	r3, r8
 3136 1acc 0400A0E3 		mov	r0, #4
 3137 1ad0 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3138 1ad4 0CC08DE5 		str	ip, [sp, #12]
 3139 1ad8 10E08DE5 		str	lr, [sp, #16]
 3140 1adc 14708DE5 		str	r7, [sp, #20]
 3141 1ae0 FEFFFFEB 		bl	CyU3PDebugPrint
1107:../uvc.c      **** }
 3142              		.loc 1 1107 0
 3143 1ae4 5CD08DE2 		add	sp, sp, #92
 3144 1ae8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3145              	.LVL261:
 3146              	.L303:
 893:../uvc.c      ****     switch (bRequest)
 3147              		.loc 1 893 0
 3148 1aec 810055E3 		cmp	r5, #129
 3149 1af0 4200000A 		beq	.L226
 3150 1af4 1100009A 		bls	.L305
 922:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3151              		.loc 1 922 0
 3152 1af8 9C489FE5 		ldr	r4, .L308+8
 3153 1afc 9314D2E5 		ldrb	r1, [r2, #1171]	@ zero_extendqisi2
 923:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3154              		.loc 1 923 0
 3155 1b00 9464D2E5 		ldrb	r6, [r2, #1172]	@ zero_extendqisi2
 924:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3156              		.loc 1 924 0
 3157 1b04 0A0050E3 		cmp	r0, #10
 922:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3158              		.loc 1 922 0
 3159 1b08 5810C4E5 		strb	r1, [r4, #88]
 923:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3160              		.loc 1 923 0
 3161 1b0c 5960C4E5 		strb	r6, [r4, #89]
 924:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3162              		.loc 1 924 0
 3163 1b10 2C00000A 		beq	.L302
 3164              	.LVL262:
 3165              	.L241:
 958:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3166              		.loc 1 958 0
 3167 1b14 00E0A0E3 		mov	lr, #0
 3168 1b18 5AE0C4E5 		strb	lr, [r4, #90]
 3169              	.L242:
 959:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3170              		.loc 1 959 0
 3171 1b1c 0030A0E3 		mov	r3, #0
 960:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3172              		.loc 1 960 0
 3173 1b20 0700A0E1 		mov	r0, r7
 3174              	.LVL263:
 3175 1b24 7C189FE5 		ldr	r1, .L308+20
 962:../uvc.c      **** 			  break;
 3176              		.loc 1 962 0
 3177 1b28 FF60A0E3 		mov	r6, #255
 959:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3178              		.loc 1 959 0
 3179 1b2c 5B30C4E5 		strb	r3, [r4, #91]
 962:../uvc.c      **** 			  break;
 3180              		.loc 1 962 0
 3181 1b30 0680A0E1 		mov	r8, r6
 960:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3182              		.loc 1 960 0
 3183 1b34 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3184              	.LVL264:
 3185 1b38 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 962:../uvc.c      **** 			  break;
 3186              		.loc 1 962 0
 3187 1b3c DCFFFFEA 		b	.L234
 3188              	.LVL265:
 3189              	.L305:
 893:../uvc.c      ****     switch (bRequest)
 3190              		.loc 1 893 0
 3191 1b40 010055E3 		cmp	r5, #1
 3192 1b44 CDFFFF1A 		bne	.L224
 964:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3193              		.loc 1 964 0
 3194 1b48 4C489FE5 		ldr	r4, .L308+8
 3195 1b4c 56208DE2 		add	r2, sp, #86
 3196 1b50 2000A0E3 		mov	r0, #32
 3197              	.LVL266:
 3198 1b54 581084E2 		add	r1, r4, #88
 3199 1b58 2C308DE5 		str	r3, [sp, #44]
 3200 1b5c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3201              	.LVL267:
 966:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3202              		.loc 1 966 0
 3203 1b60 5800D4E5 		ldrb	r0, [r4, #88]	@ zero_extendqisi2
 967:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3204              		.loc 1 967 0
 3205 1b64 59C0D4E5 		ldrb	ip, [r4, #89]	@ zero_extendqisi2
 970:../uvc.c      **** 			  switch(CtrlID)
 3206              		.loc 1 970 0
 3207 1b68 012046E2 		sub	r2, r6, #1
 966:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3208              		.loc 1 966 0
 3209 1b6c 30008DE5 		str	r0, [sp, #48]
 3210              	.LVL268:
 967:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3211              		.loc 1 967 0
 3212 1b70 34C08DE5 		str	ip, [sp, #52]
 3213              	.LVL269:
 970:../uvc.c      **** 			  switch(CtrlID)
 3214              		.loc 1 970 0
 3215 1b74 2C309DE5 		ldr	r3, [sp, #44]
 3216 1b78 090052E3 		cmp	r2, #9
 3217 1b7c 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3218 1b80 550100EA 		b	.L243
 3219              	.L248:
 3220 1b84 98200000 		.word	.L244
 3221 1b88 DC200000 		.word	.L243
 3222 1b8c A81D0000 		.word	.L245
 3223 1b90 DC200000 		.word	.L243
 3224 1b94 DC200000 		.word	.L243
 3225 1b98 DC200000 		.word	.L243
 3226 1b9c 241D0000 		.word	.L246
 3227 1ba0 DC200000 		.word	.L243
 3228 1ba4 DC200000 		.word	.L243
 3229 1ba8 A81C0000 		.word	.L247
 3230              	.LVL270:
 3231              	.L229:
 940:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3232              		.loc 1 940 0
 3233 1bac E8479FE5 		ldr	r4, .L308+8
 3234 1bb0 9784D2E5 		ldrb	r8, [r2, #1175]	@ zero_extendqisi2
 941:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3235              		.loc 1 941 0
 3236 1bb4 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 942:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3237              		.loc 1 942 0
 3238 1bb8 0A0050E3 		cmp	r0, #10
 940:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3239              		.loc 1 940 0
 3240 1bbc 5880C4E5 		strb	r8, [r4, #88]
 941:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3241              		.loc 1 941 0
 3242 1bc0 5920C4E5 		strb	r2, [r4, #89]
 942:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3243              		.loc 1 942 0
 3244 1bc4 D2FFFF1A 		bne	.L241
 3245              	.LVL271:
 3246              	.L302:
 957:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3247              		.loc 1 957 0 discriminator 1
 3248 1bc8 0110A0E3 		mov	r1, #1
 3249 1bcc 5A10C4E5 		strb	r1, [r4, #90]
 3250 1bd0 D1FFFFEA 		b	.L242
 3251              	.LVL272:
 3252              	.L230:
 897:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3253              		.loc 1 897 0
 3254 1bd4 C0479FE5 		ldr	r4, .L308+8
 898:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3255              		.loc 1 898 0
 3256 1bd8 0030A0E3 		mov	r3, #0
 3257              	.LVL273:
 899:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3258              		.loc 1 899 0
 3259 1bdc 0200A0E3 		mov	r0, #2
 3260              	.LVL274:
 3261 1be0 581084E2 		add	r1, r4, #88
 901:../uvc.c      **** 			  break;
 3262              		.loc 1 901 0
 3263 1be4 FF60A0E3 		mov	r6, #255
 897:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3264              		.loc 1 897 0
 3265 1be8 5870C4E5 		strb	r7, [r4, #88]
 898:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3266              		.loc 1 898 0
 3267 1bec 5930C4E5 		strb	r3, [r4, #89]
 901:../uvc.c      **** 			  break;
 3268              		.loc 1 901 0
 3269 1bf0 0680A0E1 		mov	r8, r6
 899:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3270              		.loc 1 899 0
 3271 1bf4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3272              	.LVL275:
 3273 1bf8 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 901:../uvc.c      **** 			  break;
 3274              		.loc 1 901 0
 3275 1bfc ACFFFFEA 		b	.L234
 3276              	.LVL276:
 3277              	.L226:
 907:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3278              		.loc 1 907 0
 3279 1c00 94479FE5 		ldr	r4, .L308+8
 3280 1c04 9DA4D2E5 		ldrb	sl, [r2, #1181]	@ zero_extendqisi2
 908:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3281              		.loc 1 908 0
 3282 1c08 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
 909:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3283              		.loc 1 909 0
 3284 1c0c 0080A0E3 		mov	r8, #0
 915:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3285              		.loc 1 915 0
 3286 1c10 0700A0E1 		mov	r0, r7
 3287              	.LVL277:
 3288 1c14 581084E2 		add	r1, r4, #88
 920:../uvc.c      **** 			  break;
 3289              		.loc 1 920 0
 3290 1c18 FF60A0E3 		mov	r6, #255
 908:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3291              		.loc 1 908 0
 3292 1c1c 59C0C4E5 		strb	ip, [r4, #89]
 909:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3293              		.loc 1 909 0
 3294 1c20 5A80C4E5 		strb	r8, [r4, #90]
 910:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3295              		.loc 1 910 0
 3296 1c24 5B80C4E5 		strb	r8, [r4, #91]
 3297              	.LVL278:
 907:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3298              		.loc 1 907 0
 3299 1c28 58A0C4E5 		strb	sl, [r4, #88]
 920:../uvc.c      **** 			  break;
 3300              		.loc 1 920 0
 3301 1c2c 0680A0E1 		mov	r8, r6
 915:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3302              		.loc 1 915 0
 3303 1c30 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3304              	.LVL279:
 3305 1c34 0AC0A0E1 		mov	ip, sl
 920:../uvc.c      **** 			  break;
 3306              		.loc 1 920 0
 3307 1c38 9DFFFFEA 		b	.L234
 3308              	.LVL280:
 3309              	.L228:
 931:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3310              		.loc 1 931 0
 3311 1c3c 58479FE5 		ldr	r4, .L308+8
 3312 1c40 9534D2E5 		ldrb	r3, [r2, #1173]	@ zero_extendqisi2
 3313              	.LVL281:
 932:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3314              		.loc 1 932 0
 3315 1c44 96E4D2E5 		ldrb	lr, [r2, #1174]	@ zero_extendqisi2
 933:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3316              		.loc 1 933 0
 3317 1c48 0A0050E3 		cmp	r0, #10
 931:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3318              		.loc 1 931 0
 3319 1c4c 5830C4E5 		strb	r3, [r4, #88]
 932:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3320              		.loc 1 932 0
 3321 1c50 59E0C4E5 		strb	lr, [r4, #89]
 933:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3322              		.loc 1 933 0
 3323 1c54 AEFFFF1A 		bne	.L241
 3324 1c58 DAFFFFEA 		b	.L302
 3325              	.LVL282:
 3326              	.L304:
 955:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3327              		.loc 1 955 0
 3328 1c5c 38479FE5 		ldr	r4, .L308+8
 3329 1c60 9B64D2E5 		ldrb	r6, [r2, #1179]	@ zero_extendqisi2
 956:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3330              		.loc 1 956 0
 3331 1c64 9CC4D2E5 		ldrb	ip, [r2, #1180]	@ zero_extendqisi2
 957:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3332              		.loc 1 957 0
 3333 1c68 0A0050E3 		cmp	r0, #10
 955:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3334              		.loc 1 955 0
 3335 1c6c 5860C4E5 		strb	r6, [r4, #88]
 956:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3336              		.loc 1 956 0
 3337 1c70 59C0C4E5 		strb	ip, [r4, #89]
 957:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3338              		.loc 1 957 0
 3339 1c74 A6FFFF1A 		bne	.L241
 3340 1c78 D2FFFFEA 		b	.L302
 3341              	.L231:
 949:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3342              		.loc 1 949 0
 3343 1c7c 18479FE5 		ldr	r4, .L308+8
 3344 1c80 9904D2E5 		ldrb	r0, [r2, #1177]	@ zero_extendqisi2
 3345              	.LVL283:
 3346 1c84 0410A0E1 		mov	r1, r4
 3347 1c88 5800E1E5 		strb	r0, [r1, #88]!
 953:../uvc.c      **** 			  break;
 3348              		.loc 1 953 0
 3349 1c8c FF60A0E3 		mov	r6, #255
 950:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3350              		.loc 1 950 0
 3351 1c90 0100A0E3 		mov	r0, #1
 3352 1c94 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3353              	.LVL284:
 953:../uvc.c      **** 			  break;
 3354              		.loc 1 953 0
 3355 1c98 0680A0E1 		mov	r8, r6
 950:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3356              		.loc 1 950 0
 3357 1c9c 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 953:../uvc.c      **** 			  break;
 3358              		.loc 1 953 0
 3359 1ca0 0170A0E3 		mov	r7, #1
 3360 1ca4 82FFFFEA 		b	.L234
 3361              	.LVL285:
 3362              	.L247:
1079:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3363              		.loc 1 1079 0
 3364 1ca8 FC669FE5 		ldr	r6, .L308+24
 3365 1cac 0010E0E3 		mvn	r1, #0
 3366 1cb0 1C0096E5 		ldr	r0, [r6, #28]
 3367 1cb4 2C308DE5 		str	r3, [sp, #44]
 3368 1cb8 FEFFFFEB 		bl	_txe_mutex_get
1080:../uvc.c      **** 					  if(getData == 1)
 3369              		.loc 1 1080 0
 3370 1cbc 30E09DE5 		ldr	lr, [sp, #48]
 3371 1cc0 2C309DE5 		ldr	r3, [sp, #44]
 3372 1cc4 01005EE3 		cmp	lr, #1
 3373 1cc8 A901000A 		beq	.L306
1082:../uvc.c      **** 					  else if(getData == 0xff)
 3374              		.loc 1 1082 0
 3375 1ccc FF005EE3 		cmp	lr, #255
 3376 1cd0 9E01000A 		beq	.L307
1085:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
 3377              		.loc 1 1085 0
 3378 1cd4 0080A0E3 		mov	r8, #0
 3379 1cd8 0600A0E1 		mov	r0, r6
 3380 1cdc 1710A0E3 		mov	r1, #23
 3381 1ce0 0B20A0E1 		mov	r2, fp
 3382 1ce4 00808DE5 		str	r8, [sp, #0]
 3383 1ce8 04808DE5 		str	r8, [sp, #4]
 3384 1cec FEFFFFEB 		bl	cmdSet
 3385              	.L300:
1088:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3386              		.loc 1 1088 0
 3387 1cf0 1C0096E5 		ldr	r0, [r6, #28]
 3388 1cf4 FEFFFFEB 		bl	_txe_mutex_put
1090:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3389              		.loc 1 1090 0
 3390 1cf8 30809DE5 		ldr	r8, [sp, #48]
 3391 1cfc 34609DE5 		ldr	r6, [sp, #52]
 3392 1d00 5AC0D4E5 		ldrb	ip, [r4, #90]	@ zero_extendqisi2
 3393 1d04 0400A0E3 		mov	r0, #4
 3394 1d08 A0169FE5 		ldr	r1, .L308+28
 3395 1d0c 0820A0E1 		mov	r2, r8
 3396 1d10 0630A0E1 		mov	r3, r6
 3397 1d14 00C08DE5 		str	ip, [sp, #0]
 3398 1d18 FEFFFFEB 		bl	CyU3PDebugPrint
1091:../uvc.c      **** 					  break;
 3399              		.loc 1 1091 0
 3400 1d1c FFC0A0E3 		mov	ip, #255
 3401 1d20 63FFFFEA 		b	.L234
 3402              	.LVL286:
 3403              	.L246:
1056:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3404              		.loc 1 1056 0
 3405 1d24 B584D8E5 		ldrb	r8, [r8, #1205]	@ zero_extendqisi2
 3406 1d28 010058E3 		cmp	r8, #1
 3407 1d2c 08005813 		cmpne	r8, #8
 3408 1d30 0000A013 		movne	r0, #0
 3409 1d34 0100A003 		moveq	r0, #1
 3410 1d38 8001001A 		bne	.L297
 3411              	.LVL287:
1059:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3412              		.loc 1 1059 0
 3413 1d3c 68869FE5 		ldr	r8, .L308+24
 3414 1d40 0010E0E3 		mvn	r1, #0
 3415 1d44 1C0098E5 		ldr	r0, [r8, #28]
 3416 1d48 2C308DE5 		str	r3, [sp, #44]
 3417 1d4c FEFFFFEB 		bl	_txe_mutex_get
1060:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3418              		.loc 1 1060 0
 3419 1d50 30A09DE5 		ldr	sl, [sp, #48]
 3420 1d54 1610A0E3 		mov	r1, #22
 3421 1d58 0B20A0E1 		mov	r2, fp
 3422 1d5c 2C309DE5 		ldr	r3, [sp, #44]
 3423 1d60 00C0A0E3 		mov	ip, #0
 3424 1d64 0800A0E1 		mov	r0, r8
 3425 1d68 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3426 1d6c FEFFFFEB 		bl	cmdSet
1061:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3427              		.loc 1 1061 0
 3428 1d70 1C0098E5 		ldr	r0, [r8, #28]
 3429 1d74 FEFFFFEB 		bl	_txe_mutex_put
1064:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3430              		.loc 1 1064 0
 3431 1d78 18069FE5 		ldr	r0, .L308+4
1065:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3432              		.loc 1 1065 0
 3433 1d7c 34209DE5 		ldr	r2, [sp, #52]
1064:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3434              		.loc 1 1064 0
 3435 1d80 061089E0 		add	r1, r9, r6
 3436 1d84 813180E0 		add	r3, r0, r1, asl #3
1066:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3437              		.loc 1 1066 0
 3438 1d88 0160A0E3 		mov	r6, #1
1064:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3439              		.loc 1 1064 0
 3440 1d8c 9DA4C3E5 		strb	sl, [r3, #1181]
1065:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3441              		.loc 1 1065 0
 3442 1d90 9E24C3E5 		strb	r2, [r3, #1182]
1066:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3443              		.loc 1 1066 0
 3444 1d94 A064C3E5 		strb	r6, [r3, #1184]
 3445              	.LVL288:
 3446              	.L298:
1068:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3447              		.loc 1 1068 0
 3448 1d98 5880D4E5 		ldrb	r8, [r4, #88]	@ zero_extendqisi2
 3449 1d9c 5960D4E5 		ldrb	r6, [r4, #89]	@ zero_extendqisi2
1073:../uvc.c      **** 					  break;
 3450              		.loc 1 1073 0
 3451 1da0 FFC0A0E3 		mov	ip, #255
 3452 1da4 42FFFFEA 		b	.L234
 3453              	.LVL289:
 3454              	.L245:
1022:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3455              		.loc 1 1022 0
 3456 1da8 B504D8E5 		ldrb	r0, [r8, #1205]	@ zero_extendqisi2
 3457 1dac 010050E3 		cmp	r0, #1
 3458 1db0 04005013 		cmpne	r0, #4
 3459 1db4 5C01001A 		bne	.L255
1021:../uvc.c      **** 					  value = (value << 8)|Data0;
 3460              		.loc 1 1021 0
 3461 1db8 30109DE5 		ldr	r1, [sp, #48]
 3462 1dbc 34E09DE5 		ldr	lr, [sp, #52]
 3463 1dc0 0E2481E1 		orr	r2, r1, lr, asl #8
1023:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3464              		.loc 1 1023 0
 3465 1dc4 F90052E3 		cmp	r2, #249
 3466 1dc8 5701008A 		bhi	.L255
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3467              		.loc 1 1028 0
 3468 1dcc C8A042E2 		sub	sl, r2, #200
 3469 1dd0 0AC8A0E1 		mov	ip, sl, asl #16
 3470 1dd4 3CC08DE5 		str	ip, [sp, #60]
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3471              		.loc 1 1030 0
 3472 1dd8 27A062E2 		rsb	sl, r2, #39
 3473 1ddc 38A08DE5 		str	sl, [sp, #56]
 3474 1de0 3CA09DE5 		ldr	sl, [sp, #60]
 3475 1de4 C81062E2 		rsb	r1, r2, #200
 3476 1de8 C80052E3 		cmp	r2, #200
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3477              		.loc 1 1028 0
 3478 1dec 640042E2 		sub	r0, r2, #100
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3479              		.loc 1 1030 0
 3480 1df0 0118A0E1 		mov	r1, r1, asl #16
 3481 1df4 64E062E2 		rsb	lr, r2, #100
 3482 1df8 2A18A081 		movhi	r1, sl, lsr #16
 3483 1dfc 2118A091 		movls	r1, r1, lsr #16
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3484              		.loc 1 1028 0
 3485 1e00 00C8A0E1 		mov	ip, r0, asl #16
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3486              		.loc 1 1030 0
 3487 1e04 640052E3 		cmp	r2, #100
 3488 1e08 0E08A0E1 		mov	r0, lr, asl #16
 3489 1e0c 2C08A081 		movhi	r0, ip, lsr #16
 3490 1e10 38C09DE5 		ldr	ip, [sp, #56]
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3491              		.loc 1 1028 0
 3492 1e14 14A042E2 		sub	sl, r2, #20
 3493 1e18 38A08DE5 		str	sl, [sp, #56]
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3494              		.loc 1 1030 0
 3495 1e1c 2008A091 		movls	r0, r0, lsr #16
 3496 1e20 14A062E2 		rsb	sl, r2, #20
 3497 1e24 3CA08DE5 		str	sl, [sp, #60]
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3498              		.loc 1 1028 0
 3499 1e28 27E042E2 		sub	lr, r2, #39
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3500              		.loc 1 1030 0
 3501 1e2c 000051E1 		cmp	r1, r0
 3502 1e30 01A0A031 		movcc	sl, r1
 3503 1e34 00A0A021 		movcs	sl, r0
 3504 1e38 0CC8A0E1 		mov	ip, ip, asl #16
 3505 1e3c 270052E3 		cmp	r2, #39
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3506              		.loc 1 1028 0
 3507 1e40 0EE8A0E1 		mov	lr, lr, asl #16
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3508              		.loc 1 1030 0
 3509 1e44 2CE8A091 		movls	lr, ip, lsr #16
 3510 1e48 64C59FE5 		ldr	ip, .L308+32
 3511 1e4c 20A08DE5 		str	sl, [sp, #32]
 3512 1e50 01A06CE0 		rsb	sl, ip, r1
 3513 1e54 2EE8A081 		movhi	lr, lr, lsr #16
 3514 1e58 00C07AE2 		rsbs	ip, sl, #0
 3515 1e5c 0AC0ACE0 		adc	ip, ip, sl
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3516              		.loc 1 1028 0
 3517 1e60 38A09DE5 		ldr	sl, [sp, #56]
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3518              		.loc 1 1030 0
 3519 1e64 44C08DE5 		str	ip, [sp, #68]
 3520              	.LVL290:
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3521              		.loc 1 1028 0
 3522 1e68 0AC8A0E1 		mov	ip, sl, asl #16
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3523              		.loc 1 1030 0
 3524 1e6c 3CA09DE5 		ldr	sl, [sp, #60]
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3525              		.loc 1 1028 0
 3526 1e70 4CC08DE5 		str	ip, [sp, #76]
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3527              		.loc 1 1030 0
 3528 1e74 0AC8A0E1 		mov	ip, sl, asl #16
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3529              		.loc 1 1028 0
 3530 1e78 0AA042E2 		sub	sl, r2, #10
 3531 1e7c 48A08DE5 		str	sl, [sp, #72]
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3532              		.loc 1 1030 0
 3533 1e80 20A09DE5 		ldr	sl, [sp, #32]
 3534 1e84 3CC08DE5 		str	ip, [sp, #60]
 3535 1e88 0A005EE1 		cmp	lr, sl
 3536 1e8c 0EA0A031 		movcc	sl, lr
 3537 1e90 0AC062E2 		rsb	ip, r2, #10
 3538 1e94 40C08DE5 		str	ip, [sp, #64]
 3539 1e98 38A08DE5 		str	sl, [sp, #56]
 3540 1e9c 3CC09DE5 		ldr	ip, [sp, #60]
 3541 1ea0 4CA09DE5 		ldr	sl, [sp, #76]
 3542 1ea4 140052E3 		cmp	r2, #20
 3543 1ea8 2CA8A091 		movls	sl, ip, lsr #16
 3544 1eac 2AA8A081 		movhi	sl, sl, lsr #16
 3545 1eb0 44C09DE5 		ldr	ip, [sp, #68]
 3546 1eb4 010050E1 		cmp	r0, r1
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3547              		.loc 1 1028 0
 3548 1eb8 48109DE5 		ldr	r1, [sp, #72]
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3549              		.loc 1 1030 0
 3550 1ebc 01C0A033 		movcc	ip, #1
 3551 1ec0 3CA08DE5 		str	sl, [sp, #60]
 3552 1ec4 24C08DE5 		str	ip, [sp, #36]
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3553              		.loc 1 1028 0
 3554 1ec8 01A8A0E1 		mov	sl, r1, asl #16
 3555 1ecc 05C042E2 		sub	ip, r2, #5
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3556              		.loc 1 1030 0
 3557 1ed0 051062E2 		rsb	r1, r2, #5
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3558              		.loc 1 1028 0
 3559 1ed4 48A08DE5 		str	sl, [sp, #72]
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3560              		.loc 1 1030 0
 3561 1ed8 40009DE5 		ldr	r0, [sp, #64]
 3562 1edc 38A09DE5 		ldr	sl, [sp, #56]
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3563              		.loc 1 1028 0
 3564 1ee0 40C08DE5 		str	ip, [sp, #64]
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3565              		.loc 1 1030 0
 3566 1ee4 3CC09DE5 		ldr	ip, [sp, #60]
 3567 1ee8 4C108DE5 		str	r1, [sp, #76]
 3568 1eec 48109DE5 		ldr	r1, [sp, #72]
 3569 1ef0 0008A0E1 		mov	r0, r0, asl #16
 3570 1ef4 0A005CE1 		cmp	ip, sl
 3571 1ef8 0AC0A021 		movcs	ip, sl
 3572 1efc 0A0052E3 		cmp	r2, #10
 3573 1f00 20A09DE5 		ldr	sl, [sp, #32]
 3574 1f04 2108A081 		movhi	r0, r1, lsr #16
 3575 1f08 2008A091 		movls	r0, r0, lsr #16
 3576 1f0c 48008DE5 		str	r0, [sp, #72]
 3577 1f10 24009DE5 		ldr	r0, [sp, #36]
 3578 1f14 0A005EE1 		cmp	lr, sl
 3579 1f18 0200A033 		movcc	r0, #2
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3580              		.loc 1 1028 0
 3581 1f1c 02E042E2 		sub	lr, r2, #2
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3582              		.loc 1 1030 0
 3583 1f20 44C08DE5 		str	ip, [sp, #68]
 3584 1f24 24008DE5 		str	r0, [sp, #36]
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3585              		.loc 1 1028 0
 3586 1f28 40C09DE5 		ldr	ip, [sp, #64]
 3587 1f2c 1CE08DE5 		str	lr, [sp, #28]
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3588              		.loc 1 1030 0
 3589 1f30 44009DE5 		ldr	r0, [sp, #68]
 3590 1f34 48E09DE5 		ldr	lr, [sp, #72]
 3591 1f38 4C109DE5 		ldr	r1, [sp, #76]
 3592 1f3c 02A062E2 		rsb	sl, r2, #2
 3593 1f40 00005EE1 		cmp	lr, r0
 3594 1f44 00E0A021 		movcs	lr, r0
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3595              		.loc 1 1028 0
 3596 1f48 0CC8A0E1 		mov	ip, ip, asl #16
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3597              		.loc 1 1030 0
 3598 1f4c 050052E3 		cmp	r2, #5
 3599 1f50 40A08DE5 		str	sl, [sp, #64]
 3600 1f54 0118A0E1 		mov	r1, r1, asl #16
 3601 1f58 3CA09DE5 		ldr	sl, [sp, #60]
 3602 1f5c 2C18A081 		movhi	r1, ip, lsr #16
 3603 1f60 38C09DE5 		ldr	ip, [sp, #56]
 3604 1f64 4CE08DE5 		str	lr, [sp, #76]
 3605 1f68 24009DE5 		ldr	r0, [sp, #36]
 3606 1f6c 40E09DE5 		ldr	lr, [sp, #64]
 3607 1f70 2118A091 		movls	r1, r1, lsr #16
 3608 1f74 0C005AE1 		cmp	sl, ip
 3609 1f78 20108DE5 		str	r1, [sp, #32]
 3610 1f7c 0300A033 		movcc	r0, #3
 3611 1f80 38008DE5 		str	r0, [sp, #56]
 3612 1f84 4CA09DE5 		ldr	sl, [sp, #76]
 3613 1f88 0E08A0E1 		mov	r0, lr, asl #16
 3614 1f8c 20E09DE5 		ldr	lr, [sp, #32]
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3615              		.loc 1 1028 0
 3616 1f90 1C109DE5 		ldr	r1, [sp, #28]
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3617              		.loc 1 1030 0
 3618 1f94 0A005EE1 		cmp	lr, sl
 3619 1f98 0AE0A021 		movcs	lr, sl
 3620 1f9c 44C09DE5 		ldr	ip, [sp, #68]
 3621 1fa0 48A09DE5 		ldr	sl, [sp, #72]
 3622 1fa4 020052E3 		cmp	r2, #2
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3623              		.loc 1 1028 0
 3624 1fa8 0118A0E1 		mov	r1, r1, asl #16
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3625              		.loc 1 1030 0
 3626 1fac 2018A091 		movls	r1, r0, lsr #16
 3627 1fb0 38009DE5 		ldr	r0, [sp, #56]
 3628 1fb4 2118A081 		movhi	r1, r1, lsr #16
 3629 1fb8 0C005AE1 		cmp	sl, ip
 3630 1fbc 0400A033 		movcc	r0, #4
 3631 1fc0 40008DE5 		str	r0, [sp, #64]
1028:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3632              		.loc 1 1028 0
 3633 1fc4 010042E2 		sub	r0, r2, #1
 3634 1fc8 38008DE5 		str	r0, [sp, #56]
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3635              		.loc 1 1030 0
 3636 1fcc 4CA09DE5 		ldr	sl, [sp, #76]
 3637 1fd0 20009DE5 		ldr	r0, [sp, #32]
 3638 1fd4 01C062E2 		rsb	ip, r2, #1
 3639 1fd8 3CC08DE5 		str	ip, [sp, #60]
 3640 1fdc 0A0050E1 		cmp	r0, sl
1037:../uvc.c      **** 						  shutter = shutter+index;
 3641              		.loc 1 1037 0
 3642 1fe0 38A09DE5 		ldr	sl, [sp, #56]
 3643 1fe4 3C009DE5 		ldr	r0, [sp, #60]
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3644              		.loc 1 1030 0
 3645 1fe8 40C09DE5 		ldr	ip, [sp, #64]
 3646 1fec 05C0A033 		movcc	ip, #5
1037:../uvc.c      **** 						  shutter = shutter+index;
 3647              		.loc 1 1037 0
 3648 1ff0 010052E3 		cmp	r2, #1
 3649 1ff4 0028A091 		movls	r2, r0, asl #16
 3650 1ff8 0A28A081 		movhi	r2, sl, asl #16
 3651 1ffc 0E0051E1 		cmp	r1, lr
 3652 2000 01A0A031 		movcc	sl, r1
 3653 2004 0EA0A021 		movcs	sl, lr
1030:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3654              		.loc 1 1030 0
 3655 2008 0E0051E1 		cmp	r1, lr
 3656 200c 0C10A021 		movcs	r1, ip
 3657 2010 0610A033 		movcc	r1, #6
1037:../uvc.c      **** 						  shutter = shutter+index;
 3658              		.loc 1 1037 0
 3659 2014 22085AE1 		cmp	sl, r2, lsr #16
1040:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3660              		.loc 1 1040 0
 3661 2018 8CA39FE5 		ldr	sl, .L308+24
1037:../uvc.c      **** 						  shutter = shutter+index;
 3662              		.loc 1 1037 0
 3663 201c 0120A091 		movls	r2, r1
 3664 2020 0720A083 		movhi	r2, #7
 3665 2024 012082E2 		add	r2, r2, #1
 3666 2028 FFE002E2 		and	lr, r2, #255
1040:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3667              		.loc 1 1040 0
 3668 202c 0010E0E3 		mvn	r1, #0
 3669 2030 1C009AE5 		ldr	r0, [sl, #28]
1037:../uvc.c      **** 						  shutter = shutter+index;
 3670              		.loc 1 1037 0
 3671 2034 38E08DE5 		str	lr, [sp, #56]
 3672              	.LVL291:
1040:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3673              		.loc 1 1040 0
 3674 2038 2C308DE5 		str	r3, [sp, #44]
 3675 203c FEFFFFEB 		bl	_txe_mutex_get
1041:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3676              		.loc 1 1041 0
 3677 2040 38C09DE5 		ldr	ip, [sp, #56]
 3678 2044 0310A0E3 		mov	r1, #3
 3679 2048 0B20A0E1 		mov	r2, fp
 3680 204c 2C309DE5 		ldr	r3, [sp, #44]
 3681 2050 00C08DE5 		str	ip, [sp, #0]
 3682 2054 0A00A0E1 		mov	r0, sl
 3683 2058 00C0A0E3 		mov	ip, #0
 3684 205c 04C08DE5 		str	ip, [sp, #4]
 3685 2060 FEFFFFEB 		bl	cmdSet
1042:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3686              		.loc 1 1042 0
 3687 2064 1C009AE5 		ldr	r0, [sl, #28]
 3688 2068 FEFFFFEB 		bl	_txe_mutex_put
1045:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3689              		.loc 1 1045 0
 3690 206c 30009DE5 		ldr	r0, [sp, #48]
1046:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3691              		.loc 1 1046 0
 3692 2070 34C09DE5 		ldr	ip, [sp, #52]
1048:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3693              		.loc 1 1048 0
 3694 2074 38309DE5 		ldr	r3, [sp, #56]
1045:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3695              		.loc 1 1045 0
 3696 2078 061089E0 		add	r1, r9, r6
 3697 207c 816188E0 		add	r6, r8, r1, asl #3
1047:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3698              		.loc 1 1047 0
 3699 2080 0120A0E3 		mov	r2, #1
1045:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3700              		.loc 1 1045 0
 3701 2084 9D04C6E5 		strb	r0, [r6, #1181]
1046:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3702              		.loc 1 1046 0
 3703 2088 9EC4C6E5 		strb	ip, [r6, #1182]
1047:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3704              		.loc 1 1047 0
 3705 208c A024C6E5 		strb	r2, [r6, #1184]
1048:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3706              		.loc 1 1048 0
 3707 2090 0D33C8E5 		strb	r3, [r8, #781]
 3708 2094 3FFFFFEA 		b	.L298
 3709              	.LVL292:
 3710              	.L244:
 975:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3711              		.loc 1 975 0
 3712 2098 062089E0 		add	r2, r9, r6
 3713 209c 826188E0 		add	r6, r8, r2, asl #3
 976:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3714              		.loc 1 976 0
 3715 20a0 0110A0E3 		mov	r1, #1
 979:../uvc.c      **** 		  		    switch (getData){
 3716              		.loc 1 979 0
 3717 20a4 01E040E2 		sub	lr, r0, #1
 975:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3718              		.loc 1 975 0
 3719 20a8 9D04C6E5 		strb	r0, [r6, #1181]
 976:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3720              		.loc 1 976 0
 3721 20ac A014C6E5 		strb	r1, [r6, #1184]
 3722              	.LVL293:
 979:../uvc.c      **** 		  		    switch (getData){
 3723              		.loc 1 979 0
 3724 20b0 07005EE3 		cmp	lr, #7
 3725 20b4 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3726 20b8 970000EA 		b	.L249
 3727              	.L254:
 3728 20bc B0220000 		.word	.L250
 3729 20c0 14220000 		.word	.L251
 3730 20c4 1C230000 		.word	.L249
 3731 20c8 B0210000 		.word	.L252
 3732 20cc 1C230000 		.word	.L249
 3733 20d0 1C230000 		.word	.L249
 3734 20d4 1C230000 		.word	.L249
 3735 20d8 10210000 		.word	.L253
 3736              	.LVL294:
 3737              	.L243:
1095:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3738              		.loc 1 1095 0
 3739 20dc 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1094:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3740              		.loc 1 1094 0
 3741 20e0 30A09DE5 		ldr	sl, [sp, #48]
 3742 20e4 069089E0 		add	r9, r9, r6
 3743 20e8 89E188E0 		add	lr, r8, r9, asl #3
1095:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3744              		.loc 1 1095 0
 3745 20ec 0620A0E1 		mov	r2, r6
 3746 20f0 0400A0E3 		mov	r0, #4
 3747 20f4 BC129FE5 		ldr	r1, .L308+36
1094:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3748              		.loc 1 1094 0
 3749 20f8 9DA4CEE5 		strb	sl, [lr, #1181]
1095:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3750              		.loc 1 1095 0
 3751 20fc FEFFFFEB 		bl	CyU3PDebugPrint
1096:../uvc.c      **** 			  		 break;
 3752              		.loc 1 1096 0
 3753 2100 FFC0A0E3 		mov	ip, #255
 3754 2104 0C60A0E1 		mov	r6, ip
 3755 2108 0C80A0E1 		mov	r8, ip
 3756 210c 68FEFFEA 		b	.L234
 3757              	.LVL295:
 3758              	.L253:
 998:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3759              		.loc 1 998 0
 3760 2110 94629FE5 		ldr	r6, .L308+24
 996:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3761              		.loc 1 996 0
 3762 2114 00A0A0E3 		mov	sl, #0
 998:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3763              		.loc 1 998 0
 3764 2118 1C0096E5 		ldr	r0, [r6, #28]
 996:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3765              		.loc 1 996 0
 3766 211c 0DA3C8E5 		strb	sl, [r8, #781]
 3767              	.LVL296:
 998:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3768              		.loc 1 998 0
 3769 2120 0010E0E3 		mvn	r1, #0
 3770 2124 2C308DE5 		str	r3, [sp, #44]
 3771 2128 FEFFFFEB 		bl	_txe_mutex_get
 999:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3772              		.loc 1 999 0
 3773 212c 0B20A0E1 		mov	r2, fp
 3774 2130 2C309DE5 		ldr	r3, [sp, #44]
 3775 2134 1010A0E3 		mov	r1, #16
 3776 2138 0600A0E1 		mov	r0, r6
 3777 213c 00A08DE5 		str	sl, [sp, #0]
 3778 2140 04A08DE5 		str	sl, [sp, #4]
 3779 2144 FEFFFFEB 		bl	cmdSet
1000:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3780              		.loc 1 1000 0
 3781 2148 1C0096E5 		ldr	r0, [r6, #28]
 3782 214c FEFFFFEB 		bl	_txe_mutex_put
 3783              	.LVL297:
 3784              	.LBB64:
 3785              	.LBB65:
 370:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3786              		.loc 1 370 0
 3787 2150 0010E0E3 		mvn	r1, #0
 3788 2154 1C0096E5 		ldr	r0, [r6, #28]
 3789 2158 FEFFFFEB 		bl	_txe_mutex_get
 371:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3790              		.loc 1 371 0
 3791 215c 0180A0E3 		mov	r8, #1
 3792 2160 1410A0E3 		mov	r1, #20
 3793 2164 2720A0E3 		mov	r2, #39
 3794 2168 3030A0E3 		mov	r3, #48
 3795 216c 0600A0E1 		mov	r0, r6
 3796 2170 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3797 2174 FEFFFFEB 		bl	cmdSet
 372:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3798              		.loc 1 372 0
 3799 2178 02C0A0E3 		mov	ip, #2
 3800 217c 1510A0E3 		mov	r1, #21
 3801 2180 2520A0E3 		mov	r2, #37
 3802 2184 3030A0E3 		mov	r3, #48
 3803 2188 0600A0E1 		mov	r0, r6
 3804 218c 00C08DE5 		str	ip, [sp, #0]
 3805 2190 04A08DE5 		str	sl, [sp, #4]
 3806 2194 FEFFFFEB 		bl	cmdSet
 373:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3807              		.loc 1 373 0
 3808 2198 1C0096E5 		ldr	r0, [r6, #28]
 3809 219c FEFFFFEB 		bl	_txe_mutex_put
 3810              	.LBE65:
 3811              	.LBE64:
1002:../uvc.c      **** 							break;
 3812              		.loc 1 1002 0
 3813 21a0 FFC0A0E3 		mov	ip, #255
 3814 21a4 0C60A0E1 		mov	r6, ip
 3815 21a8 0880A0E3 		mov	r8, #8
 3816 21ac 40FEFFEA 		b	.L234
 3817              	.LVL298:
 3818              	.L252:
 3819              	.LBB66:
 3820              	.LBB67:
 370:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3821              		.loc 1 370 0
 3822 21b0 F4819FE5 		ldr	r8, .L308+24
 3823 21b4 0010E0E3 		mvn	r1, #0
 3824 21b8 1C0098E5 		ldr	r0, [r8, #28]
 3825 21bc FEFFFFEB 		bl	_txe_mutex_get
 371:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3826              		.loc 1 371 0
 3827 21c0 0060A0E3 		mov	r6, #0
 3828 21c4 1410A0E3 		mov	r1, #20
 3829 21c8 2720A0E3 		mov	r2, #39
 3830 21cc 3030A0E3 		mov	r3, #48
 3831 21d0 0800A0E1 		mov	r0, r8
 3832 21d4 00608DE5 		str	r6, [sp, #0]
 3833 21d8 04608DE5 		str	r6, [sp, #4]
 3834 21dc FEFFFFEB 		bl	cmdSet
 372:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3835              		.loc 1 372 0
 3836 21e0 1510A0E3 		mov	r1, #21
 3837 21e4 2520A0E3 		mov	r2, #37
 3838 21e8 3030A0E3 		mov	r3, #48
 3839 21ec 0800A0E1 		mov	r0, r8
 3840 21f0 00608DE5 		str	r6, [sp, #0]
 3841 21f4 04608DE5 		str	r6, [sp, #4]
 3842 21f8 FEFFFFEB 		bl	cmdSet
 373:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3843              		.loc 1 373 0
 3844 21fc 1C0098E5 		ldr	r0, [r8, #28]
 3845 2200 FEFFFFEB 		bl	_txe_mutex_put
 3846 2204 FFC0A0E3 		mov	ip, #255
 3847 2208 0C60A0E1 		mov	r6, ip
 3848 220c 0480A0E3 		mov	r8, #4
 3849 2210 27FEFFEA 		b	.L234
 3850              	.LVL299:
 3851              	.L251:
 3852              	.LBE67:
 3853              	.LBE66:
 986:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3854              		.loc 1 986 0
 3855 2214 90A19FE5 		ldr	sl, .L308+24
 984:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3856              		.loc 1 984 0
 3857 2218 0060A0E3 		mov	r6, #0
 3858 221c 0D63C8E5 		strb	r6, [r8, #781]
 3859              	.LVL300:
 986:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3860              		.loc 1 986 0
 3861 2220 0010E0E3 		mvn	r1, #0
 3862 2224 1C009AE5 		ldr	r0, [sl, #28]
 3863 2228 2C308DE5 		str	r3, [sp, #44]
 3864 222c FEFFFFEB 		bl	_txe_mutex_get
 987:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3865              		.loc 1 987 0
 3866 2230 0B20A0E1 		mov	r2, fp
 3867 2234 2C309DE5 		ldr	r3, [sp, #44]
 3868 2238 1010A0E3 		mov	r1, #16
 3869 223c 0A00A0E1 		mov	r0, sl
 3870 2240 00608DE5 		str	r6, [sp, #0]
 3871 2244 04608DE5 		str	r6, [sp, #4]
 3872 2248 FEFFFFEB 		bl	cmdSet
 988:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3873              		.loc 1 988 0
 3874 224c 1C009AE5 		ldr	r0, [sl, #28]
 3875 2250 FEFFFFEB 		bl	_txe_mutex_put
 3876              	.LVL301:
 3877              	.LBB68:
 3878              	.LBB69:
 370:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3879              		.loc 1 370 0
 3880 2254 0010E0E3 		mvn	r1, #0
 3881 2258 1C009AE5 		ldr	r0, [sl, #28]
 3882 225c FEFFFFEB 		bl	_txe_mutex_get
 371:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3883              		.loc 1 371 0
 3884 2260 1410A0E3 		mov	r1, #20
 3885 2264 2720A0E3 		mov	r2, #39
 3886 2268 3030A0E3 		mov	r3, #48
 3887 226c 0A00A0E1 		mov	r0, sl
 3888 2270 00608DE5 		str	r6, [sp, #0]
 3889 2274 04608DE5 		str	r6, [sp, #4]
 3890 2278 FEFFFFEB 		bl	cmdSet
 372:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3891              		.loc 1 372 0
 3892 227c 1510A0E3 		mov	r1, #21
 3893 2280 2520A0E3 		mov	r2, #37
 3894 2284 3030A0E3 		mov	r3, #48
 3895 2288 0A00A0E1 		mov	r0, sl
 3896 228c 00608DE5 		str	r6, [sp, #0]
 3897 2290 04608DE5 		str	r6, [sp, #4]
 3898 2294 FEFFFFEB 		bl	cmdSet
 373:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3899              		.loc 1 373 0
 3900 2298 1C009AE5 		ldr	r0, [sl, #28]
 3901 229c FEFFFFEB 		bl	_txe_mutex_put
 3902 22a0 FFC0A0E3 		mov	ip, #255
 3903 22a4 0C60A0E1 		mov	r6, ip
 3904 22a8 0280A0E3 		mov	r8, #2
 3905 22ac 00FEFFEA 		b	.L234
 3906              	.LVL302:
 3907              	.L250:
 3908              	.LBE69:
 3909              	.LBE68:
 3910              	.LBB70:
 3911              	.LBB71:
 370:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3912              		.loc 1 370 0
 3913 22b0 F4609FE5 		ldr	r6, .L308+24
 3914 22b4 0010E0E3 		mvn	r1, #0
 3915 22b8 1C0096E5 		ldr	r0, [r6, #28]
 3916 22bc FEFFFFEB 		bl	_txe_mutex_get
 371:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3917              		.loc 1 371 0
 3918 22c0 0080A0E3 		mov	r8, #0
 3919 22c4 01A0A0E3 		mov	sl, #1
 3920 22c8 1410A0E3 		mov	r1, #20
 3921 22cc 2720A0E3 		mov	r2, #39
 3922 22d0 3030A0E3 		mov	r3, #48
 3923 22d4 0600A0E1 		mov	r0, r6
 3924 22d8 04808DE5 		str	r8, [sp, #4]
 3925 22dc 00A08DE5 		str	sl, [sp, #0]
 3926 22e0 FEFFFFEB 		bl	cmdSet
 372:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3927              		.loc 1 372 0
 3928 22e4 02C0A0E3 		mov	ip, #2
 3929 22e8 1510A0E3 		mov	r1, #21
 3930 22ec 2520A0E3 		mov	r2, #37
 3931 22f0 3030A0E3 		mov	r3, #48
 3932 22f4 0600A0E1 		mov	r0, r6
 3933 22f8 00C08DE5 		str	ip, [sp, #0]
 3934 22fc 04808DE5 		str	r8, [sp, #4]
 3935 2300 FEFFFFEB 		bl	cmdSet
 373:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3936              		.loc 1 373 0
 3937 2304 1C0096E5 		ldr	r0, [r6, #28]
 3938 2308 FEFFFFEB 		bl	_txe_mutex_put
 3939              	.LBE71:
 3940              	.LBE70:
 982:../uvc.c      **** 							break;
 3941              		.loc 1 982 0
 3942 230c FFC0A0E3 		mov	ip, #255
 3943 2310 0C60A0E1 		mov	r6, ip
 3944 2314 0A80A0E1 		mov	r8, sl
 3945 2318 E5FDFFEA 		b	.L234
 3946              	.LVL303:
 3947              	.L249:
 979:../uvc.c      **** 		  		    switch (getData){
 3948              		.loc 1 979 0
 3949 231c FFC0A0E3 		mov	ip, #255
 3950 2320 0080A0E1 		mov	r8, r0
 3951 2324 0C60A0E1 		mov	r6, ip
 3952 2328 E1FDFFEA 		b	.L234
 3953              	.LVL304:
 3954              	.L255:
1050:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3955              		.loc 1 1050 0
 3956 232c 0000A0E3 		mov	r0, #0
 3957 2330 0110A0E3 		mov	r1, #1
 3958 2334 0020A0E1 		mov	r2, r0
 3959 2338 FEFFFFEB 		bl	CyU3PUsbStall
 3960              	.LVL305:
 3961 233c 95FEFFEA 		b	.L298
 3962              	.LVL306:
 3963              	.L297:
1068:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3964              		.loc 1 1068 0
 3965 2340 0110A0E3 		mov	r1, #1
 3966 2344 0020A0E1 		mov	r2, r0
 3967 2348 FEFFFFEB 		bl	CyU3PUsbStall
 3968 234c 91FEFFEA 		b	.L298
 3969              	.LVL307:
 3970              	.L307:
1083:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3971              		.loc 1 1083 0
 3972 2350 08E0A0E3 		mov	lr, #8
 3973 2354 00C0A0E3 		mov	ip, #0
 3974 2358 0600A0E1 		mov	r0, r6
 3975 235c 1710A0E3 		mov	r1, #23
 3976 2360 0B20A0E1 		mov	r2, fp
 3977 2364 00E08DE5 		str	lr, [sp, #0]
 3978 2368 04C08DE5 		str	ip, [sp, #4]
 3979 236c FEFFFFEB 		bl	cmdSet
 3980 2370 5EFEFFEA 		b	.L300
 3981              	.L306:
1081:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3982              		.loc 1 1081 0
 3983 2374 0480A0E3 		mov	r8, #4
 3984 2378 00E0A0E3 		mov	lr, #0
 3985 237c 0600A0E1 		mov	r0, r6
 3986 2380 1710A0E3 		mov	r1, #23
 3987 2384 0B20A0E1 		mov	r2, fp
 3988 2388 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 3989 238c FEFFFFEB 		bl	cmdSet
 3990 2390 56FEFFEA 		b	.L300
 3991              	.L309:
 3992              		.align	2
 3993              	.L308:
 3994 2394 00000000 		.word	bRequest
 3995 2398 00000000 		.word	.LANCHOR1
 3996 239c 00000000 		.word	.LANCHOR0
 3997 23a0 04040000 		.word	.LC24
 3998 23a4 28040000 		.word	.LC25
 3999 23a8 58000000 		.word	.LANCHOR0+88
 4000 23ac 00000000 		.word	cmdQu
 4001 23b0 B8030000 		.word	.LC22
 4002 23b4 FFFF0000 		.word	65535
 4003 23b8 E0030000 		.word	.LC23
 4004              		.cfi_endproc
 4005              	.LFE3:
 4007              		.align	2
 4008              		.global	UVCAppEP0Thread_Entry
 4010              	UVCAppEP0Thread_Entry:
 4011              	.LFB24:
3107:../uvc.c      **** {
 4012              		.loc 1 3107 0
 4013              		.cfi_startproc
 4014              		@ args = 0, pretend = 0, frame = 32
 4015              		@ frame_needed = 0, uses_anonymous_args = 0
 4016              	.LVL308:
 4017 23bc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4018              	.LCFI17:
 4019              		.cfi_def_cfa_offset 36
 4020 23c0 644A9FE5 		ldr	r4, .L456
 4021              		.cfi_offset 14, -4
 4022              		.cfi_offset 11, -8
 4023              		.cfi_offset 10, -12
 4024              		.cfi_offset 9, -16
 4025              		.cfi_offset 8, -20
 4026              		.cfi_offset 7, -24
 4027              		.cfi_offset 6, -28
 4028              		.cfi_offset 5, -32
 4029              		.cfi_offset 4, -36
 4030 23c4 646A9FE5 		ldr	r6, .L456+4
 4031 23c8 648A9FE5 		ldr	r8, .L456+8
 4032 23cc 64BA9FE5 		ldr	fp, .L456+12
 4033 23d0 64AA9FE5 		ldr	sl, .L456+16
 4034 23d4 647A9FE5 		ldr	r7, .L456+20
 4035 23d8 3CD04DE2 		sub	sp, sp, #60
 4036              	.LCFI18:
 4037              		.cfi_def_cfa_offset 96
 4038              	.LVL309:
3129:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4039              		.loc 1 3129 0
 4040 23dc 0450A0E1 		mov	r5, r4
 4041              	.LVL310:
 4042              	.L434:
 4043 23e0 00C0E0E3 		mvn	ip, #0
 4044 23e4 400A9FE5 		ldr	r0, .L456
 4045 23e8 4C10A0E3 		mov	r1, #76
 4046 23ec 0120A0E3 		mov	r2, #1
 4047 23f0 30308DE2 		add	r3, sp, #48
 4048 23f4 00C08DE5 		str	ip, [sp, #0]
 4049 23f8 FEFFFFEB 		bl	_txe_event_flags_get
 4050 23fc 000050E3 		cmp	r0, #0
 4051 2400 3000001A 		bne	.L311
3133:../uvc.c      ****             if (!isUsbConnected)
 4052              		.loc 1 3133 0
 4053 2404 443095E5 		ldr	r3, [r5, #68]
 4054 2408 000053E3 		cmp	r3, #0
 4055 240c 8900000A 		beq	.L446
 4056              	.L312:
3142:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4057              		.loc 1 3142 0
 4058 2410 30309DE5 		ldr	r3, [sp, #48]
 4059 2414 0C0013E3 		tst	r3, #12
 4060 2418 7200001A 		bne	.L447
 4061              	.L313:
3149:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4062              		.loc 1 3149 0
 4063 241c 040013E3 		tst	r3, #4
 4064 2420 1C00000A 		beq	.L314
3151:../uvc.c      ****             	switch ((wIndex >> 8))
 4065              		.loc 1 3151 0
 4066 2424 B0E0DAE1 		ldrh	lr, [sl, #0]
 4067 2428 2E24A0E1 		mov	r2, lr, lsr #8
 4068 242c 030052E3 		cmp	r2, #3
 4069 2430 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4070 2434 120000EA 		b	.L315
 4071              	.L320:
 4072 2438 84240000 		.word	.L315
 4073 243c 68250000 		.word	.L317
 4074 2440 48240000 		.word	.L318
 4075 2444 A4250000 		.word	.L319
 4076              	.L318:
 4077              	.LBB86:
 4078              	.LBB88:
2423:../uvc.c      ****     switch (wValue)
 4079              		.loc 1 2423 0
 4080 2448 B020DBE1 		ldrh	r2, [fp, #0]
 4081 244c 060C52E3 		cmp	r2, #1536
 4082 2450 F201000A 		beq	.L326
 4083 2454 CC00008A 		bhi	.L332
 4084 2458 030C52E3 		cmp	r2, #768
 4085 245c EB01000A 		beq	.L324
 4086 2460 E201008A 		bhi	.L333
 4087 2464 010C52E3 		cmp	r2, #256
 4088 2468 7B01000A 		beq	.L322
 4089 246c 020C52E3 		cmp	r2, #512
 4090 2470 7501000A 		beq	.L448
 4091              	.L335:
 4092              	.LBE88:
 4093              	.LBE86:
 4094              	.LBB91:
 4095              	.LBB95:
2555:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4096              		.loc 1 2555 0
 4097 2474 C8199FE5 		ldr	r1, .L456+24
 4098 2478 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4099 247c 0400A0E3 		mov	r0, #4
 4100 2480 FEFFFFEB 		bl	CyU3PDebugPrint
 4101              	.L315:
 4102              	.LBE95:
 4103              	.LBE91:
3172:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4104              		.loc 1 3172 0
 4105 2484 0000A0E3 		mov	r0, #0
 4106 2488 0110A0E3 		mov	r1, #1
 4107 248c 0020A0E1 		mov	r2, r0
 4108 2490 FEFFFFEB 		bl	CyU3PUsbStall
 4109 2494 30309DE5 		ldr	r3, [sp, #48]
 4110              	.L314:
3177:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4111              		.loc 1 3177 0
 4112 2498 080013E3 		tst	r3, #8
 4113 249c 0700000A 		beq	.L377
3181:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4114              		.loc 1 3181 0
 4115 24a0 B030DAE1 		ldrh	r3, [sl, #0]
 4116 24a4 010053E3 		cmp	r3, #1
 4117 24a8 6800000A 		beq	.L378
 4118              	.L379:
 4119              	.LBB100:
 4120              	.LBB106:
3096:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4121              		.loc 1 3096 0
 4122 24ac 0000A0E3 		mov	r0, #0
 4123 24b0 0110A0E3 		mov	r1, #1
 4124 24b4 0020A0E1 		mov	r2, r0
 4125 24b8 FEFFFFEB 		bl	CyU3PUsbStall
 4126              	.L438:
 4127 24bc 30309DE5 		ldr	r3, [sp, #48]
 4128              	.L377:
 4129              	.LBE106:
 4130              	.LBE100:
3192:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4131              		.loc 1 3192 0
 4132 24c0 400013E3 		tst	r3, #64
 4133 24c4 0100001A 		bne	.L449
 4134              	.L311:
3405:../uvc.c      ****         CyU3PThreadRelinquish ();
 4135              		.loc 1 3405 0
 4136 24c8 FEFFFFEB 		bl	_txe_thread_relinquish
3406:../uvc.c      ****     }
 4137              		.loc 1 3406 0
 4138 24cc C3FFFFEA 		b	.L434
 4139              	.L449:
3197:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4140              		.loc 1 3197 0
 4141 24d0 1800A0E3 		mov	r0, #24
 4142 24d4 2C108DE2 		add	r1, sp, #44
 4143 24d8 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3202:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4144              		.loc 1 3202 0
 4145 24dc 2C309DE5 		ldr	r3, [sp, #44]
 4146 24e0 000053E3 		cmp	r3, #0
 4147 24e4 6D00000A 		beq	.L429
3202:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4148              		.loc 1 3202 0 is_stmt 0 discriminator 1
 4149 24e8 5F36D6E5 		ldrb	r3, [r6, #1631]	@ zero_extendqisi2
 4150 24ec 000053E3 		cmp	r3, #0
 4151 24f0 F4FFFF1A 		bne	.L311
3204:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4152              		.loc 1 3204 0 is_stmt 1
 4153 24f4 00E097E5 		ldr	lr, [r7, #0]
 4154 24f8 0290A0E3 		mov	r9, #2
 4155 24fc 0090CEE5 		strb	r9, [lr, #0]
3205:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4156              		.loc 1 3205 0
 4157 2500 001097E5 		ldr	r1, [r7, #0]
 4158 2504 0190A0E3 		mov	r9, #1
 4159 2508 0190C1E5 		strb	r9, [r1, #1]
3206:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4160              		.loc 1 3206 0
 4161 250c 000097E5 		ldr	r0, [r7, #0]
3210:../uvc.c      **** 					interStabuf.size   = 1024;
 4162              		.loc 1 3210 0
 4163 2510 012BA0E3 		mov	r2, #1024	@ movhi
3206:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4164              		.loc 1 3206 0
 4165 2514 0230C0E5 		strb	r3, [r0, #2]
3207:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4166              		.loc 1 3207 0
 4167 2518 00C097E5 		ldr	ip, [r7, #0]
3216:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4168              		.loc 1 3216 0
 4169 251c 0010E0E3 		mvn	r1, #0
3207:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4170              		.loc 1 3207 0
 4171 2520 0330CCE5 		strb	r3, [ip, #3]
3209:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4172              		.loc 1 3209 0
 4173 2524 00E097E5 		ldr	lr, [r7, #0]
3213:../uvc.c      **** 					interStabuf.count = 4;
 4174              		.loc 1 3213 0
 4175 2528 04C0A0E3 		mov	ip, #4	@ movhi
3216:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4176              		.loc 1 3216 0
 4177 252c 14099FE5 		ldr	r0, .L456+28
3211:../uvc.c      **** 					interStabuf.status = 0;
 4178              		.loc 1 3211 0
 4179 2530 B832CDE1 		strh	r3, [sp, #40]	@ movhi
3210:../uvc.c      **** 					interStabuf.size   = 1024;
 4180              		.loc 1 3210 0
 4181 2534 B622CDE1 		strh	r2, [sp, #38]	@ movhi
3209:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4182              		.loc 1 3209 0
 4183 2538 20E08DE5 		str	lr, [sp, #32]
3213:../uvc.c      **** 					interStabuf.count = 4;
 4184              		.loc 1 3213 0
 4185 253c B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
3216:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4186              		.loc 1 3216 0
 4187 2540 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3219:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4188              		.loc 1 3219 0
 4189 2544 FC089FE5 		ldr	r0, .L456+28
 4190 2548 20108DE2 		add	r1, sp, #32
 4191 254c FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4192              	.LVL311:
3220:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4193              		.loc 1 3220 0
 4194 2550 003050E2 		subs	r3, r0, #0
 4195 2554 7901001A 		bne	.L450
3225:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
 4196              		.loc 1 3225 0
 4197 2558 D0389FE5 		ldr	r3, .L456+4
 4198 255c 5F96C3E5 		strb	r9, [r3, #1631]
3405:../uvc.c      ****         CyU3PThreadRelinquish ();
 4199              		.loc 1 3405 0
 4200 2560 FEFFFFEB 		bl	_txe_thread_relinquish
 4201              	.LVL312:
 4202 2564 9DFFFFEA 		b	.L434
 4203              	.L317:
 4204              	.LBB112:
 4205              	.LBB96:
2498:../uvc.c      ****     switch (wValue)
 4206              		.loc 1 2498 0
 4207 2568 B020DBE1 		ldrh	r2, [fp, #0]
 4208 256c 060C52E3 		cmp	r2, #1536
 4209 2570 D600000A 		beq	.L341
 4210 2574 8F00008A 		bhi	.L347
 4211 2578 030C52E3 		cmp	r2, #768
 4212 257c 2A01000A 		beq	.L338
 4213 2580 2101008A 		bhi	.L348
 4214 2584 010C52E3 		cmp	r2, #256
 4215 2588 6801000A 		beq	.L336
 4216 258c 020C52E3 		cmp	r2, #512
 4217 2590 B7FFFF1A 		bne	.L335
 4218              	.LVL313:
2506:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4219              		.loc 1 2506 0
 4220 2594 0100A0E3 		mov	r0, #1
 4221 2598 FEFFFFEB 		bl	CTControlHandle
 4222              	.LVL314:
 4223 259c 30309DE5 		ldr	r3, [sp, #48]
 4224 25a0 BCFFFFEA 		b	.L314
 4225              	.L319:
 4226              	.LBE96:
 4227              	.LBE112:
 4228              	.LBB113:
 4229              	.LBB118:
2723:../uvc.c      ****     switch (wValue)
 4230              		.loc 1 2723 0
 4231 25a4 B020DBE1 		ldrh	r2, [fp, #0]
 4232 25a8 090C52E3 		cmp	r2, #2304
 4233 25ac 1002000A 		beq	.L362
 4234 25b0 8800008A 		bhi	.L371
 4235 25b4 010B52E3 		cmp	r2, #1024
 4236 25b8 1102000A 		beq	.L357
 4237 25bc A001008A 		bhi	.L372
 4238 25c0 020C52E3 		cmp	r2, #512
 4239 25c4 0602000A 		beq	.L355
 4240 25c8 030C52E3 		cmp	r2, #768
 4241 25cc F401000A 		beq	.L356
 4242 25d0 010C52E3 		cmp	r2, #256
 4243 25d4 AAFFFF1A 		bne	.L315
 4244              	.LVL315:
2727:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4245              		.loc 1 2727 0
 4246 25d8 1000A0E3 		mov	r0, #16
 4247 25dc FEFFFFEB 		bl	ControlHandle
 4248              	.LVL316:
 4249 25e0 30309DE5 		ldr	r3, [sp, #48]
 4250 25e4 ABFFFFEA 		b	.L314
 4251              	.L447:
 4252              	.LBE118:
 4253              	.LBE113:
3143:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4254              		.loc 1 3143 0
 4255 25e8 5C989FE5 		ldr	r9, .L456+32
 4256 25ec B0C0DBE1 		ldrh	ip, [fp, #0]
 4257 25f0 B000DAE1 		ldrh	r0, [sl, #0]
 4258 25f4 54189FE5 		ldr	r1, .L456+36
 4259 25f8 00E0D9E5 		ldrb	lr, [r9, #0]	@ zero_extendqisi2
 4260 25fc 0090D8E5 		ldrb	r9, [r8, #0]	@ zero_extendqisi2
 4261 2600 2C20D4E5 		ldrb	r2, [r4, #44]	@ zero_extendqisi2
 4262 2604 0C008DE5 		str	r0, [sp, #12]
 4263 2608 08C08DE5 		str	ip, [sp, #8]
 4264 260c B0C0D1E1 		ldrh	ip, [r1, #0]
 4265 2610 0400A0E3 		mov	r0, #4
 4266 2614 04908DE5 		str	r9, [sp, #4]
 4267 2618 34189FE5 		ldr	r1, .L456+40
 4268 261c 0090A0E3 		mov	r9, #0
 4269 2620 00E08DE5 		str	lr, [sp, #0]
 4270 2624 10C08DE5 		str	ip, [sp, #16]
 4271 2628 14908DE5 		str	r9, [sp, #20]
 4272 262c FEFFFFEB 		bl	CyU3PDebugPrint
 4273 2630 30309DE5 		ldr	r3, [sp, #48]
 4274 2634 78FFFFEA 		b	.L313
 4275              	.L446:
3135:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4276              		.loc 1 3135 0
 4277 2638 FEFFFFEB 		bl	CyU3PUsbGetSpeed
3136:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4278              		.loc 1 3136 0
 4279 263c 000050E3 		cmp	r0, #0
3135:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4280              		.loc 1 3135 0
 4281 2640 2C00C5E5 		strb	r0, [r5, #44]
3138:../uvc.c      ****                     isUsbConnected = CyTrue;
 4282              		.loc 1 3138 0
 4283 2644 0100A013 		movne	r0, #1
 4284 2648 44008515 		strne	r0, [r5, #68]
 4285 264c 6FFFFFEA 		b	.L312
 4286              	.L378:
 4287              	.LVL317:
 4288              	.LBB123:
 4289              	.LBB105:
2818:../uvc.c      ****     switch (wValue)
 4290              		.loc 1 2818 0
 4291 2650 B020DBE1 		ldrh	r2, [fp, #0]
 4292 2654 030C52E3 		cmp	r2, #768
 4293 2658 8200000A 		beq	.L382
 4294 265c 3300008A 		bhi	.L385
 4295 2660 010C52E3 		cmp	r2, #256
 4296 2664 8C00000A 		beq	.L380
 4297 2668 020C52E3 		cmp	r2, #512
 4298 266c 8EFFFF1A 		bne	.L379
2885:../uvc.c      ****             switch (bRequest)
 4299              		.loc 1 2885 0
 4300 2670 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4301 2674 810053E3 		cmp	r3, #129
 4302 2678 8C00000A 		beq	.L423
 4303 267c 3A01008A 		bhi	.L399
 4304 2680 010053E3 		cmp	r3, #1
 4305 2684 B501000A 		beq	.L451
 4306              	.L403:
2984:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4307              		.loc 1 2984 0
 4308 2688 0000A0E3 		mov	r0, #0
 4309 268c 0110A0E3 		mov	r1, #1
 4310 2690 0020A0E1 		mov	r2, r0
 4311 2694 FEFFFFEB 		bl	CyU3PUsbStall
 4312 2698 30309DE5 		ldr	r3, [sp, #48]
 4313 269c 87FFFFEA 		b	.L377
 4314              	.LVL318:
 4315              	.L429:
 4316              	.LBE105:
 4317              	.LBE123:
3226:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4318              		.loc 1 3226 0
 4319 26a0 5F26D6E5 		ldrb	r2, [r6, #1631]	@ zero_extendqisi2
 4320 26a4 000052E3 		cmp	r2, #0
 4321 26a8 86FFFF0A 		beq	.L311
3228:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4322              		.loc 1 3228 0
 4323 26ac 002097E5 		ldr	r2, [r7, #0]
 4324 26b0 0290A0E3 		mov	r9, #2
 4325 26b4 0090C2E5 		strb	r9, [r2, #0]
3229:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4326              		.loc 1 3229 0
 4327 26b8 001097E5 		ldr	r1, [r7, #0]
 4328 26bc 0190A0E3 		mov	r9, #1
 4329 26c0 0190C1E5 		strb	r9, [r1, #1]
3230:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4330              		.loc 1 3230 0
 4331 26c4 000097E5 		ldr	r0, [r7, #0]
3234:../uvc.c      **** 					interStabuf.size   = 1024;
 4332              		.loc 1 3234 0
 4333 26c8 01CBA0E3 		mov	ip, #1024	@ movhi
3230:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4334              		.loc 1 3230 0
 4335 26cc 0230C0E5 		strb	r3, [r0, #2]
3231:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4336              		.loc 1 3231 0
 4337 26d0 00E097E5 		ldr	lr, [r7, #0]
3240:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4338              		.loc 1 3240 0
 4339 26d4 0010E0E3 		mvn	r1, #0
3231:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4340              		.loc 1 3231 0
 4341 26d8 0390CEE5 		strb	r9, [lr, #3]
3233:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4342              		.loc 1 3233 0
 4343 26dc 002097E5 		ldr	r2, [r7, #0]
3237:../uvc.c      **** 					interStabuf.count = 4;
 4344              		.loc 1 3237 0
 4345 26e0 04E0A0E3 		mov	lr, #4	@ movhi
3234:../uvc.c      **** 					interStabuf.size   = 1024;
 4346              		.loc 1 3234 0
 4347 26e4 B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
3240:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4348              		.loc 1 3240 0
 4349 26e8 58079FE5 		ldr	r0, .L456+28
3235:../uvc.c      **** 					interStabuf.status = 0;
 4350              		.loc 1 3235 0
 4351 26ec 03C0A0E1 		mov	ip, r3	@ movhi
3233:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4352              		.loc 1 3233 0
 4353 26f0 20208DE5 		str	r2, [sp, #32]
3235:../uvc.c      **** 					interStabuf.status = 0;
 4354              		.loc 1 3235 0
 4355 26f4 B832CDE1 		strh	r3, [sp, #40]	@ movhi
3237:../uvc.c      **** 					interStabuf.count = 4;
 4356              		.loc 1 3237 0
 4357 26f8 B4E2CDE1 		strh	lr, [sp, #36]	@ movhi
3240:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4358              		.loc 1 3240 0
 4359 26fc 1CC08DE5 		str	ip, [sp, #28]
 4360 2700 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3243:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4361              		.loc 1 3243 0
 4362 2704 3C079FE5 		ldr	r0, .L456+28
 4363 2708 20108DE2 		add	r1, sp, #32
 4364 270c FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4365              	.LVL319:
3244:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4366              		.loc 1 3244 0
 4367 2710 1C209DE5 		ldr	r2, [sp, #28]
 4368 2714 003050E2 		subs	r3, r0, #0
 4369 2718 D300001A 		bne	.L452
3250:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4370              		.loc 1 3250 0
 4371 271c 0C379FE5 		ldr	r3, .L456+4
3251:../uvc.c      **** 					stiflag = CyTrue;
 4372              		.loc 1 3251 0
 4373 2720 9C9084E5 		str	r9, [r4, #156]
3250:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4374              		.loc 1 3250 0
 4375 2724 5F26C3E5 		strb	r2, [r3, #1631]
3405:../uvc.c      ****         CyU3PThreadRelinquish ();
 4376              		.loc 1 3405 0
 4377 2728 FEFFFFEB 		bl	_txe_thread_relinquish
 4378              	.LVL320:
 4379 272c 2BFFFFEA 		b	.L434
 4380              	.LVL321:
 4381              	.L385:
 4382              	.LBB124:
 4383              	.LBB107:
2818:../uvc.c      ****     switch (wValue)
 4384              		.loc 1 2818 0
 4385 2730 010B52E3 		cmp	r2, #1024
 4386 2734 3900000A 		beq	.L383
 4387 2738 050C52E3 		cmp	r2, #1280
 4388 273c 5AFFFF1A 		bne	.L379
3045:../uvc.c      ****                 switch (bRequest)
 4389              		.loc 1 3045 0
 4390 2740 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4391 2744 810052E3 		cmp	r2, #129
 4392 2748 5800000A 		beq	.L423
 4393 274c 3701008A 		bhi	.L426
 4394 2750 010052E3 		cmp	r2, #1
 4395 2754 54FFFF1A 		bne	.L379
3070:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4396              		.loc 1 3070 0
 4397 2758 2000A0E3 		mov	r0, #32
 4398 275c F4169FE5 		ldr	r1, .L456+44
 4399 2760 36208DE2 		add	r2, sp, #54
 4400 2764 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4401              	.LVL322:
3072:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4402              		.loc 1 3072 0
 4403 2768 000050E3 		cmp	r0, #0
 4404 276c A801001A 		bne	.L428
3082:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
 4405              		.loc 1 3082 0
 4406 2770 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 4407 2774 040080E2 		add	r0, r0, #4
 4408              	.LVL323:
 4409 2778 DC169FE5 		ldr	r1, .L456+48
 4410 277c B623DDE1 		ldrh	r2, [sp, #54]
 4411 2780 FEFFFFEB 		bl	CyU3PDebugPrint
 4412              	.LVL324:
 4413 2784 30309DE5 		ldr	r3, [sp, #48]
 4414 2788 4CFFFFEA 		b	.L377
 4415              	.L332:
 4416              	.LBE107:
 4417              	.LBE124:
 4418              	.LBB125:
 4419              	.LBB89:
2423:../uvc.c      ****     switch (wValue)
 4420              		.loc 1 2423 0
 4421 278c 0A0C52E3 		cmp	r2, #2560
 4422 2790 0E01000A 		beq	.L329
 4423 2794 0301008A 		bhi	.L334
 4424 2798 070C52E3 		cmp	r2, #1792
 4425 279c FD00000A 		beq	.L327
 4426 27a0 020B52E3 		cmp	r2, #2048
 4427 27a4 32FFFF1A 		bne	.L335
 4428              	.LVL325:
2454:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4429              		.loc 1 2454 0
 4430 27a8 0700A0E3 		mov	r0, #7
 4431 27ac FEFFFFEB 		bl	ControlHandle
 4432              	.LVL326:
 4433 27b0 30309DE5 		ldr	r3, [sp, #48]
 4434 27b4 37FFFFEA 		b	.L314
 4435              	.L347:
 4436              	.LBE89:
 4437              	.LBE125:
 4438              	.LBB126:
 4439              	.LBB94:
2498:../uvc.c      ****     switch (wValue)
 4440              		.loc 1 2498 0
 4441 27b8 090C52E3 		cmp	r2, #2304
 4442 27bc 3F01000A 		beq	.L343
 4443 27c0 3401008A 		bhi	.L349
 4444 27c4 070C52E3 		cmp	r2, #1792
 4445 27c8 2601000A 		beq	.L342
 4446 27cc 020B52E3 		cmp	r2, #2048
 4447 27d0 27FFFF1A 		bne	.L335
 4448 27d4 2FFFFFEA 		b	.L314
 4449              	.L371:
 4450              	.LBE94:
 4451              	.LBE126:
 4452              	.LBB127:
 4453              	.LBB117:
2723:../uvc.c      ****     switch (wValue)
 4454              		.loc 1 2723 0
 4455 27d8 0F0C52E3 		cmp	r2, #3840
 4456 27dc 7C01000A 		beq	.L366
 4457 27e0 3E00008A 		bhi	.L374
 4458 27e4 0B0C52E3 		cmp	r2, #2816
 4459 27e8 7501000A 		beq	.L364
 4460 27ec 0D0C52E3 		cmp	r2, #3328
 4461 27f0 6F01000A 		beq	.L365
 4462 27f4 0A0C52E3 		cmp	r2, #2560
 4463 27f8 21FFFF1A 		bne	.L315
2762:../uvc.c      ****     		if(CamMode == 1){//only 720p support
 4464              		.loc 1 2762 0
 4465 27fc 7830D4E5 		ldrb	r3, [r4, #120]	@ zero_extendqisi2
 4466 2800 010053E3 		cmp	r3, #1
 4467 2804 3D01000A 		beq	.L453
2766:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
 4468              		.loc 1 2766 0
 4469 2808 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4470 280c 0400A0E3 		mov	r0, #4
 4471 2810 48169FE5 		ldr	r1, .L456+52
 4472 2814 FEFFFFEB 		bl	CyU3PDebugPrint
 4473 2818 30309DE5 		ldr	r3, [sp, #48]
 4474 281c 1DFFFFEA 		b	.L314
 4475              	.LVL327:
 4476              	.L383:
 4477              	.LBE117:
 4478              	.LBE127:
 4479              	.LBB128:
 4480              	.LBB104:
2990:../uvc.c      ****                 switch (bRequest)
 4481              		.loc 1 2990 0
 4482 2820 0090D8E5 		ldrb	r9, [r8, #0]	@ zero_extendqisi2
 4483 2824 810059E3 		cmp	r9, #129
 4484 2828 1300000A 		beq	.L414
 4485 282c 9900008A 		bhi	.L417
 4486 2830 010059E3 		cmp	r9, #1
 4487 2834 1CFFFF1A 		bne	.L379
3015:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4488              		.loc 1 3015 0
 4489 2838 36208DE2 		add	r2, sp, #54
 4490 283c 2000A0E3 		mov	r0, #32
 4491 2840 10169FE5 		ldr	r1, .L456+44
 4492 2844 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4493              	.LVL328:
3017:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4494              		.loc 1 3017 0
 4495 2848 002050E2 		subs	r2, r0, #0
 4496 284c 1AFFFF1A 		bne	.L438
3030:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
 4497              		.loc 1 3030 0
 4498 2850 D4059FE5 		ldr	r0, .L456
 4499              	.LVL329:
 4500 2854 0910A0E1 		mov	r1, r9
 4501 2858 FEFFFFEB 		bl	_txe_event_flags_set
 4502              	.LVL330:
3031:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4503              		.loc 1 3031 0
 4504 285c 002050E2 		subs	r2, r0, #0
 4505 2860 15FFFF0A 		beq	.L438
 4506 2864 490100EA 		b	.L420
 4507              	.LVL331:
 4508              	.L382:
2941:../uvc.c      ****                 switch (bRequest)
 4509              		.loc 1 2941 0
 4510 2868 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4511 286c 830052E3 		cmp	r2, #131
 4512 2870 A700008A 		bhi	.L408
 4513 2874 810052E3 		cmp	r2, #129
 4514 2878 8C00003A 		bcc	.L454
 4515              	.L414:
3002:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4516              		.loc 1 3002 0
 4517 287c 2C20D4E5 		ldrb	r2, [r4, #44]	@ zero_extendqisi2
3004:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4518              		.loc 1 3004 0
 4519 2880 0B00A0E3 		mov	r0, #11
3002:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4520              		.loc 1 3002 0
 4521 2884 030052E3 		cmp	r2, #3
3004:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4522              		.loc 1 3004 0
 4523 2888 D4159F05 		ldreq	r1, .L456+56
3008:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4524              		.loc 1 3008 0
 4525 288c D4159F15 		ldrne	r1, .L456+60
 4526 2890 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4527 2894 30309DE5 		ldr	r3, [sp, #48]
 4528 2898 08FFFFEA 		b	.L377
 4529              	.L380:
2821:../uvc.c      ****             switch (bRequest)
 4530              		.loc 1 2821 0
 4531 289c 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4532 28a0 830052E3 		cmp	r2, #131
 4533 28a4 4600008A 		bhi	.L391
 4534 28a8 810052E3 		cmp	r2, #129
 4535 28ac 1400003A 		bcc	.L455
 4536              	.L423:
3057:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4537              		.loc 1 3057 0
 4538 28b0 2C30D4E5 		ldrb	r3, [r4, #44]	@ zero_extendqisi2
3059:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4539              		.loc 1 3059 0
 4540 28b4 1A00A0E3 		mov	r0, #26
3057:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4541              		.loc 1 3057 0
 4542 28b8 030053E3 		cmp	r3, #3
3059:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4543              		.loc 1 3059 0
 4544 28bc A8159F05 		ldreq	r1, .L456+64
3063:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4545              		.loc 1 3063 0
 4546 28c0 A8159F15 		ldrne	r1, .L456+68
 4547 28c4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4548 28c8 30309DE5 		ldr	r3, [sp, #48]
 4549 28cc FBFEFFEA 		b	.L377
 4550              	.LVL332:
 4551              	.L341:
 4552              	.LBE104:
 4553              	.LBE128:
 4554              	.LBB129:
 4555              	.LBB97:
2524:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 4556              		.loc 1 2524 0
 4557 28d0 0500A0E3 		mov	r0, #5
 4558 28d4 FEFFFFEB 		bl	CTControlHandle
 4559              	.LVL333:
 4560 28d8 30309DE5 		ldr	r3, [sp, #48]
 4561 28dc EDFEFFEA 		b	.L314
 4562              	.L374:
 4563              	.LBE97:
 4564              	.LBE129:
 4565              	.LBB130:
 4566              	.LBB119:
2723:../uvc.c      ****     switch (wValue)
 4567              		.loc 1 2723 0
 4568 28e0 110C52E3 		cmp	r2, #4352
 4569 28e4 1901000A 		beq	.L368
 4570 28e8 3F00008A 		bhi	.L375
 4571 28ec 010A52E3 		cmp	r2, #4096
 4572 28f0 E3FEFF1A 		bne	.L315
 4573              	.LVL334:
2786:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4574              		.loc 1 2786 0
 4575 28f4 1F00A0E3 		mov	r0, #31
 4576 28f8 FEFFFFEB 		bl	ControlHandle
 4577              	.LVL335:
 4578 28fc 30309DE5 		ldr	r3, [sp, #48]
 4579 2900 E4FEFFEA 		b	.L314
 4580              	.LVL336:
 4581              	.L455:
 4582              	.LBE119:
 4583              	.LBE130:
 4584              	.LBB131:
 4585              	.LBB108:
2821:../uvc.c      ****             switch (bRequest)
 4586              		.loc 1 2821 0
 4587 2904 010052E3 		cmp	r2, #1
 4588 2908 E7FEFF1A 		bne	.L379
2846:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4589              		.loc 1 2846 0
 4590 290c 2000A0E3 		mov	r0, #32
 4591 2910 40159FE5 		ldr	r1, .L456+44
 4592 2914 36208DE2 		add	r2, sp, #54
 4593 2918 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4594              	.LVL337:
2848:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4595              		.loc 1 2848 0
 4596 291c 000050E3 		cmp	r0, #0
 4597 2920 1800001A 		bne	.L393
2850:../uvc.c      ****                         CyU3PDebugPrint (4, "glProbeCtrl 20 ~25 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x\
 4598              		.loc 1 2850 0
 4599 2924 4016D6E5 		ldrb	r1, [r6, #1600]	@ zero_extendqisi2
 4600 2928 3EE6D6E5 		ldrb	lr, [r6, #1598]	@ zero_extendqisi2
 4601 292c 3F96D6E5 		ldrb	r9, [r6, #1599]	@ zero_extendqisi2
 4602 2930 41C6D6E5 		ldrb	ip, [r6, #1601]	@ zero_extendqisi2
 4603 2934 2E26D6E5 		ldrb	r2, [r6, #1582]	@ zero_extendqisi2
 4604 2938 08108DE5 		str	r1, [sp, #8]
 4605 293c 2F36D6E5 		ldrb	r3, [r6, #1583]	@ zero_extendqisi2
 4606 2940 2C159FE5 		ldr	r1, .L456+72
 4607 2944 040080E2 		add	r0, r0, #4
 4608              	.LVL338:
 4609 2948 00E08DE5 		str	lr, [sp, #0]
 4610 294c 04908DE5 		str	r9, [sp, #4]
 4611 2950 0CC08DE5 		str	ip, [sp, #12]
 4612 2954 FEFFFFEB 		bl	CyU3PDebugPrint
 4613              	.LVL339:
2862:../uvc.c      ****                             glProbeCtrl20[2] = glCommitCtrl[2];
 4614              		.loc 1 2862 0
 4615 2958 7EE0D5E5 		ldrb	lr, [r5, #126]	@ zero_extendqisi2
2863:../uvc.c      ****                             glProbeCtrl20[3] = glCommitCtrl[3];
 4616              		.loc 1 2863 0
 4617 295c 7FC0D5E5 		ldrb	ip, [r5, #127]	@ zero_extendqisi2
2864:../uvc.c      ****                             glProbeCtrl20[18] = glCommitCtrl[18];
 4618              		.loc 1 2864 0
 4619 2960 8E00D5E5 		ldrb	r0, [r5, #142]	@ zero_extendqisi2
2865:../uvc.c      ****                             glProbeCtrl20[19] = glCommitCtrl[19];
 4620              		.loc 1 2865 0
 4621 2964 8F10D5E5 		ldrb	r1, [r5, #143]	@ zero_extendqisi2
2866:../uvc.c      ****                             glProbeCtrl20[20] = glCommitCtrl[20];
 4622              		.loc 1 2866 0
 4623 2968 9020D5E5 		ldrb	r2, [r5, #144]	@ zero_extendqisi2
2867:../uvc.c      ****                             glProbeCtrl20[21] = glCommitCtrl[21];
 4624              		.loc 1 2867 0
 4625 296c 9190D5E5 		ldrb	r9, [r5, #145]	@ zero_extendqisi2
2862:../uvc.c      ****                             glProbeCtrl20[2] = glCommitCtrl[2];
 4626              		.loc 1 2862 0
 4627 2970 2EE6C6E5 		strb	lr, [r6, #1582]
2863:../uvc.c      ****                             glProbeCtrl20[3] = glCommitCtrl[3];
 4628              		.loc 1 2863 0
 4629 2974 2FC6C6E5 		strb	ip, [r6, #1583]
2864:../uvc.c      ****                             glProbeCtrl20[18] = glCommitCtrl[18];
 4630              		.loc 1 2864 0
 4631 2978 3E06C6E5 		strb	r0, [r6, #1598]
2865:../uvc.c      ****                             glProbeCtrl20[19] = glCommitCtrl[19];
 4632              		.loc 1 2865 0
 4633 297c 3F16C6E5 		strb	r1, [r6, #1599]
2866:../uvc.c      ****                             glProbeCtrl20[20] = glCommitCtrl[20];
 4634              		.loc 1 2866 0
 4635 2980 4026C6E5 		strb	r2, [r6, #1600]
2867:../uvc.c      ****                             glProbeCtrl20[21] = glCommitCtrl[21];
 4636              		.loc 1 2867 0
 4637 2984 4196C6E5 		strb	r9, [r6, #1601]
 4638              	.L393:
2870:../uvc.c      ****                     CyU3PDebugPrint (4, "glCommitCtrl 20 ~25 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x\n\r
 4639              		.loc 1 2870 0
 4640 2988 9000D4E5 		ldrb	r0, [r4, #144]	@ zero_extendqisi2
 4641 298c 7F30D4E5 		ldrb	r3, [r4, #127]	@ zero_extendqisi2
 4642 2990 7E20D4E5 		ldrb	r2, [r4, #126]	@ zero_extendqisi2
 4643 2994 8EE0D4E5 		ldrb	lr, [r4, #142]	@ zero_extendqisi2
 4644 2998 8F90D4E5 		ldrb	r9, [r4, #143]	@ zero_extendqisi2
 4645 299c 08008DE5 		str	r0, [sp, #8]
 4646 29a0 91C0D4E5 		ldrb	ip, [r4, #145]	@ zero_extendqisi2
 4647 29a4 0400A0E3 		mov	r0, #4
 4648 29a8 C8149FE5 		ldr	r1, .L456+76
 4649 29ac 00E08DE5 		str	lr, [sp, #0]
 4650 29b0 04908DE5 		str	r9, [sp, #4]
 4651 29b4 0CC08DE5 		str	ip, [sp, #12]
 4652 29b8 FEFFFFEB 		bl	CyU3PDebugPrint
 4653 29bc 30309DE5 		ldr	r3, [sp, #48]
 4654 29c0 BEFEFFEA 		b	.L377
 4655              	.LVL340:
 4656              	.L391:
2821:../uvc.c      ****             switch (bRequest)
 4657              		.loc 1 2821 0
 4658 29c4 860052E3 		cmp	r2, #134
 4659 29c8 3600000A 		beq	.L441
 4660 29cc 870052E3 		cmp	r2, #135
 4661 29d0 B6FFFF0A 		beq	.L423
 4662 29d4 850052E3 		cmp	r2, #133
 4663 29d8 B3FEFF1A 		bne	.L379
 4664              	.L415:
2999:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4665              		.loc 1 2999 0
 4666 29dc 0200A0E3 		mov	r0, #2
 4667 29e0 94149FE5 		ldr	r1, .L456+80
2997:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4668              		.loc 1 2997 0
 4669 29e4 1A30A0E3 		mov	r3, #26
 4670 29e8 CE0000EA 		b	.L439
 4671              	.LVL341:
 4672              	.L375:
 4673              	.LBE108:
 4674              	.LBE131:
 4675              	.LBB132:
 4676              	.LBB116:
2723:../uvc.c      ****     switch (wValue)
 4677              		.loc 1 2723 0
 4678 29ec 120C52E3 		cmp	r2, #4608
 4679 29f0 D200000A 		beq	.L369
 4680 29f4 130C52E3 		cmp	r2, #4864
 4681 29f8 A1FEFF1A 		bne	.L315
 4682              	.LVL342:
2798:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
 4683              		.loc 1 2798 0
 4684 29fc 2200A0E3 		mov	r0, #34
 4685 2a00 FEFFFFEB 		bl	ControlHandle
 4686              	.LVL343:
 4687 2a04 30309DE5 		ldr	r3, [sp, #48]
 4688 2a08 A2FEFFEA 		b	.L314
 4689              	.L348:
 4690              	.LBE116:
 4691              	.LBE132:
 4692              	.LBB133:
 4693              	.LBB93:
2498:../uvc.c      ****     switch (wValue)
 4694              		.loc 1 2498 0
 4695 2a0c 010B52E3 		cmp	r2, #1024
 4696 2a10 0900000A 		beq	.L339
 4697 2a14 050C52E3 		cmp	r2, #1280
 4698 2a18 95FEFF1A 		bne	.L335
 4699              	.LVL344:
2520:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4700              		.loc 1 2520 0
 4701 2a1c 0400A0E3 		mov	r0, #4
 4702 2a20 FEFFFFEB 		bl	CTControlHandle
 4703              	.LVL345:
 4704 2a24 30309DE5 		ldr	r3, [sp, #48]
 4705 2a28 9AFEFFEA 		b	.L314
 4706              	.L338:
 4707              	.LVL346:
2510:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 4708              		.loc 1 2510 0
 4709 2a2c 0200A0E3 		mov	r0, #2
 4710 2a30 FEFFFFEB 		bl	CTControlHandle
 4711              	.LVL347:
 4712 2a34 30309DE5 		ldr	r3, [sp, #48]
 4713 2a38 96FEFFEA 		b	.L314
 4714              	.L339:
 4715              	.LVL348:
2515:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 4716              		.loc 1 2515 0
 4717 2a3c 0300A0E3 		mov	r0, #3
 4718 2a40 FEFFFFEB 		bl	CTControlHandle
 4719              	.LVL349:
 4720 2a44 30309DE5 		ldr	r3, [sp, #48]
 4721 2a48 92FEFFEA 		b	.L314
 4722              	.L448:
 4723              	.LVL350:
 4724              	.LBE93:
 4725              	.LBE133:
 4726              	.LBB134:
 4727              	.LBB87:
2431:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 4728              		.loc 1 2431 0
 4729 2a4c 0100A0E3 		mov	r0, #1
 4730 2a50 FEFFFFEB 		bl	ControlHandle
 4731              	.LVL351:
 4732 2a54 30309DE5 		ldr	r3, [sp, #48]
 4733 2a58 8EFEFFEA 		b	.L314
 4734              	.L322:
 4735              	.LVL352:
2427:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 4736              		.loc 1 2427 0
 4737 2a5c 0000A0E3 		mov	r0, #0
 4738 2a60 FEFFFFEB 		bl	ControlHandle
 4739              	.LVL353:
 4740 2a64 30309DE5 		ldr	r3, [sp, #48]
 4741 2a68 8AFEFFEA 		b	.L314
 4742              	.LVL354:
 4743              	.L452:
 4744              	.LBE87:
 4745              	.LBE134:
3246:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4746              		.loc 1 3246 0
 4747 2a6c 0C149FE5 		ldr	r1, .L456+84
 4748 2a70 0320A0E1 		mov	r2, r3
 4749 2a74 0400A0E3 		mov	r0, #4
 4750              	.LVL355:
 4751 2a78 1C308DE5 		str	r3, [sp, #28]
 4752 2a7c FEFFFFEB 		bl	CyU3PDebugPrint
 4753              	.LVL356:
 4754              	.LBB135:
 4755              	.LBB136:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 4756              		.loc 1 1214 0
 4757 2a80 1C509DE5 		ldr	r5, [sp, #28]
 4758 2a84 0400A0E3 		mov	r0, #4
 4759 2a88 F4139FE5 		ldr	r1, .L456+88
 4760 2a8c 0520A0E1 		mov	r2, r5
 4761 2a90 FEFFFFEB 		bl	CyU3PDebugPrint
 4762              	.LVL357:
 4763              	.L433:
 4764 2a94 FEFFFFEA 		b	.L433
 4765              	.LVL358:
 4766              	.L417:
 4767              	.LBE136:
 4768              	.LBE135:
 4769              	.LBB137:
 4770              	.LBB103:
2990:../uvc.c      ****                 switch (bRequest)
 4771              		.loc 1 2990 0
 4772 2a98 850059E3 		cmp	r9, #133
 4773 2a9c CEFFFF0A 		beq	.L415
 4774 2aa0 860059E3 		cmp	r9, #134
 4775 2aa4 80FEFF1A 		bne	.L379
 4776              	.L441:
2994:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4777              		.loc 1 2994 0
 4778 2aa8 0300A0E1 		mov	r0, r3
 4779 2aac 330000EA 		b	.L436
 4780              	.L454:
2941:../uvc.c      ****                 switch (bRequest)
 4781              		.loc 1 2941 0
 4782 2ab0 010052E3 		cmp	r2, #1
 4783 2ab4 F3FEFF1A 		bne	.L403
2966:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4784              		.loc 1 2966 0
 4785 2ab8 2000A0E3 		mov	r0, #32
 4786 2abc 94139FE5 		ldr	r1, .L456+44
 4787 2ac0 36208DE2 		add	r2, sp, #54
 4788 2ac4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4789              	.LVL359:
2968:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4790              		.loc 1 2968 0
 4791 2ac8 000050E3 		cmp	r0, #0
 4792 2acc 7AFEFF1A 		bne	.L438
2970:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 4793              		.loc 1 2970 0
 4794 2ad0 2C20D5E5 		ldrb	r2, [r5, #44]	@ zero_extendqisi2
 4795 2ad4 030052E3 		cmp	r2, #3
 4796 2ad8 77FEFF1A 		bne	.L438
2978:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4797              		.loc 1 2978 0
 4798 2adc 8130D5E5 		ldrb	r3, [r5, #129]	@ zero_extendqisi2
2974:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4799              		.loc 1 2974 0
 4800 2ae0 7DE0D5E5 		ldrb	lr, [r5, #125]	@ zero_extendqisi2
2975:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4801              		.loc 1 2975 0
 4802 2ae4 7EC0D5E5 		ldrb	ip, [r5, #126]	@ zero_extendqisi2
2976:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4803              		.loc 1 2976 0
 4804 2ae8 7F00D5E5 		ldrb	r0, [r5, #127]	@ zero_extendqisi2
 4805              	.LVL360:
2977:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4806              		.loc 1 2977 0
 4807 2aec 8010D5E5 		ldrb	r1, [r5, #128]	@ zero_extendqisi2
2979:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4808              		.loc 1 2979 0
 4809 2af0 8290D5E5 		ldrb	r9, [r5, #130]	@ zero_extendqisi2
2978:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4810              		.loc 1 2978 0
 4811 2af4 4D36C6E5 		strb	r3, [r6, #1613]
2974:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4812              		.loc 1 2974 0
 4813 2af8 49E6C6E5 		strb	lr, [r6, #1609]
2975:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4814              		.loc 1 2975 0
 4815 2afc 4AC6C6E5 		strb	ip, [r6, #1610]
2976:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4816              		.loc 1 2976 0
 4817 2b00 4B06C6E5 		strb	r0, [r6, #1611]
2977:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4818              		.loc 1 2977 0
 4819 2b04 4C16C6E5 		strb	r1, [r6, #1612]
2979:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4820              		.loc 1 2979 0
 4821 2b08 4E96C6E5 		strb	r9, [r6, #1614]
 4822 2b0c 30309DE5 		ldr	r3, [sp, #48]
 4823 2b10 6AFEFFEA 		b	.L377
 4824              	.LVL361:
 4825              	.L408:
2941:../uvc.c      ****                 switch (bRequest)
 4826              		.loc 1 2941 0
 4827 2b14 860052E3 		cmp	r2, #134
 4828 2b18 E2FFFF0A 		beq	.L441
 4829 2b1c 870052E3 		cmp	r2, #135
 4830 2b20 55FFFF0A 		beq	.L414
 4831 2b24 850052E3 		cmp	r2, #133
 4832 2b28 D6FEFF1A 		bne	.L403
 4833 2b2c AAFFFFEA 		b	.L415
 4834              	.LVL362:
 4835              	.L336:
 4836              	.LBE103:
 4837              	.LBE137:
 4838              	.LBB138:
 4839              	.LBB98:
2502:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 4840              		.loc 1 2502 0
 4841 2b30 0000A0E3 		mov	r0, #0
 4842 2b34 FEFFFFEB 		bl	CTControlHandle
 4843              	.LVL363:
 4844 2b38 30309DE5 		ldr	r3, [sp, #48]
 4845 2b3c 55FEFFEA 		b	.L314
 4846              	.LVL364:
 4847              	.L450:
 4848              	.LBE98:
 4849              	.LBE138:
3222:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4850              		.loc 1 3222 0
 4851 2b40 38139FE5 		ldr	r1, .L456+84
 4852 2b44 0320A0E1 		mov	r2, r3
 4853 2b48 0400A0E3 		mov	r0, #4
 4854              	.LVL365:
 4855 2b4c 1C308DE5 		str	r3, [sp, #28]
 4856 2b50 FEFFFFEB 		bl	CyU3PDebugPrint
 4857              	.LVL366:
 4858              	.LBB139:
 4859              	.LBB140:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 4860              		.loc 1 1214 0
 4861 2b54 1C409DE5 		ldr	r4, [sp, #28]
 4862 2b58 0400A0E3 		mov	r0, #4
 4863 2b5c 20139FE5 		ldr	r1, .L456+88
 4864 2b60 0420A0E1 		mov	r2, r4
 4865 2b64 FEFFFFEB 		bl	CyU3PDebugPrint
 4866              	.LVL367:
 4867              	.L431:
 4868 2b68 FEFFFFEA 		b	.L431
 4869              	.LVL368:
 4870              	.L399:
 4871              	.LBE140:
 4872              	.LBE139:
 4873              	.LBB141:
 4874              	.LBB109:
2885:../uvc.c      ****             switch (bRequest)
 4875              		.loc 1 2885 0
 4876 2b6c 850053E3 		cmp	r3, #133
 4877 2b70 99FFFF0A 		beq	.L415
 4878 2b74 860053E3 		cmp	r3, #134
 4879 2b78 C2FEFF1A 		bne	.L403
 4880              	.L442:
2889:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4881              		.loc 1 2889 0
 4882 2b7c 0100A0E3 		mov	r0, #1
 4883              	.L436:
2888:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4884              		.loc 1 2888 0
 4885 2b80 0330A0E3 		mov	r3, #3
 4886 2b84 5830C4E5 		strb	r3, [r4, #88]
2889:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4887              		.loc 1 2889 0
 4888 2b88 EC129FE5 		ldr	r1, .L456+80
 4889 2b8c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4890 2b90 30309DE5 		ldr	r3, [sp, #48]
 4891 2b94 49FEFFEA 		b	.L377
 4892              	.LVL369:
 4893              	.L327:
 4894              	.LBE109:
 4895              	.LBE141:
 4896              	.LBB142:
 4897              	.LBB90:
2450:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 4898              		.loc 1 2450 0
 4899 2b98 0600A0E3 		mov	r0, #6
 4900 2b9c FEFFFFEB 		bl	ControlHandle
 4901              	.LVL370:
 4902 2ba0 30309DE5 		ldr	r3, [sp, #48]
 4903 2ba4 3BFEFFEA 		b	.L314
 4904              	.L334:
2423:../uvc.c      ****     switch (wValue)
 4905              		.loc 1 2423 0
 4906 2ba8 0D0C52E3 		cmp	r2, #3328
 4907 2bac 0700000A 		beq	.L329
 4908 2bb0 0E0C52E3 		cmp	r2, #3584
 4909 2bb4 0900000A 		beq	.L331
 4910 2bb8 030B52E3 		cmp	r2, #3072
 4911 2bbc 2CFEFF1A 		bne	.L335
 4912              	.LVL371:
2464:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4913              		.loc 1 2464 0
 4914 2bc0 0B00A0E3 		mov	r0, #11
 4915 2bc4 FEFFFFEB 		bl	ControlHandle
 4916              	.LVL372:
 4917 2bc8 30309DE5 		ldr	r3, [sp, #48]
 4918 2bcc 31FEFFEA 		b	.L314
 4919              	.L329:
 4920              	.LVL373:
2460:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 4921              		.loc 1 2460 0
 4922 2bd0 0900A0E3 		mov	r0, #9
 4923 2bd4 FEFFFFEB 		bl	ControlHandle
 4924              	.LVL374:
 4925 2bd8 30309DE5 		ldr	r3, [sp, #48]
 4926 2bdc 2DFEFFEA 		b	.L314
 4927              	.L331:
 4928              	.LVL375:
2468:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 4929              		.loc 1 2468 0
 4930 2be0 0E00A0E3 		mov	r0, #14
 4931 2be4 FEFFFFEB 		bl	ControlHandle
 4932              	.LVL376:
 4933 2be8 30309DE5 		ldr	r3, [sp, #48]
 4934 2bec 29FEFFEA 		b	.L314
 4935              	.L333:
2423:../uvc.c      ****     switch (wValue)
 4936              		.loc 1 2423 0
 4937 2bf0 010B52E3 		cmp	r2, #1024
 4938 2bf4 27FEFF0A 		beq	.L314
 4939 2bf8 050C52E3 		cmp	r2, #1280
 4940 2bfc 1CFEFF1A 		bne	.L335
 4941              	.LVL377:
2442:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 4942              		.loc 1 2442 0
 4943 2c00 0400A0E3 		mov	r0, #4
 4944 2c04 FEFFFFEB 		bl	ControlHandle
 4945              	.LVL378:
 4946 2c08 30309DE5 		ldr	r3, [sp, #48]
 4947 2c0c 21FEFFEA 		b	.L314
 4948              	.L324:
 4949              	.LVL379:
2435:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 4950              		.loc 1 2435 0
 4951 2c10 0200A0E3 		mov	r0, #2
 4952 2c14 FEFFFFEB 		bl	ControlHandle
 4953              	.LVL380:
 4954 2c18 30309DE5 		ldr	r3, [sp, #48]
 4955 2c1c 1DFEFFEA 		b	.L314
 4956              	.L326:
 4957              	.LVL381:
2446:../uvc.c      ****      		ControlHandle(HueCtlID5);
 4958              		.loc 1 2446 0
 4959 2c20 0500A0E3 		mov	r0, #5
 4960 2c24 FEFFFFEB 		bl	ControlHandle
 4961              	.LVL382:
 4962 2c28 30309DE5 		ldr	r3, [sp, #48]
 4963 2c2c 19FEFFEA 		b	.L314
 4964              	.LVL383:
 4965              	.L426:
 4966              	.LBE90:
 4967              	.LBE142:
 4968              	.LBB143:
 4969              	.LBB102:
3045:../uvc.c      ****                 switch (bRequest)
 4970              		.loc 1 3045 0
 4971 2c30 850052E3 		cmp	r2, #133
 4972 2c34 3900000A 		beq	.L424
 4973 2c38 860052E3 		cmp	r2, #134
 4974 2c3c 1AFEFF1A 		bne	.L379
 4975 2c40 CDFFFFEA 		b	.L442
 4976              	.LVL384:
 4977              	.L372:
 4978              	.LBE102:
 4979              	.LBE143:
 4980              	.LBB144:
 4981              	.LBB120:
2723:../uvc.c      ****     switch (wValue)
 4982              		.loc 1 2723 0
 4983 2c44 060C52E3 		cmp	r2, #1536
 4984 2c48 3000000A 		beq	.L359
 4985 2c4c 0900008A 		bhi	.L373
 4986 2c50 050C52E3 		cmp	r2, #1280
 4987 2c54 0AFEFF1A 		bne	.L315
 4988              	.LVL385:
2743:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 4989              		.loc 1 2743 0
 4990 2c58 1400A0E3 		mov	r0, #20
 4991 2c5c FEFFFFEB 		bl	ControlHandle
 4992              	.LVL386:
 4993 2c60 30309DE5 		ldr	r3, [sp, #48]
 4994 2c64 0BFEFFEA 		b	.L314
 4995              	.L342:
 4996              	.LVL387:
 4997              	.LBE120:
 4998              	.LBE144:
 4999              	.LBB145:
 5000              	.LBB92:
2528:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 5001              		.loc 1 2528 0
 5002 2c68 0600A0E3 		mov	r0, #6
 5003 2c6c FEFFFFEB 		bl	CTControlHandle
 5004              	.LVL388:
 5005 2c70 30309DE5 		ldr	r3, [sp, #48]
 5006 2c74 07FEFFEA 		b	.L314
 5007              	.L373:
 5008              	.LBE92:
 5009              	.LBE145:
 5010              	.LBB146:
 5011              	.LBB115:
2723:../uvc.c      ****     switch (wValue)
 5012              		.loc 1 2723 0
 5013 2c78 070C52E3 		cmp	r2, #1792
 5014 2c7c 1B00000A 		beq	.L360
 5015 2c80 020B52E3 		cmp	r2, #2048
 5016 2c84 FEFDFF1A 		bne	.L315
 5017              	.LVL389:
2755:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 5018              		.loc 1 2755 0
 5019 2c88 1700A0E3 		mov	r0, #23
 5020 2c8c FEFFFFEB 		bl	ControlHandle
 5021              	.LVL390:
 5022 2c90 30309DE5 		ldr	r3, [sp, #48]
 5023 2c94 FFFDFFEA 		b	.L314
 5024              	.L349:
 5025              	.LBE115:
 5026              	.LBE146:
 5027              	.LBB147:
 5028              	.LBB99:
2498:../uvc.c      ****     switch (wValue)
 5029              		.loc 1 2498 0
 5030 2c98 0B0C52E3 		cmp	r2, #2816
 5031 2c9c 0F00000A 		beq	.L345
 5032 2ca0 030B52E3 		cmp	r2, #3072
 5033 2ca4 0900000A 		beq	.L346
 5034 2ca8 0A0C52E3 		cmp	r2, #2560
 5035 2cac F0FDFF1A 		bne	.L335
 5036              	.LVL391:
2539:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 5037              		.loc 1 2539 0
 5038 2cb0 0800A0E3 		mov	r0, #8
 5039 2cb4 FEFFFFEB 		bl	CTControlHandle
 5040              	.LVL392:
 5041 2cb8 30309DE5 		ldr	r3, [sp, #48]
 5042 2cbc F5FDFFEA 		b	.L314
 5043              	.L343:
 5044              	.LVL393:
2534:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5045              		.loc 1 2534 0
 5046 2cc0 0700A0E3 		mov	r0, #7
 5047 2cc4 FEFFFFEB 		bl	CTControlHandle
 5048              	.LVL394:
 5049 2cc8 30309DE5 		ldr	r3, [sp, #48]
 5050 2ccc F1FDFFEA 		b	.L314
 5051              	.L346:
 5052              	.LVL395:
2547:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 5053              		.loc 1 2547 0
 5054 2cd0 0A00A0E3 		mov	r0, #10
 5055 2cd4 FEFFFFEB 		bl	CTControlHandle
 5056              	.LVL396:
 5057 2cd8 30309DE5 		ldr	r3, [sp, #48]
 5058 2cdc EDFDFFEA 		b	.L314
 5059              	.L345:
 5060              	.LVL397:
2543:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 5061              		.loc 1 2543 0
 5062 2ce0 0900A0E3 		mov	r0, #9
 5063 2ce4 FEFFFFEB 		bl	CTControlHandle
 5064              	.LVL398:
 5065 2ce8 30309DE5 		ldr	r3, [sp, #48]
 5066 2cec E9FDFFEA 		b	.L314
 5067              	.L360:
 5068              	.LVL399:
 5069              	.LBE99:
 5070              	.LBE147:
 5071              	.LBB148:
 5072              	.LBB121:
2751:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5073              		.loc 1 2751 0
 5074 2cf0 1600A0E3 		mov	r0, #22
 5075 2cf4 FEFFFFEB 		bl	ControlHandle
 5076              	.LVL400:
 5077 2cf8 30309DE5 		ldr	r3, [sp, #48]
 5078 2cfc E5FDFFEA 		b	.L314
 5079              	.L453:
 5080              	.LVL401:
2764:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 5081              		.loc 1 2764 0
 5082 2d00 1900A0E3 		mov	r0, #25
 5083 2d04 FEFFFFEB 		bl	ControlHandle
 5084              	.LVL402:
 5085 2d08 30309DE5 		ldr	r3, [sp, #48]
 5086 2d0c E1FDFFEA 		b	.L314
 5087              	.L359:
 5088              	.LVL403:
2747:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5089              		.loc 1 2747 0
 5090 2d10 1500A0E3 		mov	r0, #21
 5091 2d14 FEFFFFEB 		bl	ControlHandle
 5092              	.LVL404:
 5093 2d18 30309DE5 		ldr	r3, [sp, #48]
 5094 2d1c DDFDFFEA 		b	.L314
 5095              	.LVL405:
 5096              	.L424:
 5097              	.LBE121:
 5098              	.LBE148:
 5099              	.LBB149:
 5100              	.LBB110:
3054:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5101              		.loc 1 3054 0
 5102 2d20 54119FE5 		ldr	r1, .L456+80
 5103 2d24 0200A0E3 		mov	r0, #2
 5104              	.L439:
3053:../uvc.c      ****                         glEp0Buffer[1] = 0;
 5105              		.loc 1 3053 0
 5106 2d28 0090A0E3 		mov	r9, #0
3052:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 5107              		.loc 1 3052 0
 5108 2d2c 5830C4E5 		strb	r3, [r4, #88]
3053:../uvc.c      ****                         glEp0Buffer[1] = 0;
 5109              		.loc 1 3053 0
 5110 2d30 5990C4E5 		strb	r9, [r4, #89]
3054:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5111              		.loc 1 3054 0
 5112 2d34 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5113 2d38 30309DE5 		ldr	r3, [sp, #48]
 5114 2d3c DFFDFFEA 		b	.L377
 5115              	.LVL406:
 5116              	.L369:
 5117              	.LBE110:
 5118              	.LBE149:
 5119              	.LBB150:
 5120              	.LBB114:
2794:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
 5121              		.loc 1 2794 0
 5122 2d40 2100A0E3 		mov	r0, #33
 5123 2d44 FEFFFFEB 		bl	ControlHandle
 5124              	.LVL407:
 5125 2d48 30309DE5 		ldr	r3, [sp, #48]
 5126 2d4c D1FDFFEA 		b	.L314
 5127              	.L368:
 5128              	.LVL408:
2790:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
 5129              		.loc 1 2790 0
 5130 2d50 2000A0E3 		mov	r0, #32
 5131 2d54 FEFFFFEB 		bl	ControlHandle
 5132              	.LVL409:
 5133 2d58 30309DE5 		ldr	r3, [sp, #48]
 5134 2d5c CDFDFFEA 		b	.L314
 5135              	.LVL410:
 5136              	.L451:
 5137              	.LBE114:
 5138              	.LBE150:
 5139              	.LBB151:
 5140              	.LBB101:
2910:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5141              		.loc 1 2910 0
 5142 2d60 2000A0E3 		mov	r0, #32
 5143 2d64 EC109FE5 		ldr	r1, .L456+44
 5144 2d68 36208DE2 		add	r2, sp, #54
 5145 2d6c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5146              	.LVL411:
2912:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5147              		.loc 1 2912 0
 5148 2d70 000050E3 		cmp	r0, #0
 5149 2d74 D0FDFF1A 		bne	.L438
2925:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5150              		.loc 1 2925 0
 5151 2d78 0020A0E3 		mov	r2, #0
 5152 2d7c A8009FE5 		ldr	r0, .L456
 5153              	.LVL412:
 5154 2d80 0110A0E3 		mov	r1, #1
 5155 2d84 FEFFFFEB 		bl	_txe_event_flags_set
 5156              	.LVL413:
2926:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5157              		.loc 1 2926 0
 5158 2d88 002050E2 		subs	r2, r0, #0
 5159 2d8c CAFDFF0A 		beq	.L438
 5160              	.L420:
3033:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 5161              		.loc 1 3033 0
 5162 2d90 0400A0E3 		mov	r0, #4
 5163              	.LVL414:
 5164 2d94 EC109FE5 		ldr	r1, .L456+92
 5165 2d98 FEFFFFEB 		bl	CyU3PDebugPrint
 5166              	.LVL415:
 5167 2d9c 30309DE5 		ldr	r3, [sp, #48]
 5168 2da0 C6FDFFEA 		b	.L377
 5169              	.L356:
 5170              	.LVL416:
 5171              	.LBE101:
 5172              	.LBE151:
 5173              	.LBB152:
 5174              	.LBB122:
2735:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5175              		.loc 1 2735 0
 5176 2da4 1200A0E3 		mov	r0, #18
 5177 2da8 FEFFFFEB 		bl	ControlHandle
 5178              	.LVL417:
 5179 2dac 30309DE5 		ldr	r3, [sp, #48]
 5180 2db0 B8FDFFEA 		b	.L314
 5181              	.L365:
 5182              	.LVL418:
2774:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5183              		.loc 1 2774 0
 5184 2db4 1C00A0E3 		mov	r0, #28
 5185 2db8 FEFFFFEB 		bl	ControlHandle
 5186              	.LVL419:
 5187 2dbc 30309DE5 		ldr	r3, [sp, #48]
 5188 2dc0 B4FDFFEA 		b	.L314
 5189              	.L364:
 5190              	.LVL420:
2770:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5191              		.loc 1 2770 0
 5192 2dc4 1A00A0E3 		mov	r0, #26
 5193 2dc8 FEFFFFEB 		bl	ControlHandle
 5194              	.LVL421:
 5195 2dcc 30309DE5 		ldr	r3, [sp, #48]
 5196 2dd0 B0FDFFEA 		b	.L314
 5197              	.L366:
 5198              	.LVL422:
2782:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5199              		.loc 1 2782 0
 5200 2dd4 1E00A0E3 		mov	r0, #30
 5201 2dd8 FEFFFFEB 		bl	ControlHandle
 5202              	.LVL423:
 5203 2ddc 30309DE5 		ldr	r3, [sp, #48]
 5204 2de0 ACFDFFEA 		b	.L314
 5205              	.L355:
 5206              	.LVL424:
2731:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5207              		.loc 1 2731 0
 5208 2de4 1100A0E3 		mov	r0, #17
 5209 2de8 FEFFFFEB 		bl	ControlHandle
 5210              	.LVL425:
 5211 2dec 30309DE5 		ldr	r3, [sp, #48]
 5212 2df0 A8FDFFEA 		b	.L314
 5213              	.L362:
 5214              	.LVL426:
2759:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5215              		.loc 1 2759 0
 5216 2df4 1800A0E3 		mov	r0, #24
 5217 2df8 FEFFFFEB 		bl	ControlHandle
 5218              	.LVL427:
 5219 2dfc 30309DE5 		ldr	r3, [sp, #48]
 5220 2e00 A4FDFFEA 		b	.L314
 5221              	.L357:
 5222              	.LVL428:
2739:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5223              		.loc 1 2739 0
 5224 2e04 1300A0E3 		mov	r0, #19
 5225 2e08 FEFFFFEB 		bl	ControlHandle
 5226              	.LVL429:
 5227 2e0c 30309DE5 		ldr	r3, [sp, #48]
 5228 2e10 A0FDFFEA 		b	.L314
 5229              	.LVL430:
 5230              	.L428:
 5231              	.LBE122:
 5232              	.LBE152:
 5233              	.LBB153:
 5234              	.LBB111:
3084:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5235              		.loc 1 3084 0
 5236 2e14 70109FE5 		ldr	r1, .L456+96
 5237 2e18 B623DDE1 		ldrh	r2, [sp, #54]
 5238 2e1c 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 5239 2e20 0400A0E3 		mov	r0, #4
 5240              	.LVL431:
 5241 2e24 FEFFFFEB 		bl	CyU3PDebugPrint
 5242 2e28 9FFDFFEA 		b	.L379
 5243              	.L457:
 5244              		.align	2
 5245              	.L456:
 5246 2e2c 00000000 		.word	.LANCHOR0
 5247 2e30 00000000 		.word	.LANCHOR1
 5248 2e34 00000000 		.word	bRequest
 5249 2e38 00000000 		.word	wValue
 5250 2e3c 00000000 		.word	wIndex
 5251 2e40 00000000 		.word	glInterStaBuffer
 5252 2e44 08050000 		.word	.LC27
 5253 2e48 00000000 		.word	glChHandleInterStat
 5254 2e4c 00000000 		.word	bmReqType
 5255 2e50 00000000 		.word	wLength
 5256 2e54 8C040000 		.word	.LC26
 5257 2e58 7C000000 		.word	.LANCHOR0+124
 5258 2e5c 10060000 		.word	.LC32
 5259 2e60 34050000 		.word	.LC28
 5260 2e64 48060000 		.word	.LANCHOR1+1608
 5261 2e68 54060000 		.word	.LANCHOR1+1620
 5262 2e6c 10060000 		.word	.LANCHOR1+1552
 5263 2e70 2C060000 		.word	.LANCHOR1+1580
 5264 2e74 74050000 		.word	.LC29
 5265 2e78 AC050000 		.word	.LC30
 5266 2e7c 58000000 		.word	.LANCHOR0+88
 5267 2e80 60060000 		.word	.LC34
 5268 2e84 80000000 		.word	.LC4
 5269 2e88 E8050000 		.word	.LC31
 5270 2e8c 38060000 		.word	.LC33
 5271              	.LBE111:
 5272              	.LBE153:
 5273              		.cfi_endproc
 5274              	.LFE24:
 5276              		.align	2
 5277              		.global	CamDefSet
 5279              	CamDefSet:
 5280              	.LFB4:
1111:../uvc.c      **** {
 5281              		.loc 1 1111 0
 5282              		.cfi_startproc
 5283              		@ args = 0, pretend = 0, frame = 24
 5284              		@ frame_needed = 0, uses_anonymous_args = 0
 5285              	.LVL432:
 5286 2e90 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5287              	.LCFI19:
 5288              		.cfi_def_cfa_offset 36
1117:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5289              		.loc 1 1117 0
 5290 2e94 AC429FE5 		ldr	r4, .L461
 5291              		.cfi_offset 14, -4
 5292              		.cfi_offset 11, -8
 5293              		.cfi_offset 10, -12
 5294              		.cfi_offset 9, -16
 5295              		.cfi_offset 8, -20
 5296              		.cfi_offset 7, -24
 5297              		.cfi_offset 6, -28
 5298              		.cfi_offset 5, -32
 5299              		.cfi_offset 4, -36
1122:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5300              		.loc 1 1122 0
 5301 2e98 AC229FE5 		ldr	r2, .L461+4
1119:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5302              		.loc 1 1119 0
 5303 2e9c A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1111:../uvc.c      **** {
 5304              		.loc 1 1111 0
 5305 2ea0 2CD04DE2 		sub	sp, sp, #44
 5306              	.LCFI20:
 5307              		.cfi_def_cfa_offset 80
1122:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5308              		.loc 1 1122 0
 5309 2ea4 1C0092E5 		ldr	r0, [r2, #28]
 5310 2ea8 0010E0E3 		mvn	r1, #0
1124:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5311              		.loc 1 1124 0
 5312 2eac 2963A0E1 		mov	r6, r9, lsr #6
1118:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5313              		.loc 1 1118 0
 5314 2eb0 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1117:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5315              		.loc 1 1117 0
 5316 2eb4 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5317              	.LVL433:
1122:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5318              		.loc 1 1122 0
 5319 2eb8 FEFFFFEB 		bl	_txe_mutex_get
1123:../uvc.c      ****     if(Data1&0x80){
 5320              		.loc 1 1123 0
 5321 2ebc 800019E3 		tst	r9, #128
1124:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5322              		.loc 1 1124 0
 5323 2ec0 01600612 		andne	r6, r6, #1
 5324 2ec4 0660E011 		mvnne	r6, r6
 5325 2ec8 3B600612 		andne	r6, r6, #59
 5326 2ecc 0660E011 		mvnne	r6, r6
 5327 2ed0 FF600612 		andne	r6, r6, #255
 5328              	.LVL434:
1126:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5329              		.loc 1 1126 0
 5330 2ed4 C6608603 		orreq	r6, r6, #198
 5331              	.LVL435:
1130:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5332              		.loc 1 1130 0
 5333 2ed8 0080A0E3 		mov	r8, #0
 5334 2edc 0A20A0E1 		mov	r2, sl
 5335 2ee0 0730A0E1 		mov	r3, r7
 5336 2ee4 0110A0E3 		mov	r1, #1
1128:../uvc.c      ****     Data0 = (Data0 << 2);
 5337              		.loc 1 1128 0
 5338 2ee8 0951A0E1 		mov	r5, r9, asl #2
1130:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5339              		.loc 1 1130 0
 5340 2eec 58029FE5 		ldr	r0, .L461+4
1133:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5341              		.loc 1 1133 0
 5342 2ef0 0190A0E3 		mov	r9, #1
 5343              	.LVL436:
1128:../uvc.c      ****     Data0 = (Data0 << 2);
 5344              		.loc 1 1128 0
 5345 2ef4 FF5005E2 		and	r5, r5, #255
 5346              	.LVL437:
1130:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5347              		.loc 1 1130 0
 5348 2ef8 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5349 2efc FEFFFFEB 		bl	cmdSet
 5350              	.LVL438:
1133:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5351              		.loc 1 1133 0
 5352 2f00 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5353 2f04 0910A0E1 		mov	r1, r9
 5354 2f08 0730A0E1 		mov	r3, r7
 5355 2f0c 38029FE5 		ldr	r0, .L461+4
 5356 2f10 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5357 2f14 FEFFFFEB 		bl	cmdSet
 5358              	.LVL439:
1136:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5359              		.loc 1 1136 0
 5360 2f18 0620A0E1 		mov	r2, r6
 5361 2f1c 0530A0E1 		mov	r3, r5
 5362 2f20 28129FE5 		ldr	r1, .L461+8
 5363 2f24 0400A0E3 		mov	r0, #4
1135:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5364              		.loc 1 1135 0
 5365 2f28 A661C4E5 		strb	r6, [r4, #422]
1134:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5366              		.loc 1 1134 0
 5367 2f2c A551C4E5 		strb	r5, [r4, #421]
1136:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5368              		.loc 1 1136 0
 5369 2f30 FEFFFFEB 		bl	CyU3PDebugPrint
 5370              	.LVL440:
1141:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5371              		.loc 1 1141 0
 5372 2f34 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5373              	.LVL441:
1142:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5374              		.loc 1 1142 0
 5375 2f38 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5376 2f3c BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5377 2f40 0210A0E3 		mov	r1, #2
 5378 2f44 00029FE5 		ldr	r0, .L461+4
 5379 2f48 00B08DE5 		str	fp, [sp, #0]
 5380 2f4c 04808DE5 		str	r8, [sp, #4]
 5381 2f50 FEFFFFEB 		bl	cmdSet
 5382              	.LVL442:
1144:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5383              		.loc 1 1144 0
 5384 2f54 0B20A0E1 		mov	r2, fp
 5385 2f58 0530A0E1 		mov	r3, r5
 5386 2f5c EC119FE5 		ldr	r1, .L461+8
 5387 2f60 0400A0E3 		mov	r0, #4
1143:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5388              		.loc 1 1143 0
 5389 2f64 BD51C4E5 		strb	r5, [r4, #445]
1144:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5390              		.loc 1 1144 0
 5391 2f68 FEFFFFEB 		bl	CyU3PDebugPrint
 5392              	.LVL443:
1149:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5393              		.loc 1 1149 0
 5394 2f6c 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1148:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5395              		.loc 1 1148 0
 5396 2f70 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5397              	.LVL444:
1150:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5398              		.loc 1 1150 0
 5399 2f74 80B047E2 		sub	fp, r7, #128
 5400 2f78 FF100BE2 		and	r1, fp, #255
 5401 2f7c 14108DE5 		str	r1, [sp, #20]
 5402 2f80 14C09DE5 		ldr	ip, [sp, #20]
1151:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5403              		.loc 1 1151 0
 5404 2f84 760047E2 		sub	r0, r7, #118
1152:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5405              		.loc 1 1152 0
 5406 2f88 7EE087E2 		add	lr, r7, #126
1150:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5407              		.loc 1 1150 0
 5408 2f8c 0630A0E1 		mov	r3, r6
1151:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5409              		.loc 1 1151 0
 5410 2f90 18008DE5 		str	r0, [sp, #24]
1150:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5411              		.loc 1 1150 0
 5412 2f94 0510A0E3 		mov	r1, #5
 5413 2f98 DF20A0E3 		mov	r2, #223
 5414 2f9c A8019FE5 		ldr	r0, .L461+4
1152:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5415              		.loc 1 1152 0
 5416 2fa0 1CE08DE5 		str	lr, [sp, #28]
1150:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5417              		.loc 1 1150 0
 5418 2fa4 00C08DE5 		str	ip, [sp, #0]
 5419 2fa8 04808DE5 		str	r8, [sp, #4]
 5420 2fac FEFFFFEB 		bl	cmdSet
 5421              	.LVL445:
1151:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5422              		.loc 1 1151 0
 5423 2fb0 18A09DE5 		ldr	sl, [sp, #24]
1153:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5424              		.loc 1 1153 0
 5425 2fb4 72E087E2 		add	lr, r7, #114
1151:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5426              		.loc 1 1151 0
 5427 2fb8 FFC00AE2 		and	ip, sl, #255
 5428 2fbc 0630A0E1 		mov	r3, r6
 5429 2fc0 0510A0E3 		mov	r1, #5
 5430 2fc4 DC20A0E3 		mov	r2, #220
 5431 2fc8 7C019FE5 		ldr	r0, .L461+4
1153:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5432              		.loc 1 1153 0
 5433 2fcc 20E08DE5 		str	lr, [sp, #32]
1151:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5434              		.loc 1 1151 0
 5435 2fd0 00C08DE5 		str	ip, [sp, #0]
 5436 2fd4 04908DE5 		str	r9, [sp, #4]
 5437 2fd8 FEFFFFEB 		bl	cmdSet
1152:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5438              		.loc 1 1152 0
 5439 2fdc 1C009DE5 		ldr	r0, [sp, #28]
 5440 2fe0 02E0A0E3 		mov	lr, #2
 5441 2fe4 FFC000E2 		and	ip, r0, #255
 5442 2fe8 0630A0E1 		mov	r3, r6
1154:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5443              		.loc 1 1154 0
 5444 2fec 6FA047E2 		sub	sl, r7, #111
1152:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5445              		.loc 1 1152 0
 5446 2ff0 0510A0E3 		mov	r1, #5
 5447 2ff4 DE20A0E3 		mov	r2, #222
 5448 2ff8 4C019FE5 		ldr	r0, .L461+4
 5449 2ffc 04E08DE5 		str	lr, [sp, #4]
1154:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5450              		.loc 1 1154 0
 5451 3000 24A08DE5 		str	sl, [sp, #36]
1152:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5452              		.loc 1 1152 0
 5453 3004 00C08DE5 		str	ip, [sp, #0]
 5454 3008 FEFFFFEB 		bl	cmdSet
1153:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5455              		.loc 1 1153 0
 5456 300c 20A09DE5 		ldr	sl, [sp, #32]
 5457 3010 0630A0E1 		mov	r3, r6
 5458 3014 FFC00AE2 		and	ip, sl, #255
 5459 3018 00C08DE5 		str	ip, [sp, #0]
 5460 301c 0510A0E3 		mov	r1, #5
 5461 3020 03C0A0E3 		mov	ip, #3
 5462 3024 E020A0E3 		mov	r2, #224
 5463 3028 1C019FE5 		ldr	r0, .L461+4
 5464 302c 04C08DE5 		str	ip, [sp, #4]
 5465 3030 FEFFFFEB 		bl	cmdSet
1154:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5466              		.loc 1 1154 0
 5467 3034 24009DE5 		ldr	r0, [sp, #36]
 5468 3038 04A0A0E3 		mov	sl, #4
 5469 303c FFC000E2 		and	ip, r0, #255
 5470 3040 0630A0E1 		mov	r3, r6
 5471 3044 0510A0E3 		mov	r1, #5
 5472 3048 DD20A0E3 		mov	r2, #221
 5473 304c F8009FE5 		ldr	r0, .L461+4
 5474 3050 00C08DE5 		str	ip, [sp, #0]
1155:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5475              		.loc 1 1155 0
 5476 3054 7F7087E2 		add	r7, r7, #127
 5477              	.LVL446:
1154:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5478              		.loc 1 1154 0
 5479 3058 04A08DE5 		str	sl, [sp, #4]
 5480 305c FEFFFFEB 		bl	cmdSet
1155:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5481              		.loc 1 1155 0
 5482 3060 05E0A0E3 		mov	lr, #5
 5483 3064 0E10A0E1 		mov	r1, lr
 5484 3068 0630A0E1 		mov	r3, r6
 5485 306c E120A0E3 		mov	r2, #225
 5486 3070 FF6007E2 		and	r6, r7, #255
 5487              	.LVL447:
 5488 3074 D0009FE5 		ldr	r0, .L461+4
 5489 3078 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5490 307c FEFFFFEB 		bl	cmdSet
 5491              	.LVL448:
1156:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5492              		.loc 1 1156 0
 5493 3080 14C09DE5 		ldr	ip, [sp, #20]
1157:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5494              		.loc 1 1157 0
 5495 3084 24E09DE5 		ldr	lr, [sp, #36]
 5496 3088 1C609DE5 		ldr	r6, [sp, #28]
1156:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5497              		.loc 1 1156 0
 5498 308c 05C2C4E5 		strb	ip, [r4, #517]
1157:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5499              		.loc 1 1157 0
 5500 3090 20C09DE5 		ldr	ip, [sp, #32]
 5501 3094 0B20A0E1 		mov	r2, fp
 5502 3098 18309DE5 		ldr	r3, [sp, #24]
 5503 309c B0109FE5 		ldr	r1, .L461+12
 5504 30a0 0A00A0E1 		mov	r0, sl
 5505 30a4 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5506 30a8 0C708DE5 		str	r7, [sp, #12]
 5507 30ac FEFFFFEB 		bl	CyU3PDebugPrint
 5508              	.LVL449:
1161:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5509              		.loc 1 1161 0
 5510 30b0 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5511              	.LVL450:
1162:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5512              		.loc 1 1162 0
 5513 30b4 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5514              	.LVL451:
1163:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5515              		.loc 1 1163 0
 5516 30b8 0730A0E1 		mov	r3, r7
 5517 30bc 0610A0E3 		mov	r1, #6
 5518 30c0 8520A0E3 		mov	r2, #133
 5519 30c4 80009FE5 		ldr	r0, .L461+4
 5520 30c8 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5521 30cc FEFFFFEB 		bl	cmdSet
1164:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5522              		.loc 1 1164 0
 5523 30d0 0730A0E1 		mov	r3, r7
 5524 30d4 0610A0E3 		mov	r1, #6
 5525 30d8 8620A0E3 		mov	r2, #134
 5526 30dc 68009FE5 		ldr	r0, .L461+4
 5527 30e0 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5528 30e4 FEFFFFEB 		bl	cmdSet
1166:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5529              		.loc 1 1166 0
 5530 30e8 0620A0E1 		mov	r2, r6
 5531 30ec 0530A0E1 		mov	r3, r5
 5532 30f0 58109FE5 		ldr	r1, .L461+8
 5533 30f4 0A00A0E1 		mov	r0, sl
1165:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5534              		.loc 1 1165 0
 5535 30f8 1D62C4E5 		strb	r6, [r4, #541]
1166:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5536              		.loc 1 1166 0
 5537 30fc FEFFFFEB 		bl	CyU3PDebugPrint
 5538              	.LVL452:
1171:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5539              		.loc 1 1171 0
 5540 3100 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5541              	.LVL453:
1172:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5542              		.loc 1 1172 0
 5543 3104 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5544 3108 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5545 310c 0710A0E3 		mov	r1, #7
 5546 3110 34009FE5 		ldr	r0, .L461+4
 5547 3114 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5548 3118 FEFFFFEB 		bl	cmdSet
 5549              	.LVL454:
1174:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5550              		.loc 1 1174 0
 5551 311c 0530A0E1 		mov	r3, r5
 5552 3120 0A00A0E1 		mov	r0, sl
 5553 3124 24109FE5 		ldr	r1, .L461+8
 5554 3128 0620A0E1 		mov	r2, r6
1173:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5555              		.loc 1 1173 0
 5556 312c 3552C4E5 		strb	r5, [r4, #565]
1174:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5557              		.loc 1 1174 0
 5558 3130 FEFFFFEB 		bl	CyU3PDebugPrint
1176:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5559              		.loc 1 1176 0
 5560 3134 10309FE5 		ldr	r3, .L461+4
 5561 3138 1C0093E5 		ldr	r0, [r3, #28]
1179:../uvc.c      **** }
 5562              		.loc 1 1179 0
 5563 313c 2CD08DE2 		add	sp, sp, #44
 5564 3140 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1176:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5565              		.loc 1 1176 0
 5566 3144 FEFFFFEA 		b	_txe_mutex_put
 5567              	.L462:
 5568              		.align	2
 5569              	.L461:
 5570 3148 00000000 		.word	.LANCHOR1
 5571 314c 00000000 		.word	cmdQu
 5572 3150 94060000 		.word	.LC35
 5573 3154 B4060000 		.word	.LC36
 5574              		.cfi_endproc
 5575              	.LFE4:
 5577              		.align	2
 5578              		.global	CyFxUVCAddHeader
 5580              	CyFxUVCAddHeader:
 5581              	.LFB5:
1187:../uvc.c      **** {
 5582              		.loc 1 1187 0
 5583              		.cfi_startproc
 5584              		@ args = 0, pretend = 0, frame = 0
 5585              		@ frame_needed = 0, uses_anonymous_args = 0
 5586              	.LVL455:
 5587 3158 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5588              	.LCFI21:
 5589              		.cfi_def_cfa_offset 16
1189:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5590              		.loc 1 1189 0
 5591 315c 0C20A0E3 		mov	r2, #12
1187:../uvc.c      **** {
 5592              		.loc 1 1187 0
 5593 3160 0150A0E1 		mov	r5, r1
 5594              		.cfi_offset 14, -4
 5595              		.cfi_offset 5, -8
 5596              		.cfi_offset 4, -12
 5597              		.cfi_offset 3, -16
1189:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5598              		.loc 1 1189 0
 5599 3164 18109FE5 		ldr	r1, .L465
 5600              	.LVL456:
1187:../uvc.c      **** {
 5601              		.loc 1 1187 0
 5602 3168 0040A0E1 		mov	r4, r0
1189:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5603              		.loc 1 1189 0
 5604 316c FEFFFFEB 		bl	CyU3PMemCopy
 5605              	.LVL457:
1192:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5606              		.loc 1 1192 0
 5607 3170 020015E3 		tst	r5, #2
1194:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5608              		.loc 1 1194 0
 5609 3174 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5610 3178 02308313 		orrne	r3, r3, #2
 5611 317c 0130C415 		strneb	r3, [r4, #1]
 5612 3180 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5613              	.L466:
 5614              		.align	2
 5615              	.L465:
 5616 3184 80040000 		.word	.LANCHOR1+1152
 5617              		.cfi_endproc
 5618              	.LFE5:
 5620              		.align	2
 5621              		.global	CyFxAppErrorHandler
 5623              	CyFxAppErrorHandler:
 5624              	.LFB6:
1204:../uvc.c      **** {
 5625              		.loc 1 1204 0
 5626              		.cfi_startproc
 5627              		@ args = 0, pretend = 0, frame = 0
 5628              		@ frame_needed = 0, uses_anonymous_args = 0
 5629              	.LVL458:
 5630 3188 0020A0E1 		mov	r2, r0
 5631 318c 08402DE9 		stmfd	sp!, {r3, lr}
 5632              	.LCFI22:
 5633              		.cfi_def_cfa_offset 8
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 5634              		.loc 1 1214 0
 5635 3190 08109FE5 		ldr	r1, .L469
 5636 3194 0400A0E3 		mov	r0, #4
 5637              	.LVL459:
 5638              		.cfi_offset 14, -4
 5639              		.cfi_offset 3, -8
 5640 3198 FEFFFFEB 		bl	CyU3PDebugPrint
 5641              	.LVL460:
 5642              	.L468:
 5643 319c FEFFFFEA 		b	.L468
 5644              	.L470:
 5645              		.align	2
 5646              	.L469:
 5647 31a0 80000000 		.word	.LC4
 5648              		.cfi_endproc
 5649              	.LFE6:
 5651              		.align	2
 5652              		.global	UVCAppThread_Entry
 5654              	UVCAppThread_Entry:
 5655              	.LFB18:
2188:../uvc.c      **** {
 5656              		.loc 1 2188 0
 5657              		.cfi_startproc
 5658              		@ args = 0, pretend = 0, frame = 176
 5659              		@ frame_needed = 0, uses_anonymous_args = 0
 5660              	.LVL461:
 5661 31a4 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5662              	.LCFI23:
 5663              		.cfi_def_cfa_offset 28
 5664 31a8 C4D04DE2 		sub	sp, sp, #196
 5665              	.LCFI24:
 5666              		.cfi_def_cfa_offset 224
 5667              	.LBB214:
 5668              	.LBB215:
1632:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5669              		.loc 1 1632 0
 5670              		.cfi_offset 14, -4
 5671              		.cfi_offset 10, -8
 5672              		.cfi_offset 8, -12
 5673              		.cfi_offset 7, -16
 5674              		.cfi_offset 6, -20
 5675              		.cfi_offset 5, -24
 5676              		.cfi_offset 4, -28
 5677 31ac FEFFFFEB 		bl	CyU3PUartInit
 5678              	.LVL462:
1633:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5679              		.loc 1 1633 0
 5680 31b0 004050E2 		subs	r4, r0, #0
 5681 31b4 4301001A 		bne	.L545
1640:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5682              		.loc 1 1640 0
 5683 31b8 0C2B9FE5 		ldr	r2, .L575
1641:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5684              		.loc 1 1641 0
 5685 31bc 0130A0E3 		mov	r3, #1
1649:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5686              		.loc 1 1649 0
 5687 31c0 0410A0E1 		mov	r1, r4
 5688 31c4 58008DE2 		add	r0, sp, #88
 5689              	.LVL463:
1642:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5690              		.loc 1 1642 0
 5691 31c8 6D40CDE5 		strb	r4, [sp, #109]
1644:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5692              		.loc 1 1644 0
 5693 31cc 5C408DE5 		str	r4, [sp, #92]
1645:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5694              		.loc 1 1645 0
 5695 31d0 60408DE5 		str	r4, [sp, #96]
1640:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5696              		.loc 1 1640 0
 5697 31d4 68208DE5 		str	r2, [sp, #104]
1641:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5698              		.loc 1 1641 0
 5699 31d8 6C30CDE5 		strb	r3, [sp, #108]
1643:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5700              		.loc 1 1643 0
 5701 31dc 58308DE5 		str	r3, [sp, #88]
1646:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5702              		.loc 1 1646 0
 5703 31e0 64308DE5 		str	r3, [sp, #100]
1649:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5704              		.loc 1 1649 0
 5705 31e4 FEFFFFEB 		bl	CyU3PUartSetConfig
 5706              	.LVL464:
1650:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5707              		.loc 1 1650 0
 5708 31e8 004050E2 		subs	r4, r0, #0
 5709 31ec 2D01001A 		bne	.L546
1657:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5710              		.loc 1 1657 0
 5711 31f0 0000E0E3 		mvn	r0, #0
 5712              	.LVL465:
 5713 31f4 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5714              	.LVL466:
1658:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5715              		.loc 1 1658 0
 5716 31f8 004050E2 		subs	r4, r0, #0
 5717 31fc 2101001A 		bne	.L547
1665:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5718              		.loc 1 1665 0
 5719 3200 0300A0E3 		mov	r0, #3
 5720              	.LVL467:
 5721 3204 0410A0E3 		mov	r1, #4
 5722 3208 FEFFFFEB 		bl	CyU3PDebugInit
 5723              	.LVL468:
1666:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5724              		.loc 1 1666 0
 5725 320c 004050E2 		subs	r4, r0, #0
 5726 3210 3401001A 		bne	.L548
1673:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5727              		.loc 1 1673 0
 5728 3214 FEFFFFEB 		bl	CyU3PDebugPreamble
 5729              	.LVL469:
 5730 3218 0640A0E3 		mov	r4, #6
 5731              	.LVL470:
 5732              	.L480:
 5733              	.LBE215:
 5734              	.LBE214:
2203:../uvc.c      **** 		CyU3PThreadSleep(500);
 5735              		.loc 1 2203 0
 5736 321c 7D0FA0E3 		mov	r0, #500
 5737 3220 014044E2 		sub	r4, r4, #1
 5738 3224 FEFFFFEB 		bl	_tx_thread_sleep
2202:../uvc.c      **** 	while (i++ < 6){
 5739              		.loc 1 2202 0
 5740 3228 FF4014E2 		ands	r4, r4, #255
 5741 322c FAFFFF1A 		bne	.L480
 5742              	.LBB225:
 5743              	.LBB226:
1683:../uvc.c      ****     status = CyU3PI2cInit ();
 5744              		.loc 1 1683 0
 5745 3230 FEFFFFEB 		bl	CyU3PI2cInit
 5746              	.LVL471:
1684:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5747              		.loc 1 1684 0
 5748 3234 004050E2 		subs	r4, r0, #0
 5749 3238 8B02001A 		bne	.L549
 5750              	.LVL472:
 5751              	.L481:
1691:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5752              		.loc 1 1691 0
 5753 323c 8CCA9FE5 		ldr	ip, .L575+4
1692:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5754              		.loc 1 1692 0
 5755 3240 0060A0E3 		mov	r6, #0
1693:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5756              		.loc 1 1693 0
 5757 3244 0050E0E3 		mvn	r5, #0
1696:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5758              		.loc 1 1696 0
 5759 3248 94008DE2 		add	r0, sp, #148
 5760 324c 0610A0E1 		mov	r1, r6
1691:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5761              		.loc 1 1691 0
 5762 3250 94C08DE5 		str	ip, [sp, #148]
1692:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5763              		.loc 1 1692 0
 5764 3254 98608DE5 		str	r6, [sp, #152]
1693:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5765              		.loc 1 1693 0
 5766 3258 9C508DE5 		str	r5, [sp, #156]
1694:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5767              		.loc 1 1694 0
 5768 325c B05ACDE1 		strh	r5, [sp, #160]	@ movhi
1696:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5769              		.loc 1 1696 0
 5770 3260 FEFFFFEB 		bl	CyU3PI2cSetConfig
 5771              	.LVL473:
1697:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5772              		.loc 1 1697 0
 5773 3264 004050E2 		subs	r4, r0, #0
 5774 3268 7902001A 		bne	.L550
 5775              	.LVL474:
 5776              	.L482:
 5777              	.LBE226:
 5778              	.LBE225:
 5779              	.LBB228:
 5780              	.LBB230:
1770:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 5781              		.loc 1 1770 0
 5782 326c 606A9FE5 		ldr	r6, .L575+8
 5783 3270 0010A0E3 		mov	r1, #0
 5784 3274 0600A0E1 		mov	r0, r6
 5785 3278 2820A0E3 		mov	r2, #40
 5786 327c FEFFFFEB 		bl	_txe_event_flags_create
 5787              	.LVL475:
1771:../uvc.c      ****     if (apiRetStatus != 0)
 5788              		.loc 1 1771 0
 5789 3280 004050E2 		subs	r4, r0, #0
 5790              	.LVL476:
 5791 3284 6902001A 		bne	.L551
1785:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5792              		.loc 1 1785 0
 5793 3288 0250A0E3 		mov	r5, #2
1792:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5794              		.loc 1 1792 0
 5795 328c 0410A0E1 		mov	r1, r4
1781:../uvc.c      ****     isUsbConnected = CyFalse;
 5796              		.loc 1 1781 0
 5797 3290 444086E5 		str	r4, [r6, #68]
1782:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 5798              		.loc 1 1782 0
 5799 3294 484086E5 		str	r4, [r6, #72]
1788:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5800              		.loc 1 1788 0
 5801 3298 0370A0E3 		mov	r7, #3
1792:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5802              		.loc 1 1792 0
 5803 329c A4008DE2 		add	r0, sp, #164
 5804              	.LVL477:
1787:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 5805              		.loc 1 1787 0
 5806 32a0 AC40CDE5 		strb	r4, [sp, #172]
1789:../uvc.c      ****     gpioClock.halfDiv    = 0;
 5807              		.loc 1 1789 0
 5808 32a4 A8408DE5 		str	r4, [sp, #168]
1785:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5809              		.loc 1 1785 0
 5810 32a8 A450CDE5 		strb	r5, [sp, #164]
1786:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 5811              		.loc 1 1786 0
 5812 32ac A550CDE5 		strb	r5, [sp, #165]
1788:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5813              		.loc 1 1788 0
 5814 32b0 AD70CDE5 		strb	r7, [sp, #173]
1792:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5815              		.loc 1 1792 0
 5816 32b4 FEFFFFEB 		bl	CyU3PGpioInit
 5817              	.LVL478:
1793:../uvc.c      ****     if (apiRetStatus != 0)
 5818              		.loc 1 1793 0
 5819 32b8 004050E2 		subs	r4, r0, #0
 5820 32bc 5202001A 		bne	.L552
1801:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 5821              		.loc 1 1801 0
 5822 32c0 1600A0E3 		mov	r0, #22
 5823              	.LVL479:
 5824 32c4 0110A0E3 		mov	r1, #1
 5825 32c8 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5826              	.LVL480:
1802:../uvc.c      ****     if (apiRetStatus != 0)
 5827              		.loc 1 1802 0
 5828 32cc 004050E2 		subs	r4, r0, #0
 5829 32d0 2102001A 		bne	.L553
1807:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 5830              		.loc 1 1807 0
 5831 32d4 1400A0E3 		mov	r0, #20
 5832              	.LVL481:
 5833 32d8 0110A0E3 		mov	r1, #1
 5834 32dc FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5835              	.LVL482:
1808:../uvc.c      ****     if (apiRetStatus != 0)
 5836              		.loc 1 1808 0
 5837 32e0 004050E2 		subs	r4, r0, #0
 5838 32e4 1302001A 		bne	.L554
1813:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 5839              		.loc 1 1813 0
 5840 32e8 1800A0E3 		mov	r0, #24
 5841              	.LVL483:
 5842 32ec 0110A0E3 		mov	r1, #1
 5843 32f0 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5844              	.LVL484:
1814:../uvc.c      ****     if (apiRetStatus != 0)
 5845              		.loc 1 1814 0
 5846 32f4 004050E2 		subs	r4, r0, #0
 5847 32f8 0502001A 		bne	.L555
1821:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5848              		.loc 1 1821 0
 5849 32fc 0180A0E3 		mov	r8, #1
1826:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5850              		.loc 1 1826 0
 5851 3300 1600A0E3 		mov	r0, #22
 5852              	.LVL485:
 5853 3304 70108DE2 		add	r1, sp, #112
1824:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5854              		.loc 1 1824 0
 5855 3308 7C408DE5 		str	r4, [sp, #124]
1825:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5856              		.loc 1 1825 0
 5857 330c 8040CDE5 		strb	r4, [sp, #128]
1821:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5858              		.loc 1 1821 0
 5859 3310 70808DE5 		str	r8, [sp, #112]
1822:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5860              		.loc 1 1822 0
 5861 3314 74808DE5 		str	r8, [sp, #116]
1823:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5862              		.loc 1 1823 0
 5863 3318 78808DE5 		str	r8, [sp, #120]
1826:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5864              		.loc 1 1826 0
 5865 331c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5866              	.LVL486:
1827:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5867              		.loc 1 1827 0
 5868 3320 004050E2 		subs	r4, r0, #0
 5869 3324 F101001A 		bne	.L556
1840:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5870              		.loc 1 1840 0
 5871 3328 1400A0E3 		mov	r0, #20
 5872              	.LVL487:
 5873 332c 70108DE2 		add	r1, sp, #112
1838:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5874              		.loc 1 1838 0
 5875 3330 7C408DE5 		str	r4, [sp, #124]
1839:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5876              		.loc 1 1839 0
 5877 3334 8040CDE5 		strb	r4, [sp, #128]
1835:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5878              		.loc 1 1835 0
 5879 3338 70808DE5 		str	r8, [sp, #112]
1836:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5880              		.loc 1 1836 0
 5881 333c 74808DE5 		str	r8, [sp, #116]
1837:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5882              		.loc 1 1837 0
 5883 3340 78808DE5 		str	r8, [sp, #120]
1840:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5884              		.loc 1 1840 0
 5885 3344 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5886              	.LVL488:
1841:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5887              		.loc 1 1841 0
 5888 3348 004050E2 		subs	r4, r0, #0
 5889 334c DE01001A 		bne	.L557
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5890              		.loc 1 1854 0
 5891 3350 1800A0E3 		mov	r0, #24
 5892              	.LVL489:
 5893 3354 70108DE2 		add	r1, sp, #112
1849:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 5894              		.loc 1 1849 0
 5895 3358 70408DE5 		str	r4, [sp, #112]
1850:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 5896              		.loc 1 1850 0
 5897 335c 74408DE5 		str	r4, [sp, #116]
1851:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 5898              		.loc 1 1851 0
 5899 3360 78408DE5 		str	r4, [sp, #120]
1853:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5900              		.loc 1 1853 0
 5901 3364 8040CDE5 		strb	r4, [sp, #128]
1852:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 5902              		.loc 1 1852 0
 5903 3368 7C808DE5 		str	r8, [sp, #124]
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5904              		.loc 1 1854 0
 5905 336c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5906              	.LVL490:
1855:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5907              		.loc 1 1855 0
 5908 3370 004050E2 		subs	r4, r0, #0
 5909 3374 CB01001A 		bne	.L558
1867:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5910              		.loc 1 1867 0
 5911 3378 0800A0E1 		mov	r0, r8
 5912              	.LVL491:
 5913 337c 84108DE2 		add	r1, sp, #132
1864:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5914              		.loc 1 1864 0
 5915 3380 8C408DE5 		str	r4, [sp, #140]
1865:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 5916              		.loc 1 1865 0
 5917 3384 88408DE5 		str	r4, [sp, #136]
1862:../uvc.c      ****     pibclock.clkDiv      = 2;
 5918              		.loc 1 1862 0
 5919 3388 B458CDE1 		strh	r5, [sp, #132]	@ movhi
1863:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5920              		.loc 1 1863 0
 5921 338c 9070CDE5 		strb	r7, [sp, #144]
1867:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5922              		.loc 1 1867 0
 5923 3390 FEFFFFEB 		bl	CyU3PPibInit
 5924              	.LVL492:
1868:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5925              		.loc 1 1868 0
 5926 3394 004050E2 		subs	r4, r0, #0
 5927 3398 B901001A 		bne	.L559
1875:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 5928              		.loc 1 1875 0
 5929 339c 34099FE5 		ldr	r0, .L575+12
 5930              	.LVL493:
 5931 33a0 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
1883:../uvc.c      ****     SensorReset ();
 5932              		.loc 1 1883 0
 5933 33a4 FEFFFFEB 		bl	SensorReset
1884:../uvc.c      ****     SensorInit ();
 5934              		.loc 1 1884 0
 5935 33a8 FEFFFFEB 		bl	SensorInit
1887:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 5936              		.loc 1 1887 0
 5937 33ac FEFFFFEB 		bl	CyU3PUsbStart
 5938              	.LVL494:
1888:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5939              		.loc 1 1888 0
 5940 33b0 004050E2 		subs	r4, r0, #0
 5941 33b4 A901001A 		bne	.L560
1894:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 5942              		.loc 1 1894 0
 5943 33b8 0010A0E3 		mov	r1, #0
 5944 33bc 18099FE5 		ldr	r0, .L575+16
 5945              	.LVL495:
 5946 33c0 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
1897:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 5947              		.loc 1 1897 0
 5948 33c4 14099FE5 		ldr	r0, .L575+20
 5949 33c8 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1903:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 5950              		.loc 1 1903 0
 5951 33cc 0010A0E3 		mov	r1, #0
 5952 33d0 0C299FE5 		ldr	r2, .L575+24
 5953 33d4 0100A0E3 		mov	r0, #1
 5954 33d8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1904:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 5955              		.loc 1 1904 0
 5956 33dc 0000A0E3 		mov	r0, #0
 5957 33e0 0010A0E1 		mov	r1, r0
 5958 33e4 FC289FE5 		ldr	r2, .L575+28
 5959 33e8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1907:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 5960              		.loc 1 1907 0
 5961 33ec 0010A0E3 		mov	r1, #0
 5962 33f0 F4289FE5 		ldr	r2, .L575+32
 5963 33f4 0200A0E3 		mov	r0, #2
 5964 33f8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1908:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 5965              		.loc 1 1908 0
 5966 33fc 0010A0E3 		mov	r1, #0
 5967 3400 E8289FE5 		ldr	r2, .L575+36
 5968 3404 0700A0E3 		mov	r0, #7
 5969 3408 FEFFFFEB 		bl	CyU3PUsbSetDesc
1911:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 5970              		.loc 1 1911 0
 5971 340c 0010A0E3 		mov	r1, #0
 5972 3410 DC289FE5 		ldr	r2, .L575+40
 5973 3414 0400A0E3 		mov	r0, #4
 5974 3418 FEFFFFEB 		bl	CyU3PUsbSetDesc
1912:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 5975              		.loc 1 1912 0
 5976 341c 0010A0E3 		mov	r1, #0
 5977 3420 D0289FE5 		ldr	r2, .L575+44
 5978 3424 0300A0E3 		mov	r0, #3
 5979 3428 FEFFFFEB 		bl	CyU3PUsbSetDesc
1913:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 5980              		.loc 1 1913 0
 5981 342c 0010A0E3 		mov	r1, #0
 5982 3430 C4289FE5 		ldr	r2, .L575+48
 5983 3434 0600A0E3 		mov	r0, #6
 5984 3438 FEFFFFEB 		bl	CyU3PUsbSetDesc
1916:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 5985              		.loc 1 1916 0
 5986 343c 0010A0E3 		mov	r1, #0
 5987 3440 B8289FE5 		ldr	r2, .L575+52
 5988 3444 0500A0E3 		mov	r0, #5
 5989 3448 FEFFFFEB 		bl	CyU3PUsbSetDesc
1917:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 5990              		.loc 1 1917 0
 5991 344c 0110A0E3 		mov	r1, #1
 5992 3450 AC289FE5 		ldr	r2, .L575+56
 5993 3454 0500A0E3 		mov	r0, #5
 5994 3458 FEFFFFEB 		bl	CyU3PUsbSetDesc
1918:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 5995              		.loc 1 1918 0
 5996 345c 0210A0E3 		mov	r1, #2
 5997 3460 A0289FE5 		ldr	r2, .L575+60
 5998 3464 0500A0E3 		mov	r0, #5
 5999 3468 FEFFFFEB 		bl	CyU3PUsbSetDesc
1928:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6000              		.loc 1 1928 0
 6001 346c 0080A0E3 		mov	r8, #0
1925:../uvc.c      ****     endPointConfig.enable   = 1;
 6002              		.loc 1 1925 0
 6003 3470 0140A0E3 		mov	r4, #1
 6004              	.LVL496:
1927:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6005              		.loc 1 1927 0
 6006 3474 40A0A0E3 		mov	sl, #64	@ movhi
1926:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6007              		.loc 1 1926 0
 6008 3478 0370A0E3 		mov	r7, #3
1931:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6009              		.loc 1 1931 0
 6010 347c 8200A0E3 		mov	r0, #130
 6011 3480 B0108DE2 		add	r1, sp, #176
1927:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6012              		.loc 1 1927 0
 6013 3484 B8ABCDE1 		strh	sl, [sp, #184]	@ movhi
1925:../uvc.c      ****     endPointConfig.enable   = 1;
 6014              		.loc 1 1925 0
 6015 3488 B0408DE5 		str	r4, [sp, #176]
1926:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6016              		.loc 1 1926 0
 6017 348c B470CDE5 		strb	r7, [sp, #180]
1928:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6018              		.loc 1 1928 0
 6019 3490 BB80CDE5 		strb	r8, [sp, #187]
1929:../uvc.c      ****     endPointConfig.streams  = 0;
 6020              		.loc 1 1929 0
 6021 3494 B68BCDE1 		strh	r8, [sp, #182]	@ movhi
1930:../uvc.c      ****     endPointConfig.burstLen = 1;
 6022              		.loc 1 1930 0
 6023 3498 BA40CDE5 		strb	r4, [sp, #186]
1931:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6024              		.loc 1 1931 0
 6025 349c FEFFFFEB 		bl	CyU3PSetEpConfig
 6026              	.LVL497:
1929:../uvc.c      ****     endPointConfig.streams  = 0;
 6027              		.loc 1 1929 0
 6028 34a0 08A0A0E1 		mov	sl, r8	@ movhi
1932:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6029              		.loc 1 1932 0
 6030 34a4 005050E2 		subs	r5, r0, #0
 6031 34a8 6301001A 		bne	.L561
1942:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6032              		.loc 1 1942 0
 6033 34ac 58389FE5 		ldr	r3, .L575+64
1943:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6034              		.loc 1 1943 0
 6035 34b0 58E89FE5 		ldr	lr, .L575+68
1940:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6036              		.loc 1 1940 0
 6037 34b4 01CBA0E3 		mov	ip, #1024	@ movhi
1949:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6038              		.loc 1 1949 0
 6039 34b8 1080A0E3 		mov	r8, #16
1951:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6040              		.loc 1 1951 0
 6041 34bc 50089FE5 		ldr	r0, .L575+72
 6042              	.LVL498:
 6043 34c0 0410A0E3 		mov	r1, #4
 6044 34c4 3C208DE2 		add	r2, sp, #60
1944:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 6045              		.loc 1 1944 0
 6046 34c8 B454CDE1 		strh	r5, [sp, #68]	@ movhi
1945:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 6047              		.loc 1 1945 0
 6048 34cc B654CDE1 		strh	r5, [sp, #70]	@ movhi
1946:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 6049              		.loc 1 1946 0
 6050 34d0 B854CDE1 		strh	r5, [sp, #72]	@ movhi
1947:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 6051              		.loc 1 1947 0
 6052 34d4 BA54CDE1 		strh	r5, [sp, #74]	@ movhi
1950:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6053              		.loc 1 1950 0
 6054 34d8 54508DE5 		str	r5, [sp, #84]
1940:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6055              		.loc 1 1940 0
 6056 34dc BCC3CDE1 		strh	ip, [sp, #60]	@ movhi
1941:../uvc.c      ****     dmaInterConfig.count          = 1;
 6057              		.loc 1 1941 0
 6058 34e0 BE43CDE1 		strh	r4, [sp, #62]	@ movhi
1942:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6059              		.loc 1 1942 0
 6060 34e4 B034CDE1 		strh	r3, [sp, #64]	@ movhi
1943:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6061              		.loc 1 1943 0
 6062 34e8 B2E4CDE1 		strh	lr, [sp, #66]	@ movhi
1948:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6063              		.loc 1 1948 0
 6064 34ec 4CA0CDE5 		strb	sl, [sp, #76]
1949:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6065              		.loc 1 1949 0
 6066 34f0 50808DE5 		str	r8, [sp, #80]
1951:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6067              		.loc 1 1951 0
 6068 34f4 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6069              	.LVL499:
1953:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6070              		.loc 1 1953 0
 6071 34f8 005050E2 		subs	r5, r0, #0
 6072 34fc 4501001A 		bne	.L562
1960:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6073              		.loc 1 1960 0
 6074 3500 010BA0E3 		mov	r0, #1024
 6075              	.LVL500:
 6076 3504 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6077 3508 08189FE5 		ldr	r1, .L575+76
1961:../uvc.c      ****     if (glInterStaBuffer == 0)
 6078              		.loc 1 1961 0
 6079 350c 000050E3 		cmp	r0, #0
1960:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6080              		.loc 1 1960 0
 6081 3510 000081E5 		str	r0, [r1, #0]
1961:../uvc.c      ****     if (glInterStaBuffer == 0)
 6082              		.loc 1 1961 0
 6083 3514 3701000A 		beq	.L563
1969:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6084              		.loc 1 1969 0
 6085 3518 08C0A0E3 		mov	ip, #8	@ movhi
1970:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6086              		.loc 1 1970 0
 6087 351c 0230A0E3 		mov	r3, #2	@ movhi
1981:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6088              		.loc 1 1981 0
 6089 3520 F4879FE5 		ldr	r8, .L575+80
1969:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6090              		.loc 1 1969 0
 6091 3524 B6C1CDE1 		strh	ip, [sp, #22]	@ movhi
1970:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6092              		.loc 1 1970 0
 6093 3528 B831CDE1 		strh	r3, [sp, #24]	@ movhi
1972:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6094              		.loc 1 1972 0
 6095 352c ECC79FE5 		ldr	ip, .L575+84
1973:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6096              		.loc 1 1973 0
 6097 3530 EC379FE5 		ldr	r3, .L575+88
1968:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6098              		.loc 1 1968 0
 6099 3534 03EBA0E3 		mov	lr, #3072	@ movhi
1974:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6100              		.loc 1 1974 0
 6101 3538 BA52CDE1 		strh	r5, [sp, #42]	@ movhi
1977:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6102              		.loc 1 1977 0
 6103 353c B053CDE1 		strh	r5, [sp, #48]	@ movhi
1980:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6104              		.loc 1 1980 0
 6105 3540 E0579FE5 		ldr	r5, .L575+92
 6106              	.LVL501:
1968:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6107              		.loc 1 1968 0
 6108 3544 B4E1CDE1 		strh	lr, [sp, #20]	@ movhi
1971:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6109              		.loc 1 1971 0
 6110 3548 01ECA0E3 		mov	lr, #256	@ movhi
1981:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6111              		.loc 1 1981 0
 6112 354c 0710A0E3 		mov	r1, #7
 6113 3550 14208DE2 		add	r2, sp, #20
1971:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6114              		.loc 1 1971 0
 6115 3554 BAE1CDE1 		strh	lr, [sp, #26]	@ movhi
1972:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6116              		.loc 1 1972 0
 6117 3558 BCC1CDE1 		strh	ip, [sp, #28]	@ movhi
1975:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6118              		.loc 1 1975 0
 6119 355c 0CE0A0E3 		mov	lr, #12	@ movhi
1976:../uvc.c      ****     dmaMultiConfig.prodFooter     = 132;                  /* 4 byte footer to compensate for the 12
 6120              		.loc 1 1976 0
 6121 3560 84C0A0E3 		mov	ip, #132	@ movhi
1973:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6122              		.loc 1 1973 0
 6123 3564 B232CDE1 		strh	r3, [sp, #34]	@ movhi
1981:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6124              		.loc 1 1981 0
 6125 3568 0800A0E1 		mov	r0, r8
1979:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6126              		.loc 1 1979 0
 6127 356c 1830A0E3 		mov	r3, #24
1975:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6128              		.loc 1 1975 0
 6129 3570 BCE2CDE1 		strh	lr, [sp, #44]	@ movhi
1976:../uvc.c      ****     dmaMultiConfig.prodFooter     = 132;                  /* 4 byte footer to compensate for the 12
 6130              		.loc 1 1976 0
 6131 3574 BEC2CDE1 		strh	ip, [sp, #46]	@ movhi
1978:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6132              		.loc 1 1978 0
 6133 3578 32A0CDE5 		strb	sl, [sp, #50]
1979:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6134              		.loc 1 1979 0
 6135 357c 34308DE5 		str	r3, [sp, #52]
1980:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6136              		.loc 1 1980 0
 6137 3580 38508DE5 		str	r5, [sp, #56]
1981:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6138              		.loc 1 1981 0
 6139 3584 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
1983:../uvc.c      ****     CyU3PDebugPrint (4, "DMA Channel Creation. xfersize %d, size %d, count %d, activeProInd %d, act
 6140              		.loc 1 1983 0
 6141 3588 B8E0D8E1 		ldrh	lr, [r8, #8]
 6142 358c B630D8E1 		ldrh	r3, [r8, #6]
 6143 3590 702098E5 		ldr	r2, [r8, #112]
 6144 3594 46C088E2 		add	ip, r8, #70
 6145 3598 3EA088E2 		add	sl, r8, #62
 6146 359c 88179FE5 		ldr	r1, .L575+96
 6147 35a0 00E08DE5 		str	lr, [sp, #0]
 6148 35a4 00148DE9 		stmib	sp, {sl, ip}	@ phole stm
1981:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6149              		.loc 1 1981 0
 6150 35a8 0050A0E1 		mov	r5, r0
 6151              	.LVL502:
1983:../uvc.c      ****     CyU3PDebugPrint (4, "DMA Channel Creation. xfersize %d, size %d, count %d, activeProInd %d, act
 6152              		.loc 1 1983 0
 6153 35ac 0400A0E3 		mov	r0, #4
 6154              	.LVL503:
 6155 35b0 FEFFFFEB 		bl	CyU3PDebugPrint
1986:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6156              		.loc 1 1986 0
 6157 35b4 000055E3 		cmp	r5, #0
 6158 35b8 0501001A 		bne	.L564
2077:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6159              		.loc 1 2077 0
 6160 35bc 0400A0E1 		mov	r0, r4
 6161 35c0 0410A0E1 		mov	r1, r4
 6162 35c4 FEFFFFEB 		bl	CyU3PConnectState
 6163              	.LVL504:
2078:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6164              		.loc 1 2078 0
 6165 35c8 005050E2 		subs	r5, r0, #0
 6166 35cc F700001A 		bne	.L565
2084:../uvc.c      ****     CyU3PBusyWait(100);
 6167              		.loc 1 2084 0
 6168 35d0 6400A0E3 		mov	r0, #100
 6169              	.LVL505:
 6170 35d4 FEFFFFEB 		bl	CyU3PBusyWait
2086:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6171              		.loc 1 2086 0
 6172 35d8 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2103:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6173              		.loc 1 2103 0
 6174 35dc B0108DE2 		add	r1, sp, #176
2088:../uvc.c      ****     endPointConfig.enable   = 1;
 6175              		.loc 1 2088 0
 6176 35e0 B0408DE5 		str	r4, [sp, #176]
2089:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_ISO;//CY_U3P_USB_EP_BULK;
 6177              		.loc 1 2089 0
 6178 35e4 B440CDE5 		strb	r4, [sp, #180]
2090:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6179              		.loc 1 2090 0
 6180 35e8 030050E3 		cmp	r0, #3
2086:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6181              		.loc 1 2086 0
 6182 35ec 2C00C6E5 		strb	r0, [r6, #44]
2098:../uvc.c      ****     	endPointConfig.pcktSize = 0x400;
 6183              		.loc 1 2098 0
 6184 35f0 010BA013 		movne	r0, #1024	@ movhi
2092:../uvc.c      ****     	endPointConfig.pcktSize = 0x400;//CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6185              		.loc 1 2092 0
 6186 35f4 012BA003 		moveq	r2, #1024	@ movhi
2094:../uvc.c      ****     	endPointConfig.isoPkts = 3; //for isochronous
 6187              		.loc 1 2094 0
 6188 35f8 BB00CD05 		streqb	r0, [sp, #187]
2098:../uvc.c      ****     	endPointConfig.pcktSize = 0x400;
 6189              		.loc 1 2098 0
 6190 35fc B80BCD11 		strneh	r0, [sp, #184]	@ movhi
2100:../uvc.c      ****     	endPointConfig.isoPkts = 3; //for isochronous
 6191              		.loc 1 2100 0
 6192 3600 BB70CD15 		strneb	r7, [sp, #187]
2103:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6193              		.loc 1 2103 0
 6194 3604 8300A0E3 		mov	r0, #131
2102:../uvc.c      ****     endPointConfig.streams  = 0;
 6195              		.loc 1 2102 0
 6196 3608 0070A0E3 		mov	r7, #0	@ movhi
2092:../uvc.c      ****     	endPointConfig.pcktSize = 0x400;//CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6197              		.loc 1 2092 0
 6198 360c B82BCD01 		streqh	r2, [sp, #184]	@ movhi
2093:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6199              		.loc 1 2093 0
 6200 3610 BA40CD05 		streqb	r4, [sp, #186]
2099:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6201              		.loc 1 2099 0
 6202 3614 BA40CD15 		strneb	r4, [sp, #186]
2102:../uvc.c      ****     endPointConfig.streams  = 0;
 6203              		.loc 1 2102 0
 6204 3618 B67BCDE1 		strh	r7, [sp, #182]	@ movhi
2103:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6205              		.loc 1 2103 0
 6206 361c FEFFFFEB 		bl	CyU3PSetEpConfig
 6207              	.LVL506:
2104:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6208              		.loc 1 2104 0
 6209 3620 004050E2 		subs	r4, r0, #0
 6210 3624 4A00001A 		bne	.L544
 6211 3628 00779FE5 		ldr	r7, .L575+100
 6212              	.LBE230:
 6213              	.LBE228:
2230:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6214              		.loc 1 2230 0
 6215 362c A0569FE5 		ldr	r5, .L575+8
2301:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6216              		.loc 1 2301 0
 6217 3630 0780A0E1 		mov	r8, r7
 6218              	.LVL507:
 6219              	.L515:
2230:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6220              		.loc 1 2230 0
 6221 3634 98069FE5 		ldr	r0, .L575+8
 6222 3638 0110A0E3 		mov	r1, #1
 6223 363c 0220A0E3 		mov	r2, #2
 6224 3640 BC308DE2 		add	r3, sp, #188
 6225 3644 00408DE5 		str	r4, [sp, #0]
 6226 3648 FEFFFFEB 		bl	_txe_event_flags_get
 6227 364c 000050E3 		cmp	r0, #0
 6228 3650 2C00001A 		bne	.L517
2276:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6229              		.loc 1 2276 0
 6230 3654 281095E5 		ldr	r1, [r5, #40]
 6231 3658 000051E3 		cmp	r1, #0
 6232 365c 0300000A 		beq	.L518
2276:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6233              		.loc 1 2276 0 is_stmt 0 discriminator 1
 6234 3660 B6A3D5E1 		ldrh	sl, [r5, #54]
 6235 3664 B833D5E1 		ldrh	r3, [r5, #56]
 6236 3668 03005AE1 		cmp	sl, r3
 6237 366c 4301000A 		beq	.L566
 6238              	.L518:
2404:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6239              		.loc 1 2404 0 is_stmt 1
 6240 3670 4010A0E3 		mov	r1, #64
 6241 3674 0020A0E3 		mov	r2, #0
 6242 3678 54069FE5 		ldr	r0, .L575+8
 6243 367c FEFFFFEB 		bl	_txe_event_flags_set
2407:../uvc.c      ****         CyU3PThreadRelinquish ();
 6244              		.loc 1 2407 0
 6245 3680 FEFFFFEB 		bl	_txe_thread_relinquish
2408:../uvc.c      ****     }
 6246              		.loc 1 2408 0
 6247 3684 EAFFFFEA 		b	.L515
 6248              	.LVL508:
 6249              	.L547:
 6250              	.LBB265:
 6251              	.LBB224:
1660:../uvc.c      ****     	CyU3PDebugPrint (4, "test UART transfer");
 6252              		.loc 1 1660 0
 6253 3688 A4169FE5 		ldr	r1, .L575+104
 6254 368c 0400A0E3 		mov	r0, #4
 6255              	.LVL509:
 6256 3690 FEFFFFEB 		bl	CyU3PDebugPrint
 6257              	.LVL510:
 6258              	.LBB216:
 6259              	.LBB217:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6260              		.loc 1 1214 0
 6261 3694 0400A0E3 		mov	r0, #4
 6262 3698 98169FE5 		ldr	r1, .L575+108
 6263 369c 0420A0E1 		mov	r2, r4
 6264 36a0 FEFFFFEB 		bl	CyU3PDebugPrint
 6265              	.L477:
 6266 36a4 FEFFFFEA 		b	.L477
 6267              	.LVL511:
 6268              	.L546:
 6269              	.LBE217:
 6270              	.LBE216:
1652:../uvc.c      ****     	CyU3PDebugPrint (4, "test UART config");
 6271              		.loc 1 1652 0
 6272 36a8 8C169FE5 		ldr	r1, .L575+112
 6273 36ac 0400A0E3 		mov	r0, #4
 6274              	.LVL512:
 6275 36b0 FEFFFFEB 		bl	CyU3PDebugPrint
 6276              	.LVL513:
 6277              	.LBB218:
 6278              	.LBB219:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6279              		.loc 1 1214 0
 6280 36b4 0400A0E3 		mov	r0, #4
 6281 36b8 78169FE5 		ldr	r1, .L575+108
 6282 36bc 0420A0E1 		mov	r2, r4
 6283 36c0 FEFFFFEB 		bl	CyU3PDebugPrint
 6284              	.L475:
 6285 36c4 FEFFFFEA 		b	.L475
 6286              	.LVL514:
 6287              	.L545:
 6288              	.LBE219:
 6289              	.LBE218:
1635:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 6290              		.loc 1 1635 0
 6291 36c8 70169FE5 		ldr	r1, .L575+116
 6292 36cc 0400A0E3 		mov	r0, #4
 6293              	.LVL515:
 6294 36d0 FEFFFFEB 		bl	CyU3PDebugPrint
 6295              	.LVL516:
 6296              	.LBB220:
 6297              	.LBB221:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6298              		.loc 1 1214 0
 6299 36d4 0400A0E3 		mov	r0, #4
 6300 36d8 58169FE5 		ldr	r1, .L575+108
 6301 36dc 0420A0E1 		mov	r2, r4
 6302 36e0 FEFFFFEB 		bl	CyU3PDebugPrint
 6303              	.L473:
 6304 36e4 FEFFFFEA 		b	.L473
 6305              	.LVL517:
 6306              	.L548:
 6307              	.LBE221:
 6308              	.LBE220:
1668:../uvc.c      ****     	CyU3PDebugPrint (4, "test debug");
 6309              		.loc 1 1668 0
 6310 36e8 54169FE5 		ldr	r1, .L575+120
 6311 36ec 0400A0E3 		mov	r0, #4
 6312              	.LVL518:
 6313 36f0 FEFFFFEB 		bl	CyU3PDebugPrint
 6314              	.LVL519:
 6315              	.LBB222:
 6316              	.LBB223:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6317              		.loc 1 1214 0
 6318 36f4 0400A0E3 		mov	r0, #4
 6319 36f8 38169FE5 		ldr	r1, .L575+108
 6320 36fc 0420A0E1 		mov	r2, r4
 6321 3700 FEFFFFEB 		bl	CyU3PDebugPrint
 6322              	.L479:
 6323 3704 FEFFFFEA 		b	.L479
 6324              	.LVL520:
 6325              	.L517:
 6326              	.LBE223:
 6327              	.LBE222:
 6328              	.LBE224:
 6329              	.LBE265:
2332:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6330              		.loc 1 2332 0
 6331 3708 C4059FE5 		ldr	r0, .L575+8
 6332 370c 0210A0E3 		mov	r1, #2
 6333 3710 0320A0E3 		mov	r2, #3
 6334 3714 BC308DE2 		add	r3, sp, #188
 6335 3718 00408DE5 		str	r4, [sp, #0]
 6336 371c FEFFFFEB 		bl	_txe_event_flags_get
 6337 3720 000050E3 		cmp	r0, #0
 6338 3724 1A00001A 		bne	.L525
2347:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6339              		.loc 1 2347 0
 6340 3728 481095E5 		ldr	r1, [r5, #72]
2335:../uvc.c      ****                 hitFV     = CyFalse;
 6341              		.loc 1 2335 0
 6342 372c 284085E5 		str	r4, [r5, #40]
2347:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6343              		.loc 1 2347 0
 6344 3730 000051E3 		cmp	r1, #0
2336:../uvc.c      ****                 prodCount = 0;
 6345              		.loc 1 2336 0
 6346 3734 B643C5E1 		strh	r4, [r5, #54]	@ movhi
2343:../uvc.c      ****                 fb=0;
 6347              		.loc 1 2343 0
 6348 3738 BE42C5E1 		strh	r4, [r5, #46]	@ movhi
2337:../uvc.c      ****                 consCount = 0;
 6349              		.loc 1 2337 0
 6350 373c B843C5E1 		strh	r4, [r5, #56]	@ movhi
2344:../uvc.c      ****                 pb=0;
 6351              		.loc 1 2344 0
 6352 3740 B243C5E1 		strh	r4, [r5, #50]	@ movhi
2345:../uvc.c      ****                 pbc=0;
 6353              		.loc 1 2345 0
 6354 3744 B443C5E1 		strh	r4, [r5, #52]	@ movhi
2347:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6355              		.loc 1 2347 0
 6356 3748 0A00000A 		beq	.L567
 6357              	.L526:
2360:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6358              		.loc 1 2360 0
 6359 374c 484086E5 		str	r4, [r6, #72]
 6360 3750 C6FFFFEA 		b	.L518
 6361              	.LVL521:
 6362              	.L544:
 6363              	.LBB266:
 6364              	.LBB263:
2107:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(iso), Error Code = %d\n", apiRetStatus)
 6365              		.loc 1 2107 0
 6366 3754 EC159FE5 		ldr	r1, .L575+124
 6367 3758 0420A0E1 		mov	r2, r4
 6368 375c 0400A0E3 		mov	r0, #4
 6369 3760 FEFFFFEB 		bl	CyU3PDebugPrint
 6370              	.LVL522:
 6371              	.LBB257:
 6372              	.LBB258:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6373              		.loc 1 1214 0
 6374 3764 0400A0E3 		mov	r0, #4
 6375 3768 C8159FE5 		ldr	r1, .L575+108
 6376 376c 0420A0E1 		mov	r2, r4
 6377 3770 FEFFFFEB 		bl	CyU3PDebugPrint
 6378              	.L516:
 6379 3774 FEFFFFEA 		b	.L516
 6380              	.LVL523:
 6381              	.L567:
 6382              	.LBE258:
 6383              	.LBE257:
 6384              	.LBE263:
 6385              	.LBE266:
2349:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6386              		.loc 1 2349 0
 6387 3778 9C059FE5 		ldr	r0, .L575+80
 6388 377c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6389              	.LVL524:
2350:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6390              		.loc 1 2350 0
 6391 3780 00A050E2 		subs	sl, r0, #0
 6392 3784 3F00001A 		bne	.L568
2357:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6393              		.loc 1 2357 0
 6394 3788 8300A0E3 		mov	r0, #131
 6395              	.LVL525:
 6396 378c FEFFFFEB 		bl	CyU3PUsbFlushEp
 6397 3790 EDFFFFEA 		b	.L526
 6398              	.LVL526:
 6399              	.L525:
2365:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6400              		.loc 1 2365 0
 6401 3794 00C0E0E3 		mvn	ip, #0
 6402 3798 0110A0E3 		mov	r1, #1
 6403 379c 0220A0E3 		mov	r2, #2
 6404 37a0 BC308DE2 		add	r3, sp, #188
 6405 37a4 28059FE5 		ldr	r0, .L575+8
 6406 37a8 00C08DE5 		str	ip, [sp, #0]
 6407 37ac FEFFFFEB 		bl	_txe_event_flags_get
2369:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6408              		.loc 1 2369 0
 6409 37b0 64059FE5 		ldr	r0, .L575+80
 6410 37b4 0410A0E1 		mov	r1, r4
 6411 37b8 0420A0E1 		mov	r2, r4
 6412 37bc FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6413              	.LVL527:
2370:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6414              		.loc 1 2370 0
 6415 37c0 00A050E2 		subs	sl, r0, #0
 6416 37c4 7000001A 		bne	.L569
2378:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6417              		.loc 1 2378 0
 6418 37c8 403095E5 		ldr	r3, [r5, #64]
 6419 37cc 000053E3 		cmp	r3, #0
 6420 37d0 6500001A 		bne	.L531
2381:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6421              		.loc 1 2381 0
 6422 37d4 3010A0E3 		mov	r1, #48
 6423 37d8 0120A0E3 		mov	r2, #1
 6424 37dc 823083E2 		add	r3, r3, #130
 6425 37e0 2100A0E3 		mov	r0, #33
 6426              	.LVL528:
 6427 37e4 FEFFFFEB 		bl	SensorSetIrisControl
2382:../uvc.c      ****                     CyU3PThreadSleep(500);
 6428              		.loc 1 2382 0
 6429 37e8 7D0FA0E3 		mov	r0, #500
 6430 37ec FEFFFFEB 		bl	_tx_thread_sleep
2383:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6431              		.loc 1 2383 0
 6432 37f0 3010A0E3 		mov	r1, #48
 6433 37f4 0220A0E3 		mov	r2, #2
 6434 37f8 5230A0E3 		mov	r3, #82
 6435 37fc 2500A0E3 		mov	r0, #37
 6436 3800 FEFFFFEB 		bl	SensorSetIrisControl
2384:../uvc.c      ****                     CyU3PThreadSleep(500);
 6437              		.loc 1 2384 0
 6438 3804 7D0FA0E3 		mov	r0, #500
 6439 3808 FEFFFFEB 		bl	_tx_thread_sleep
2385:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
 6440              		.loc 1 2385 0
 6441 380c 3010A0E3 		mov	r1, #48
 6442 3810 0A20A0E3 		mov	r2, #10
 6443 3814 8230A0E3 		mov	r3, #130
 6444 3818 2300A0E3 		mov	r0, #35
 6445 381c FEFFFFEB 		bl	SensorSetIrisControl
2386:../uvc.c      ****                    	CyU3PThreadSleep(300);
 6446              		.loc 1 2386 0
 6447 3820 4B0FA0E3 		mov	r0, #300
 6448 3824 FEFFFFEB 		bl	_tx_thread_sleep
2387:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6449              		.loc 1 2387 0
 6450 3828 3010A0E3 		mov	r1, #48
 6451 382c 0420A0E1 		mov	r2, r4
 6452 3830 8230A0E3 		mov	r3, #130
 6453 3834 2100A0E3 		mov	r0, #33
 6454 3838 FEFFFFEB 		bl	SensorSetIrisControl
2388:../uvc.c      ****                     CyU3PThreadSleep(500);
 6455              		.loc 1 2388 0
 6456 383c 7D0FA0E3 		mov	r0, #500
 6457 3840 FEFFFFEB 		bl	_tx_thread_sleep
2389:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6458              		.loc 1 2389 0
 6459 3844 5230A0E3 		mov	r3, #82
 6460 3848 3010A0E3 		mov	r1, #48
 6461 384c 0420A0E1 		mov	r2, r4
 6462 3850 2500A0E3 		mov	r0, #37
 6463 3854 FEFFFFEB 		bl	SensorSetIrisControl
2390:../uvc.c      ****                     CyU3PThreadSleep(500);
 6464              		.loc 1 2390 0
 6465 3858 7D0FA0E3 		mov	r0, #500
 6466 385c FEFFFFEB 		bl	_tx_thread_sleep
 6467              	.LVL529:
 6468              	.LBB267:
 6469              	.LBB268:
2132:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6470              		.loc 1 2132 0
 6471 3860 2C30D5E5 		ldrb	r3, [r5, #44]	@ zero_extendqisi2
 6472 3864 030053E3 		cmp	r3, #3
 6473 3868 3800000A 		beq	.L570
2137:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6474              		.loc 1 2137 0
 6475 386c 020053E3 		cmp	r3, #2
 6476 3870 0D00000A 		beq	.L571
 6477              	.LVL530:
 6478              	.L534:
 6479              	.LBE268:
 6480              	.LBE267:
2392:../uvc.c      ****                     gpif_initialized = CyTrue;
 6481              		.loc 1 2392 0
 6482 3874 01E0A0E3 		mov	lr, #1
 6483 3878 40E086E5 		str	lr, [r6, #64]
2393:../uvc.c      ****                     CyU3PThreadSleep(200);
 6484              		.loc 1 2393 0
 6485 387c C800A0E3 		mov	r0, #200
 6486 3880 FEFFFFEB 		bl	_tx_thread_sleep
 6487 3884 79FFFFEA 		b	.L518
 6488              	.LVL531:
 6489              	.L568:
2352:../uvc.c      ****                     	CyU3PDebugPrint (4, "test 1 0x%x\r\n", apiRetStatus);
 6490              		.loc 1 2352 0
 6491 3888 BC149FE5 		ldr	r1, .L575+128
 6492 388c 0A20A0E1 		mov	r2, sl
 6493 3890 0400A0E3 		mov	r0, #4
 6494              	.LVL532:
 6495 3894 FEFFFFEB 		bl	CyU3PDebugPrint
 6496              	.LVL533:
 6497              	.LBB274:
 6498              	.LBB275:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6499              		.loc 1 1214 0
 6500 3898 0400A0E3 		mov	r0, #4
 6501 389c 94149FE5 		ldr	r1, .L575+108
 6502 38a0 0A20A0E1 		mov	r2, sl
 6503 38a4 FEFFFFEB 		bl	CyU3PDebugPrint
 6504              	.L528:
 6505 38a8 FEFFFFEA 		b	.L528
 6506              	.LVL534:
 6507              	.L571:
 6508              	.LBE275:
 6509              	.LBE274:
 6510              	.LBB276:
 6511              	.LBB273:
2139:../uvc.c      ****     	CyU3PDebugPrint(1,"%d \r\n high gpif", glProbeCtrl20[3]);
 6512              		.loc 1 2139 0
 6513 38ac 9C149FE5 		ldr	r1, .L575+132
 6514 38b0 2F26D7E5 		ldrb	r2, [r7, #1583]	@ zero_extendqisi2
 6515 38b4 0100A0E3 		mov	r0, #1
 6516 38b8 FEFFFFEB 		bl	CyU3PDebugPrint
2140:../uvc.c      ****     	if(glProbeCtrl20[3]==2)//480x320
 6517              		.loc 1 2140 0
 6518 38bc 2F36D7E5 		ldrb	r3, [r7, #1583]	@ zero_extendqisi2
 6519 38c0 020053E3 		cmp	r3, #2
2141:../uvc.c      ****     		apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2_480);
 6520              		.loc 1 2141 0
 6521 38c4 88049F05 		ldreq	r0, .L575+136
2143:../uvc.c      ****     		apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2_640);
 6522              		.loc 1 2143 0
 6523 38c8 88049F15 		ldrne	r0, .L575+140
 6524 38cc FEFFFFEB 		bl	CyU3PGpifLoad
 6525 38d0 00A0A0E1 		mov	sl, r0
 6526              	.LVL535:
 6527              	.L533:
2145:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6528              		.loc 1 2145 0
 6529 38d4 00005AE3 		cmp	sl, #0
 6530 38d8 1300001A 		bne	.L572
2153:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6531              		.loc 1 2153 0
 6532 38dc 2C30D6E5 		ldrb	r3, [r6, #44]	@ zero_extendqisi2
 6533 38e0 030053E3 		cmp	r3, #3
 6534 38e4 0100000A 		beq	.L540
2157:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 6535              		.loc 1 2157 0
 6536 38e8 020053E3 		cmp	r3, #2
 6537 38ec E0FFFF1A 		bne	.L534
 6538              	.L540:
2162:../uvc.c      ****     		apiRetStatus = CyU3PGpifSMStart (START_USB2_640, ALPHA_START_USB2_640);
 6539              		.loc 1 2162 0
 6540 38f0 0A00A0E1 		mov	r0, sl
 6541              	.LVL536:
 6542 38f4 0A10A0E1 		mov	r1, sl
 6543 38f8 FEFFFFEB 		bl	CyU3PGpifSMStart
2164:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6544              		.loc 1 2164 0
 6545 38fc 000050E3 		cmp	r0, #0
2162:../uvc.c      ****     		apiRetStatus = CyU3PGpifSMStart (START_USB2_640, ALPHA_START_USB2_640);
 6546              		.loc 1 2162 0
 6547 3900 00A0A0E1 		mov	sl, r0
 6548              	.LVL537:
2164:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6549              		.loc 1 2164 0
 6550 3904 DAFFFF0A 		beq	.L534
2167:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 6551              		.loc 1 2167 0
 6552 3908 0020A0E1 		mov	r2, r0
 6553 390c 48149FE5 		ldr	r1, .L575+144
 6554 3910 0400A0E3 		mov	r0, #4
 6555              	.LVL538:
 6556 3914 FEFFFFEB 		bl	CyU3PDebugPrint
 6557              	.LVL539:
 6558              	.LBB269:
 6559              	.LBB270:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6560              		.loc 1 1214 0
 6561 3918 0400A0E3 		mov	r0, #4
 6562 391c 14149FE5 		ldr	r1, .L575+108
 6563 3920 0A20A0E1 		mov	r2, sl
 6564 3924 FEFFFFEB 		bl	CyU3PDebugPrint
 6565              	.L541:
 6566 3928 FEFFFFEA 		b	.L541
 6567              	.LVL540:
 6568              	.L572:
 6569              	.LBE270:
 6570              	.LBE269:
2148:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 6571              		.loc 1 2148 0
 6572 392c 2C149FE5 		ldr	r1, .L575+148
 6573 3930 0A20A0E1 		mov	r2, sl
 6574 3934 0400A0E3 		mov	r0, #4
 6575              	.LVL541:
 6576 3938 FEFFFFEB 		bl	CyU3PDebugPrint
 6577              	.LVL542:
 6578              	.LBB271:
 6579              	.LBB272:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6580              		.loc 1 1214 0
 6581 393c 0400A0E3 		mov	r0, #4
 6582 3940 F0139FE5 		ldr	r1, .L575+108
 6583 3944 0A20A0E1 		mov	r2, sl
 6584 3948 FEFFFFEB 		bl	CyU3PDebugPrint
 6585              	.L537:
 6586 394c FEFFFFEA 		b	.L537
 6587              	.LVL543:
 6588              	.L570:
 6589              	.LBE272:
 6590              	.LBE271:
2134:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 6591              		.loc 1 2134 0
 6592 3950 0C149FE5 		ldr	r1, .L575+152
 6593 3954 0100A0E3 		mov	r0, #1
 6594 3958 FEFFFFEB 		bl	CyU3PDebugPrint
2135:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6595              		.loc 1 2135 0
 6596 395c 04049FE5 		ldr	r0, .L575+156
 6597 3960 FEFFFFEB 		bl	CyU3PGpifLoad
 6598 3964 00A0A0E1 		mov	sl, r0
 6599              	.LVL544:
 6600 3968 D9FFFFEA 		b	.L533
 6601              	.LVL545:
 6602              	.L531:
 6603              	.LBE273:
 6604              	.LBE276:
2400:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6605              		.loc 1 2400 0
 6606 396c AC039FE5 		ldr	r0, .L575+84
 6607              	.LVL546:
 6608 3970 02A0A0E3 		mov	sl, #2
 6609              	.LVL547:
 6610 3974 0410A0E1 		mov	r1, r4
 6611 3978 0020A0E1 		mov	r2, r0
 6612 397c 0430A0E1 		mov	r3, r4
 6613 3980 00A08DE5 		str	sl, [sp, #0]
 6614 3984 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6615 3988 38FFFFEA 		b	.L518
 6616              	.LVL548:
 6617              	.L569:
2373:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 6618              		.loc 1 2373 0
 6619 398c D8139FE5 		ldr	r1, .L575+160
 6620 3990 0A20A0E1 		mov	r2, sl
 6621 3994 0400A0E3 		mov	r0, #4
 6622              	.LVL549:
 6623 3998 FEFFFFEB 		bl	CyU3PDebugPrint
 6624              	.LVL550:
 6625              	.LBB277:
 6626              	.LBB278:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6627              		.loc 1 1214 0
 6628 399c 0400A0E3 		mov	r0, #4
 6629 39a0 90139FE5 		ldr	r1, .L575+108
 6630 39a4 0A20A0E1 		mov	r2, sl
 6631 39a8 FEFFFFEB 		bl	CyU3PDebugPrint
 6632              	.L530:
 6633 39ac FEFFFFEA 		b	.L530
 6634              	.LVL551:
 6635              	.L565:
 6636              	.LBE278:
 6637              	.LBE277:
 6638              	.LBB279:
 6639              	.LBB229:
2080:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6640              		.loc 1 2080 0
 6641 39b0 B8139FE5 		ldr	r1, .L575+164
 6642 39b4 0520A0E1 		mov	r2, r5
 6643 39b8 0400A0E3 		mov	r0, #4
 6644              	.LVL552:
 6645 39bc FEFFFFEB 		bl	CyU3PDebugPrint
 6646              	.LVL553:
 6647              	.LBB255:
 6648              	.LBB256:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6649              		.loc 1 1214 0
 6650 39c0 0400A0E3 		mov	r0, #4
 6651 39c4 6C139FE5 		ldr	r1, .L575+108
 6652 39c8 0520A0E1 		mov	r2, r5
 6653 39cc FEFFFFEB 		bl	CyU3PDebugPrint
 6654              	.L512:
 6655 39d0 FEFFFFEA 		b	.L512
 6656              	.LVL554:
 6657              	.L564:
 6658              	.LBE256:
 6659              	.LBE255:
1989:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6660              		.loc 1 1989 0
 6661 39d4 98139FE5 		ldr	r1, .L575+168
 6662 39d8 0520A0E1 		mov	r2, r5
 6663 39dc 0400A0E3 		mov	r0, #4
 6664 39e0 FEFFFFEB 		bl	CyU3PDebugPrint
 6665              	.LVL555:
 6666              	.LBB253:
 6667              	.LBB254:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6668              		.loc 1 1214 0
 6669 39e4 0400A0E3 		mov	r0, #4
 6670 39e8 48139FE5 		ldr	r1, .L575+108
 6671 39ec 0520A0E1 		mov	r2, r5
 6672 39f0 FEFFFFEB 		bl	CyU3PDebugPrint
 6673              	.L510:
 6674 39f4 FEFFFFEA 		b	.L510
 6675              	.LVL556:
 6676              	.L563:
 6677              	.LBE254:
 6678              	.LBE253:
1963:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6679              		.loc 1 1963 0
 6680 39f8 78139FE5 		ldr	r1, .L575+172
 6681 39fc 040080E2 		add	r0, r0, #4
 6682 3a00 FEFFFFEB 		bl	CyU3PDebugPrint
 6683              	.LVL557:
 6684              	.LBB251:
 6685              	.LBB252:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6686              		.loc 1 1214 0
 6687 3a04 0400A0E3 		mov	r0, #4
 6688 3a08 28139FE5 		ldr	r1, .L575+108
 6689 3a0c 0820A0E1 		mov	r2, r8
 6690 3a10 FEFFFFEB 		bl	CyU3PDebugPrint
 6691              	.L508:
 6692 3a14 FEFFFFEA 		b	.L508
 6693              	.LVL558:
 6694              	.L562:
 6695              	.LBE252:
 6696              	.LBE251:
1956:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6697              		.loc 1 1956 0
 6698 3a18 5C139FE5 		ldr	r1, .L575+176
 6699 3a1c 0520A0E1 		mov	r2, r5
 6700 3a20 0400A0E3 		mov	r0, #4
 6701 3a24 FEFFFFEB 		bl	CyU3PDebugPrint
 6702              	.LVL559:
 6703              	.LBB249:
 6704              	.LBB250:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6705              		.loc 1 1214 0
 6706 3a28 0400A0E3 		mov	r0, #4
 6707 3a2c 04139FE5 		ldr	r1, .L575+108
 6708 3a30 0520A0E1 		mov	r2, r5
 6709 3a34 FEFFFFEB 		bl	CyU3PDebugPrint
 6710              	.L506:
 6711 3a38 FEFFFFEA 		b	.L506
 6712              	.LVL560:
 6713              	.L561:
 6714              	.LBE250:
 6715              	.LBE249:
1935:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(int), Error Code = %d\n", apiRetStatus)
 6716              		.loc 1 1935 0
 6717 3a3c 3C139FE5 		ldr	r1, .L575+180
 6718 3a40 0520A0E1 		mov	r2, r5
 6719 3a44 0400A0E3 		mov	r0, #4
 6720              	.LVL561:
 6721 3a48 FEFFFFEB 		bl	CyU3PDebugPrint
 6722              	.LVL562:
 6723              	.LBB247:
 6724              	.LBB248:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6725              		.loc 1 1214 0
 6726 3a4c 0400A0E3 		mov	r0, #4
 6727 3a50 E0129FE5 		ldr	r1, .L575+108
 6728 3a54 0520A0E1 		mov	r2, r5
 6729 3a58 FEFFFFEB 		bl	CyU3PDebugPrint
 6730              	.L504:
 6731 3a5c FEFFFFEA 		b	.L504
 6732              	.LVL563:
 6733              	.L560:
 6734              	.LBE248:
 6735              	.LBE247:
1890:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6736              		.loc 1 1890 0
 6737 3a60 1C139FE5 		ldr	r1, .L575+184
 6738 3a64 0420A0E1 		mov	r2, r4
 6739 3a68 0400A0E3 		mov	r0, #4
 6740              	.LVL564:
 6741 3a6c FEFFFFEB 		bl	CyU3PDebugPrint
 6742              	.LVL565:
 6743              	.LBB245:
 6744              	.LBB246:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6745              		.loc 1 1214 0
 6746 3a70 0400A0E3 		mov	r0, #4
 6747 3a74 BC129FE5 		ldr	r1, .L575+108
 6748 3a78 0420A0E1 		mov	r2, r4
 6749 3a7c FEFFFFEB 		bl	CyU3PDebugPrint
 6750              	.L502:
 6751 3a80 FEFFFFEA 		b	.L502
 6752              	.LVL566:
 6753              	.L559:
 6754              	.LBE246:
 6755              	.LBE245:
1870:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6756              		.loc 1 1870 0
 6757 3a84 FC129FE5 		ldr	r1, .L575+188
 6758 3a88 0420A0E1 		mov	r2, r4
 6759 3a8c 0400A0E3 		mov	r0, #4
 6760              	.LVL567:
 6761 3a90 FEFFFFEB 		bl	CyU3PDebugPrint
 6762              	.LVL568:
 6763              	.LBB243:
 6764              	.LBB244:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6765              		.loc 1 1214 0
 6766 3a94 0400A0E3 		mov	r0, #4
 6767 3a98 98129FE5 		ldr	r1, .L575+108
 6768 3a9c 0420A0E1 		mov	r2, r4
 6769 3aa0 FEFFFFEB 		bl	CyU3PDebugPrint
 6770              	.L500:
 6771 3aa4 FEFFFFEA 		b	.L500
 6772              	.LVL569:
 6773              	.L558:
 6774              	.LBE244:
 6775              	.LBE243:
1857:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6776              		.loc 1 1857 0
 6777 3aa8 DC129FE5 		ldr	r1, .L575+192
 6778 3aac 0420A0E1 		mov	r2, r4
 6779 3ab0 0400A0E3 		mov	r0, #4
 6780              	.LVL570:
 6781 3ab4 FEFFFFEB 		bl	CyU3PDebugPrint
 6782              	.LVL571:
 6783              	.LBB241:
 6784              	.LBB242:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6785              		.loc 1 1214 0
 6786 3ab8 0400A0E3 		mov	r0, #4
 6787 3abc 74129FE5 		ldr	r1, .L575+108
 6788 3ac0 0420A0E1 		mov	r2, r4
 6789 3ac4 FEFFFFEB 		bl	CyU3PDebugPrint
 6790              	.L498:
 6791 3ac8 FEFFFFEA 		b	.L498
 6792              	.LVL572:
 6793              	.L557:
 6794              	.LBE242:
 6795              	.LBE241:
1843:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 6796              		.loc 1 1843 0
 6797 3acc BC129FE5 		ldr	r1, .L575+196
 6798 3ad0 0420A0E1 		mov	r2, r4
 6799 3ad4 0400A0E3 		mov	r0, #4
 6800              	.LVL573:
 6801 3ad8 FEFFFFEB 		bl	CyU3PDebugPrint
 6802              	.LVL574:
 6803              	.LBB239:
 6804              	.LBB240:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6805              		.loc 1 1214 0
 6806 3adc 0400A0E3 		mov	r0, #4
 6807 3ae0 50129FE5 		ldr	r1, .L575+108
 6808 3ae4 0420A0E1 		mov	r2, r4
 6809 3ae8 FEFFFFEB 		bl	CyU3PDebugPrint
 6810              	.L496:
 6811 3aec FEFFFFEA 		b	.L496
 6812              	.LVL575:
 6813              	.L556:
 6814              	.LBE240:
 6815              	.LBE239:
1829:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6816              		.loc 1 1829 0
 6817 3af0 9C129FE5 		ldr	r1, .L575+200
 6818 3af4 0420A0E1 		mov	r2, r4
 6819 3af8 0400A0E3 		mov	r0, #4
 6820              	.LVL576:
 6821 3afc FEFFFFEB 		bl	CyU3PDebugPrint
 6822              	.LVL577:
 6823              	.LBB237:
 6824              	.LBB238:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6825              		.loc 1 1214 0
 6826 3b00 0400A0E3 		mov	r0, #4
 6827 3b04 2C129FE5 		ldr	r1, .L575+108
 6828 3b08 0420A0E1 		mov	r2, r4
 6829 3b0c FEFFFFEB 		bl	CyU3PDebugPrint
 6830              	.L494:
 6831 3b10 FEFFFFEA 		b	.L494
 6832              	.LVL578:
 6833              	.L555:
 6834              	.LBE238:
 6835              	.LBE237:
1816:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 6836              		.loc 1 1816 0
 6837 3b14 7C129FE5 		ldr	r1, .L575+204
 6838 3b18 0420A0E1 		mov	r2, r4
 6839 3b1c 0400A0E3 		mov	r0, #4
 6840              	.LVL579:
 6841 3b20 FEFFFFEB 		bl	CyU3PDebugPrint
 6842              	.LVL580:
 6843              	.LBB235:
 6844              	.LBB236:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6845              		.loc 1 1214 0
 6846 3b24 0400A0E3 		mov	r0, #4
 6847 3b28 08129FE5 		ldr	r1, .L575+108
 6848 3b2c 0420A0E1 		mov	r2, r4
 6849 3b30 FEFFFFEB 		bl	CyU3PDebugPrint
 6850              	.L492:
 6851 3b34 FEFFFFEA 		b	.L492
 6852              	.LVL581:
 6853              	.L554:
 6854              	.LBE236:
 6855              	.LBE235:
1810:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6856              		.loc 1 1810 0
 6857 3b38 5C129FE5 		ldr	r1, .L575+208
 6858 3b3c 0420A0E1 		mov	r2, r4
 6859 3b40 0400A0E3 		mov	r0, #4
 6860              	.LVL582:
 6861 3b44 FEFFFFEB 		bl	CyU3PDebugPrint
 6862              	.LVL583:
 6863              	.LBB233:
 6864              	.LBB234:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6865              		.loc 1 1214 0
 6866 3b48 0400A0E3 		mov	r0, #4
 6867 3b4c E4119FE5 		ldr	r1, .L575+108
 6868 3b50 0420A0E1 		mov	r2, r4
 6869 3b54 FEFFFFEB 		bl	CyU3PDebugPrint
 6870              	.L490:
 6871 3b58 FEFFFFEA 		b	.L490
 6872              	.LVL584:
 6873              	.L553:
 6874              	.LBE234:
 6875              	.LBE233:
1804:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6876              		.loc 1 1804 0
 6877 3b5c 3C129FE5 		ldr	r1, .L575+212
 6878 3b60 0420A0E1 		mov	r2, r4
 6879 3b64 0400A0E3 		mov	r0, #4
 6880              	.LVL585:
 6881 3b68 FEFFFFEB 		bl	CyU3PDebugPrint
 6882              	.LVL586:
 6883              	.LBB231:
 6884              	.LBB232:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6885              		.loc 1 1214 0
 6886 3b6c 0400A0E3 		mov	r0, #4
 6887 3b70 C0119FE5 		ldr	r1, .L575+108
 6888 3b74 0420A0E1 		mov	r2, r4
 6889 3b78 FEFFFFEB 		bl	CyU3PDebugPrint
 6890              	.L488:
 6891 3b7c FEFFFFEA 		b	.L488
 6892              	.LVL587:
 6893              	.L566:
 6894              	.LBE232:
 6895              	.LBE231:
 6896              	.LBE229:
 6897              	.LBE279:
2286:../uvc.c      ****                 prodCount = 0;
 6898              		.loc 1 2286 0
 6899 3b80 B643C5E1 		strh	r4, [r5, #54]	@ movhi
2287:../uvc.c      ****                 consCount = 0;
 6900              		.loc 1 2287 0
 6901 3b84 B843C5E1 		strh	r4, [r5, #56]	@ movhi
2288:../uvc.c      ****                 hitFV     = CyFalse;
 6902              		.loc 1 2288 0
 6903 3b88 284085E5 		str	r4, [r5, #40]
2301:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6904              		.loc 1 2301 0
 6905 3b8c 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
2283:../uvc.c      ****             	fb=0;
 6906              		.loc 1 2283 0
 6907 3b90 BE42C5E1 		strh	r4, [r5, #46]	@ movhi
2301:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6908              		.loc 1 2301 0
 6909 3b94 010022E2 		eor	r0, r2, #1
 6910 3b98 8104C7E5 		strb	r0, [r7, #1153]
2302:../uvc.c      ****                 if(stiflag){
 6911              		.loc 1 2302 0
 6912 3b9c 9CE095E5 		ldr	lr, [r5, #156]
2303:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6913              		.loc 1 2303 0
 6914 3ba0 81C4D8E5 		ldrb	ip, [r8, #1153]	@ zero_extendqisi2
2302:../uvc.c      ****                 if(stiflag){
 6915              		.loc 1 2302 0
 6916 3ba4 00005EE3 		cmp	lr, #0
2303:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6917              		.loc 1 2303 0
 6918 3ba8 20C08C13 		orrne	ip, ip, #32
2306:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6919              		.loc 1 2306 0
 6920 3bac DFC00C02 		andeq	ip, ip, #223
2303:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6921              		.loc 1 2303 0
 6922 3bb0 81C4C815 		strneb	ip, [r8, #1153]
2306:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6923              		.loc 1 2306 0
 6924 3bb4 81C4C805 		streqb	ip, [r8, #1153]
2304:../uvc.c      ****                 	stiflag = CyFalse;
 6925              		.loc 1 2304 0
 6926 3bb8 9C408515 		strne	r4, [r5, #156]
2284:../uvc.c      ****             	pb=0;
 6927              		.loc 1 2284 0
 6928 3bbc B243C5E1 		strh	r4, [r5, #50]	@ movhi
2285:../uvc.c      ****             	pbc=0;
 6929              		.loc 1 2285 0
 6930 3bc0 B443C5E1 		strh	r4, [r5, #52]	@ movhi
2309:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6931              		.loc 1 2309 0
 6932 3bc4 50019FE5 		ldr	r0, .L575+80
 6933 3bc8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6934              	.LVL588:
2310:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6935              		.loc 1 2310 0
 6936 3bcc 00A050E2 		subs	sl, r0, #0
 6937 3bd0 3400001A 		bne	.L573
2317:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6938              		.loc 1 2317 0
 6939 3bd4 0A10A0E1 		mov	r1, sl
 6940 3bd8 0A20A0E1 		mov	r2, sl
 6941 3bdc 38019FE5 		ldr	r0, .L575+80
 6942              	.LVL589:
 6943 3be0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6944              	.LVL590:
2318:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6945              		.loc 1 2318 0
 6946 3be4 00A050E2 		subs	sl, r0, #0
 6947 3be8 2500001A 		bne	.L574
2326:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6948              		.loc 1 2326 0
 6949 3bec 2C019FE5 		ldr	r0, .L575+84
 6950              	.LVL591:
 6951 3bf0 0A10A0E1 		mov	r1, sl
 6952 3bf4 0A30A0E1 		mov	r3, sl
 6953 3bf8 0020A0E1 		mov	r2, r0
 6954 3bfc 02A0A0E3 		mov	sl, #2
 6955              	.LVL592:
 6956 3c00 00A08DE5 		str	sl, [sp, #0]
 6957 3c04 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6958              	.LVL593:
 6959 3c08 98FEFFEA 		b	.L518
 6960              	.LVL594:
 6961              	.L552:
 6962              	.LBB280:
 6963              	.LBB264:
1795:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6964              		.loc 1 1795 0
 6965 3c0c 90119FE5 		ldr	r1, .L575+216
 6966 3c10 0420A0E1 		mov	r2, r4
 6967 3c14 0400A0E3 		mov	r0, #4
 6968              	.LVL595:
 6969 3c18 FEFFFFEB 		bl	CyU3PDebugPrint
 6970              	.LVL596:
 6971              	.LBB259:
 6972              	.LBB260:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6973              		.loc 1 1214 0
 6974 3c1c 0400A0E3 		mov	r0, #4
 6975 3c20 10119FE5 		ldr	r1, .L575+108
 6976 3c24 0420A0E1 		mov	r2, r4
 6977 3c28 FEFFFFEB 		bl	CyU3PDebugPrint
 6978              	.L486:
 6979 3c2c FEFFFFEA 		b	.L486
 6980              	.LVL597:
 6981              	.L551:
 6982              	.LBE260:
 6983              	.LBE259:
1773:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6984              		.loc 1 1773 0
 6985 3c30 70119FE5 		ldr	r1, .L575+220
 6986 3c34 0420A0E1 		mov	r2, r4
 6987 3c38 0400A0E3 		mov	r0, #4
 6988              	.LVL598:
 6989 3c3c FEFFFFEB 		bl	CyU3PDebugPrint
 6990              	.LVL599:
 6991              	.LBB261:
 6992              	.LBB262:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 6993              		.loc 1 1214 0
 6994 3c40 0400A0E3 		mov	r0, #4
 6995 3c44 EC109FE5 		ldr	r1, .L575+108
 6996 3c48 0420A0E1 		mov	r2, r4
 6997 3c4c FEFFFFEB 		bl	CyU3PDebugPrint
 6998              	.L484:
 6999 3c50 FEFFFFEA 		b	.L484
 7000              	.LVL600:
 7001              	.L550:
 7002              	.LBE262:
 7003              	.LBE261:
 7004              	.LBE264:
 7005              	.LBE280:
 7006              	.LBB281:
 7007              	.LBB227:
1699:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 7008              		.loc 1 1699 0
 7009 3c54 50119FE5 		ldr	r1, .L575+224
 7010 3c58 0400A0E3 		mov	r0, #4
 7011              	.LVL601:
 7012 3c5c FEFFFFEB 		bl	CyU3PDebugPrint
1700:../uvc.c      ****         CyFxAppErrorHandler (status);
 7013              		.loc 1 1700 0
 7014 3c60 0400A0E1 		mov	r0, r4
 7015 3c64 FEFFFFEB 		bl	CyFxAppErrorHandler
 7016 3c68 7FFDFFEA 		b	.L482
 7017              	.LVL602:
 7018              	.L549:
1686:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 7019              		.loc 1 1686 0
 7020 3c6c 3C119FE5 		ldr	r1, .L575+228
 7021 3c70 0400A0E3 		mov	r0, #4
 7022              	.LVL603:
 7023 3c74 FEFFFFEB 		bl	CyU3PDebugPrint
1687:../uvc.c      ****         CyFxAppErrorHandler (status);
 7024              		.loc 1 1687 0
 7025 3c78 0400A0E1 		mov	r0, r4
 7026 3c7c FEFFFFEB 		bl	CyFxAppErrorHandler
 7027 3c80 6DFDFFEA 		b	.L481
 7028              	.LVL604:
 7029              	.L574:
 7030              	.LBE227:
 7031              	.LBE281:
2320:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 7032              		.loc 1 2320 0
 7033 3c84 28119FE5 		ldr	r1, .L575+232
 7034 3c88 0A20A0E1 		mov	r2, sl
 7035 3c8c 0400A0E3 		mov	r0, #4
 7036              	.LVL605:
 7037 3c90 FEFFFFEB 		bl	CyU3PDebugPrint
 7038              	.LVL606:
 7039              	.LBB282:
 7040              	.LBB283:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 7041              		.loc 1 1214 0
 7042 3c94 0400A0E3 		mov	r0, #4
 7043 3c98 98109FE5 		ldr	r1, .L575+108
 7044 3c9c 0A20A0E1 		mov	r2, sl
 7045 3ca0 FEFFFFEB 		bl	CyU3PDebugPrint
 7046              	.L524:
 7047 3ca4 FEFFFFEA 		b	.L524
 7048              	.LVL607:
 7049              	.L573:
 7050              	.LBE283:
 7051              	.LBE282:
2312:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 7052              		.loc 1 2312 0
 7053 3ca8 08119FE5 		ldr	r1, .L575+236
 7054 3cac 0A20A0E1 		mov	r2, sl
 7055 3cb0 0400A0E3 		mov	r0, #4
 7056              	.LVL608:
 7057 3cb4 FEFFFFEB 		bl	CyU3PDebugPrint
 7058              	.LVL609:
 7059              	.LBB284:
 7060              	.LBB285:
1214:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler... 0x%x\r\n", apiRetStatus);
 7061              		.loc 1 1214 0
 7062 3cb8 0400A0E3 		mov	r0, #4
 7063 3cbc 74109FE5 		ldr	r1, .L575+108
 7064 3cc0 0A20A0E1 		mov	r2, sl
 7065 3cc4 FEFFFFEB 		bl	CyU3PDebugPrint
 7066              	.L522:
 7067 3cc8 FEFFFFEA 		b	.L522
 7068              	.L576:
 7069              		.align	2
 7070              	.L575:
 7071 3ccc 00C20100 		.word	115200
 7072 3cd0 A0860100 		.word	100000
 7073 3cd4 00000000 		.word	.LANCHOR0
 7074 3cd8 00000000 		.word	CyFxGpifCB
 7075 3cdc 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7076 3ce0 00000000 		.word	CyFxUVCApplnUSBEventCB
 7077 3ce4 00000000 		.word	CyFxUSBDeviceDscr
 7078 3ce8 00000000 		.word	CyFxUSBDeviceDscrSS
 7079 3cec 00000000 		.word	CyFxUSBDeviceQualDscr
 7080 3cf0 00000000 		.word	CyFxUSBBOSDscr
 7081 3cf4 00000000 		.word	CyFxUSBHSConfigDscr
 7082 3cf8 00000000 		.word	CyFxUSBFSConfigDscr
 7083 3cfc 00000000 		.word	CyFxUSBSSConfigDscr
 7084 3d00 00000000 		.word	CyFxUSBStringLangIDDscr
 7085 3d04 00000000 		.word	CyFxUSBManufactureDscr
 7086 3d08 00000000 		.word	CyFxUSBProductDscr
 7087 3d0c 013F0000 		.word	16129
 7088 3d10 02030000 		.word	770
 7089 3d14 00000000 		.word	glChHandleInterStat
 7090 3d18 00000000 		.word	glInterStaBuffer
 7091 3d1c 00000000 		.word	glChHandleUVCStream
 7092 3d20 01010000 		.word	257
 7093 3d24 03030000 		.word	771
 7094 3d28 00000000 		.word	CyFxUvcApplnDmaCallback
 7095 3d2c F8090000 		.word	.LC56
 7096 3d30 00000000 		.word	.LANCHOR1
 7097 3d34 20070000 		.word	.LC39
 7098 3d38 80000000 		.word	.LC4
 7099 3d3c 0C070000 		.word	.LC38
 7100 3d40 EC060000 		.word	.LC37
 7101 3d44 34070000 		.word	.LC40
 7102 3d48 A80A0000 		.word	.LC59
 7103 3d4c 400B0000 		.word	.LC62
 7104 3d50 940B0000 		.word	.LC65
 7105 3d54 2C000000 		.word	.LANCHOR2+44
 7106 3d58 48000000 		.word	.LANCHOR2+72
 7107 3d5c DC0B0000 		.word	.LC67
 7108 3d60 A40B0000 		.word	.LC66
 7109 3d64 840B0000 		.word	.LC64
 7110 3d68 10000000 		.word	.LANCHOR2+16
 7111 3d6c 500B0000 		.word	.LC63
 7112 3d70 800A0000 		.word	.LC58
 7113 3d74 500A0000 		.word	.LC57
 7114 3d78 C0090000 		.word	.LC55
 7115 3d7c 80090000 		.word	.LC54
 7116 3d80 48090000 		.word	.LC53
 7117 3d84 18090000 		.word	.LC52
 7118 3d88 E8080000 		.word	.LC51
 7119 3d8c B0080000 		.word	.LC50
 7120 3d90 7C080000 		.word	.LC49
 7121 3d94 48080000 		.word	.LC48
 7122 3d98 1C080000 		.word	.LC47
 7123 3d9c F0070000 		.word	.LC46
 7124 3da0 C8070000 		.word	.LC45
 7125 3da4 A4070000 		.word	.LC44
 7126 3da8 78070000 		.word	.LC43
 7127 3dac 5C070000 		.word	.LC42
 7128 3db0 40070000 		.word	.LC41
 7129 3db4 0C0B0000 		.word	.LC61
 7130 3db8 E00A0000 		.word	.LC60
 7131              	.LBE285:
 7132              	.LBE284:
 7133              		.cfi_endproc
 7134              	.LFE18:
 7136              		.align	2
 7137              		.global	CyFxApplicationDefine
 7139              	CyFxApplicationDefine:
 7140              	.LFB26:
3642:../uvc.c      **** }
3643:../uvc.c      **** 
3644:../uvc.c      **** 
3645:../uvc.c      **** /*
3646:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3647:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3648:../uvc.c      ****  */
3649:../uvc.c      **** void
3650:../uvc.c      **** CyFxApplicationDefine (
3651:../uvc.c      ****         void)
3652:../uvc.c      **** {
 7141              		.loc 1 3652 0
 7142              		.cfi_startproc
 7143              		@ args = 0, pretend = 0, frame = 40
 7144              		@ frame_needed = 0, uses_anonymous_args = 0
 7145              	.LVL610:
 7146 3dbc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7147              	.LCFI25:
 7148              		.cfi_def_cfa_offset 36
3653:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3654:../uvc.c      ****     uint32_t retThrdCreate;
3655:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3656:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3657:../uvc.c      **** 
3658:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3659:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7149              		.loc 1 3659 0
 7150 3dc0 010AA0E3 		mov	r0, #4096
3652:../uvc.c      **** {
 7151              		.loc 1 3652 0
 7152 3dc4 4CD04DE2 		sub	sp, sp, #76
 7153              	.LCFI26:
 7154              		.cfi_def_cfa_offset 112
 7155              		.loc 1 3659 0
 7156              		.cfi_offset 14, -4
 7157              		.cfi_offset 11, -8
 7158              		.cfi_offset 10, -12
 7159              		.cfi_offset 9, -16
 7160              		.cfi_offset 8, -20
 7161              		.cfi_offset 7, -24
 7162              		.cfi_offset 6, -28
 7163              		.cfi_offset 5, -32
 7164              		.cfi_offset 4, -36
 7165 3dc8 FEFFFFEB 		bl	CyU3PMemAlloc
 7166 3dcc 00A0A0E1 		mov	sl, r0
 7167              	.LVL611:
3660:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7168              		.loc 1 3660 0
 7169 3dd0 010AA0E3 		mov	r0, #4096
 7170              	.LVL612:
 7171 3dd4 FEFFFFEB 		bl	CyU3PMemAlloc
 7172 3dd8 00B0A0E1 		mov	fp, r0
 7173              	.LVL613:
3661:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7174              		.loc 1 3661 0
 7175 3ddc 010AA0E3 		mov	r0, #4096
 7176              	.LVL614:
 7177 3de0 FEFFFFEB 		bl	CyU3PMemAlloc
3662:../uvc.c      **** 
3663:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7178              		.loc 1 3663 0
 7179 3de4 00005AE3 		cmp	sl, #0
 7180 3de8 00005B13 		cmpne	fp, #0
 7181 3dec 0090A013 		movne	r9, #0
 7182 3df0 0190A003 		moveq	r9, #1
3661:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7183              		.loc 1 3661 0
 7184 3df4 24008DE5 		str	r0, [sp, #36]
 7185              	.LVL615:
 7186              		.loc 1 3663 0
 7187 3df8 0000001A 		bne	.L581
 7188              	.LVL616:
 7189              	.L578:
 7190              	.L580:
 7191 3dfc FEFFFFEA 		b	.L580
 7192              	.L581:
 7193              		.loc 1 3663 0 is_stmt 0 discriminator 1
 7194 3e00 000050E3 		cmp	r0, #0
 7195 3e04 FCFFFF0A 		beq	.L578
3664:../uvc.c      ****         goto fatalErrorHandler;
3665:../uvc.c      **** 
3666:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3667:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7196              		.loc 1 3667 0 is_stmt 1
 7197 3e08 28408DE2 		add	r4, sp, #40
 7198 3e0c 0400A0E1 		mov	r0, r4
 7199 3e10 4010A0E3 		mov	r1, #64
 7200 3e14 18219FE5 		ldr	r2, .L582
 7201 3e18 FEFFFFEB 		bl	cmdbufCreate
 7202 3e1c 0450A0E1 		mov	r5, r4
 7203 3e20 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7204 3e24 0C719FE5 		ldr	r7, .L582+4
3668:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7205              		.loc 1 3668 0
 7206 3e28 0C819FE5 		ldr	r8, .L582+8
3667:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7207              		.loc 1 3667 0
 7208 3e2c 07C0A0E1 		mov	ip, r7
 7209 3e30 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7210 3e34 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3669:../uvc.c      **** 
3670:../uvc.c      **** 	/****** initialize command descriptor ***********/
3671:../uvc.c      **** 	cmdquInit(cmdQuptr);
3672:../uvc.c      **** 	cmdquInit(statQuptr);
3673:../uvc.c      **** 
3674:../uvc.c      ****     /* Create the UVC application thread. */
3675:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7211              		.loc 1 3675 0
 7212 3e38 0860A0E3 		mov	r6, #8
3667:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7213              		.loc 1 3667 0
 7214 3e3c 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3668:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7215              		.loc 1 3668 0
 7216 3e40 F8209FE5 		ldr	r2, .L582+12
 7217 3e44 0400A0E1 		mov	r0, r4
 7218 3e48 2010A0E3 		mov	r1, #32
 7219 3e4c FEFFFFEB 		bl	cmdbufCreate
 7220 3e50 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7221 3e54 08C0A0E1 		mov	ip, r8
 7222 3e58 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7223 3e5c 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7224              		.loc 1 3675 0
 7225 3e60 0140A0E3 		mov	r4, #1
3668:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7226              		.loc 1 3668 0
 7227 3e64 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3671:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7228              		.loc 1 3671 0
 7229 3e68 0700A0E1 		mov	r0, r7
 7230 3e6c FEFFFFEB 		bl	cmdquInit
3672:../uvc.c      **** 	cmdquInit(statQuptr);
 7231              		.loc 1 3672 0
 7232 3e70 0800A0E1 		mov	r0, r8
 7233 3e74 FEFFFFEB 		bl	cmdquInit
 7234              		.loc 1 3675 0
 7235 3e78 A850A0E3 		mov	r5, #168
 7236 3e7c 01CAA0E3 		mov	ip, #4096
 7237 3e80 BC009FE5 		ldr	r0, .L582+16
 7238 3e84 BC109FE5 		ldr	r1, .L582+20
 7239 3e88 BC209FE5 		ldr	r2, .L582+24
 7240 3e8c 0930A0E1 		mov	r3, r9
 7241 3e90 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7242 3e94 08608DE5 		str	r6, [sp, #8]
 7243 3e98 0C608DE5 		str	r6, [sp, #12]
 7244 3e9c 10908DE5 		str	r9, [sp, #16]
 7245 3ea0 14408DE5 		str	r4, [sp, #20]
 7246 3ea4 18508DE5 		str	r5, [sp, #24]
 7247 3ea8 FEFFFFEB 		bl	_txe_thread_create
 7248              	.LVL617:
3676:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3677:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3678:../uvc.c      ****             0,                                          /* No input parameter to thread */
3679:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3680:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3681:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3682:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3683:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3684:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3685:../uvc.c      ****             );
3686:../uvc.c      ****     if (retThrdCreate != 0)
 7249              		.loc 1 3686 0
 7250 3eac 00C050E2 		subs	ip, r0, #0
 7251 3eb0 D1FFFF1A 		bne	.L578
3687:../uvc.c      ****     {
3688:../uvc.c      ****         goto fatalErrorHandler;
3689:../uvc.c      ****     }
3690:../uvc.c      **** 
3691:../uvc.c      ****     /* Create the control request handling thread. */
3692:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7252              		.loc 1 3692 0
 7253 3eb4 0C30A0E1 		mov	r3, ip
 7254 3eb8 027BA0E3 		mov	r7, #2048
 7255 3ebc 8C009FE5 		ldr	r0, .L582+28
 7256              	.LVL618:
 7257 3ec0 8C109FE5 		ldr	r1, .L582+32
 7258 3ec4 8C209FE5 		ldr	r2, .L582+36
 7259 3ec8 10C08DE5 		str	ip, [sp, #16]
 7260 3ecc 00B08DE5 		str	fp, [sp, #0]
 7261 3ed0 04708DE5 		str	r7, [sp, #4]
 7262 3ed4 08608DE5 		str	r6, [sp, #8]
 7263 3ed8 0C608DE5 		str	r6, [sp, #12]
 7264 3edc 14408DE5 		str	r4, [sp, #20]
 7265 3ee0 18508DE5 		str	r5, [sp, #24]
 7266 3ee4 FEFFFFEB 		bl	_txe_thread_create
 7267              	.LVL619:
3693:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3694:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3695:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3696:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3697:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3698:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3699:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3700:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3701:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3702:../uvc.c      ****             );
3703:../uvc.c      ****     if (retThrdCreate != 0)
 7268              		.loc 1 3703 0
 7269 3ee8 00C050E2 		subs	ip, r0, #0
 7270 3eec C2FFFF1A 		bne	.L578
3704:../uvc.c      ****     {
3705:../uvc.c      ****         goto fatalErrorHandler;
3706:../uvc.c      ****     }
3707:../uvc.c      **** #if 1
3708:../uvc.c      ****     /* Create the I2C control command handling thread. */
3709:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7271              		.loc 1 3709 0
 7272 3ef0 24E09DE5 		ldr	lr, [sp, #36]
 7273 3ef4 60009FE5 		ldr	r0, .L582+40
 7274              	.LVL620:
 7275 3ef8 60109FE5 		ldr	r1, .L582+44
 7276 3efc 60209FE5 		ldr	r2, .L582+48
 7277 3f00 0C30A0E1 		mov	r3, ip
 7278 3f04 00E08DE5 		str	lr, [sp, #0]
 7279 3f08 04708DE5 		str	r7, [sp, #4]
 7280 3f0c 08608DE5 		str	r6, [sp, #8]
 7281 3f10 0C608DE5 		str	r6, [sp, #12]
 7282 3f14 10C08DE5 		str	ip, [sp, #16]
 7283 3f18 14408DE5 		str	r4, [sp, #20]
 7284 3f1c 18508DE5 		str	r5, [sp, #24]
 7285 3f20 FEFFFFEB 		bl	_txe_thread_create
 7286              	.LVL621:
3710:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3711:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3712:../uvc.c      ****             0,                                          /* No input parameter to thread */
3713:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3714:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3715:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3716:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3717:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3718:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3719:../uvc.c      ****             );
3720:../uvc.c      ****     if (retThrdCreate != 0)
 7287              		.loc 1 3720 0
 7288 3f24 000050E3 		cmp	r0, #0
 7289 3f28 B3FFFF1A 		bne	.L578
3721:../uvc.c      ****     {
3722:../uvc.c      ****         goto fatalErrorHandler;
3723:../uvc.c      ****     }
3724:../uvc.c      **** #endif
3725:../uvc.c      **** 
3726:../uvc.c      ****     return;
3727:../uvc.c      **** 
3728:../uvc.c      **** fatalErrorHandler:
3729:../uvc.c      ****     /* Add custom recovery or debug actions here */
3730:../uvc.c      ****     /* Loop indefinitely */
3731:../uvc.c      ****     while (1);
3732:../uvc.c      **** }
 7290              		.loc 1 3732 0
 7291 3f2c 4CD08DE2 		add	sp, sp, #76
 7292 3f30 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7293              	.L583:
 7294              		.align	2
 7295              	.L582:
 7296 3f34 00000000 		.word	cmdQuMux
 7297 3f38 00000000 		.word	cmdQu
 7298 3f3c 00000000 		.word	statQu
 7299 3f40 00000000 		.word	staQuMux
 7300 3f44 A0000000 		.word	.LANCHOR0+160
 7301 3f48 140C0000 		.word	.LC68
 7302 3f4c 00000000 		.word	UVCAppThread_Entry
 7303 3f50 48010000 		.word	.LANCHOR0+328
 7304 3f54 280C0000 		.word	.LC69
 7305 3f58 00000000 		.word	UVCAppEP0Thread_Entry
 7306 3f5c F0010000 		.word	.LANCHOR0+496
 7307 3f60 400C0000 		.word	.LC70
 7308 3f64 00000000 		.word	I2cAppThread_Entry
 7309              		.cfi_endproc
 7310              	.LFE26:
 7312              		.align	2
 7313              		.global	main
 7315              	main:
 7316              	.LFB27:
3733:../uvc.c      **** 
3734:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3735:../uvc.c      ****  * the ThreadX RTOS here.
3736:../uvc.c      ****  */
3737:../uvc.c      **** int
3738:../uvc.c      **** main (
3739:../uvc.c      ****         void)
3740:../uvc.c      **** {
 7317              		.loc 1 3740 0
 7318              		.cfi_startproc
 7319              		@ args = 0, pretend = 0, frame = 56
 7320              		@ frame_needed = 0, uses_anonymous_args = 0
 7321 3f68 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7322              	.LCFI27:
 7323              		.cfi_def_cfa_offset 12
3741:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3742:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3743:../uvc.c      **** 
3744:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3745:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3746:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3747:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3748:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3749:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7324              		.loc 1 3749 0
 7325 3f6c 0010A0E3 		mov	r1, #0
3740:../uvc.c      **** {
 7326              		.loc 1 3740 0
 7327 3f70 3CD04DE2 		sub	sp, sp, #60
 7328              	.LCFI28:
 7329              		.cfi_def_cfa_offset 72
3746:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7330              		.loc 1 3746 0
 7331 3f74 0220A0E3 		mov	r2, #2
3750:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7332              		.loc 1 3750 0
 7333 3f78 033081E2 		add	r3, r1, #3
3745:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7334              		.loc 1 3745 0
 7335 3f7c 0150A0E3 		mov	r5, #1
 7336              		.cfi_offset 14, -4
 7337              		.cfi_offset 5, -8
 7338              		.cfi_offset 4, -12
3751:../uvc.c      **** 
3752:../uvc.c      ****     /* Initialize the device */
3753:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7339              		.loc 1 3753 0
 7340 3f80 28008DE2 		add	r0, sp, #40
3745:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7341              		.loc 1 3745 0
 7342 3f84 28508DE5 		str	r5, [sp, #40]
3746:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7343              		.loc 1 3746 0
 7344 3f88 2C20CDE5 		strb	r2, [sp, #44]
3747:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7345              		.loc 1 3747 0
 7346 3f8c 2D20CDE5 		strb	r2, [sp, #45]
3748:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7347              		.loc 1 3748 0
 7348 3f90 2E20CDE5 		strb	r2, [sp, #46]
3749:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7349              		.loc 1 3749 0
 7350 3f94 30108DE5 		str	r1, [sp, #48]
3750:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7351              		.loc 1 3750 0
 7352 3f98 3430CDE5 		strb	r3, [sp, #52]
 7353              		.loc 1 3753 0
 7354 3f9c FEFFFFEB 		bl	CyU3PDeviceInit
 7355              	.LVL622:
3754:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7356              		.loc 1 3754 0
 7357 3fa0 004050E2 		subs	r4, r0, #0
 7358 3fa4 0000000A 		beq	.L587
 7359              	.L585:
 7360              	.L586:
 7361 3fa8 FEFFFFEA 		b	.L586
 7362              	.L587:
3755:../uvc.c      ****     {
3756:../uvc.c      ****         goto handle_fatal_error;
3757:../uvc.c      ****     }
3758:../uvc.c      **** 
3759:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3760:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7363              		.loc 1 3760 0
 7364 3fac 0410A0E1 		mov	r1, r4
 7365 3fb0 0420A0E1 		mov	r2, r4
 7366 3fb4 0500A0E1 		mov	r0, r5
 7367              	.LVL623:
 7368 3fb8 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7369              	.LVL624:
3761:../uvc.c      **** 
3762:../uvc.c      ****     /* Configure the IO matrix for the device. */
3763:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3764:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3765:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3766:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3767:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3768:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3769:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3770:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3771:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3772:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3773:../uvc.c      **** 
3774:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7370              		.loc 1 3774 0
 7371 3fbc 0D00A0E1 		mov	r0, sp
3764:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7372              		.loc 1 3764 0
 7373 3fc0 1640CDE5 		strb	r4, [sp, #22]
3765:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7374              		.loc 1 3765 0
 7375 3fc4 18408DE5 		str	r4, [sp, #24]
3766:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7376              		.loc 1 3766 0
 7377 3fc8 1C408DE5 		str	r4, [sp, #28]
3767:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7378              		.loc 1 3767 0
 7379 3fcc 20408DE5 		str	r4, [sp, #32]
3768:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7380              		.loc 1 3768 0
 7381 3fd0 24408DE5 		str	r4, [sp, #36]
3771:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7382              		.loc 1 3771 0
 7383 3fd4 0C408DE5 		str	r4, [sp, #12]
3772:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7384              		.loc 1 3772 0
 7385 3fd8 10408DE5 		str	r4, [sp, #16]
3763:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7386              		.loc 1 3763 0
 7387 3fdc 00508DE5 		str	r5, [sp, #0]
3769:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7388              		.loc 1 3769 0
 7389 3fe0 04508DE5 		str	r5, [sp, #4]
3770:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7390              		.loc 1 3770 0
 7391 3fe4 08508DE5 		str	r5, [sp, #8]
 7392              		.loc 1 3774 0
 7393 3fe8 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7394              	.LVL625:
3775:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7395              		.loc 1 3775 0
 7396 3fec 004050E2 		subs	r4, r0, #0
 7397 3ff0 ECFFFF1A 		bne	.L585
3776:../uvc.c      ****     {
3777:../uvc.c      ****         goto handle_fatal_error;
3778:../uvc.c      ****     }
3779:../uvc.c      **** 
3780:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3781:../uvc.c      ****     CyU3PKernelEntry ();
 7398              		.loc 1 3781 0
 7399 3ff4 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7400              	.LVL626:
3782:../uvc.c      **** 
3783:../uvc.c      ****     /* Dummy return to make the compiler happy */
3784:../uvc.c      ****     return 0;
3785:../uvc.c      **** 
3786:../uvc.c      **** handle_fatal_error:
3787:../uvc.c      ****     /* Cannot recover from this error. */
3788:../uvc.c      ****     while (1);
3789:../uvc.c      **** }
 7401              		.loc 1 3789 0
 7402 3ff8 0400A0E1 		mov	r0, r4
 7403 3ffc 3CD08DE2 		add	sp, sp, #60
 7404 4000 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7405              		.cfi_endproc
 7406              	.LFE27:
 7408              		.global	CyFxGpifTransition
 7409              		.global	CyFxGpifWavedata
 7410              		.global	CyFxGpifWavedataPosition
 7411              		.global	CyFxGpifRegValue
 7412              		.global	CyFxGpifConfig
 7413              		.global	CyFxGpifTransition_usb2_480
 7414              		.global	CyFxGpifWavedata_usb2_480
 7415              		.global	CyFxGpifWavedataPosition_usb2_480
 7416              		.global	CyFxGpifRegValue_usb2_480
 7417              		.global	CyFxGpifConfig_usb2_480
 7418              		.global	CyFxGpifTransition_usb2_640
 7419              		.global	CyFxGpifWavedata_usb2_640
 7420              		.global	CyFxGpifWavedataPosition_usb2_640
 7421              		.global	CyFxGpifRegValue_usb2_640
 7422              		.global	CyFxGpifConfig_usb2_640
 7423              		.global	snapButFlag
 7424              		.global	testSnap
 7425              		.global	fb
 7426              		.global	pb
 7427              		.global	pbc
 7428              		.global	takeFull
 7429              		.global	fbbak
 7430              		.global	pbbak
 7431              		.global	pbcbak
 7432              		.global	pbcpbak
 7433              		.global	isUsbConnected
 7434              		.global	usbSpeed
 7435              		.global	clearFeatureRqtReceived
 7436              		.global	streamingStarted
 7437              		.global	glProbeCtrl
 7438              		.global	glProbeStilCtrl
 7439              		.global	glProbeCtrl20
 7440              		.global	glProbeStilCtrl20
 7441              		.global	glUVCHeader
 7442              		.comm	glChHandleUVCStream,220,4
 7443              		.comm	glChHandleStillStream,220,4
 7444              		.comm	glChHandleInterStat,160,4
 7445              		.comm	glInterStaBuffer,4,4
 7446              		.comm	cmdQu,32,4
 7447              		.comm	statQu,32,4
 7448              		.comm	cmdQuMux,56,4
 7449              		.comm	staQuMux,56,4
 7450              		.comm	timMux,56,4
 7451              		.comm	bmReqType,1,1
 7452              		.comm	bRequest,1,1
 7453              		.comm	wValue,2,2
 7454              		.comm	wIndex,2,2
 7455              		.comm	wLength,2,2
 7456              		.comm	posTick,4,4
 7457              		.comm	I2CCmdTimer,44,4
 7458              		.section	.rodata
 7459              		.align	2
 7460              		.set	.LANCHOR2,. + 0
 7463              	ExTime:
 7464 0000 9C       		.byte	-100
 7465 0001 00       		.byte	0
 7466 0002 4E       		.byte	78
 7467 0003 00       		.byte	0
 7468 0004 27       		.byte	39
 7469 0005 00       		.byte	0
 7470 0006 14       		.byte	20
 7471 0007 00       		.byte	0
 7472 0008 0A       		.byte	10
 7473 0009 00       		.byte	0
 7474 000a 05       		.byte	5
 7475 000b 00       		.byte	0
 7476 000c 02       		.byte	2
 7477 000d 00       		.byte	0
 7478 000e 01       		.byte	1
 7479 000f 00       		.byte	0
 7482              	CyFxGpifConfig:
 7483 0010 0F00     		.short	15
 7484 0012 0000     		.space	2
 7485 0014 00000000 		.word	CyFxGpifWavedata
 7486 0018 00000000 		.word	CyFxGpifWavedataPosition
 7487 001c 0500     		.short	5
 7488 001e 0000     		.space	2
 7489 0020 00000000 		.word	CyFxGpifTransition
 7490 0024 4C00     		.short	76
 7491 0026 0000     		.space	2
 7492 0028 00000000 		.word	CyFxGpifRegValue
 7495              	CyFxGpifConfig_usb2_480:
 7496 002c 9B00     		.short	155
 7497 002e 0000     		.space	2
 7498 0030 00000000 		.word	CyFxGpifWavedata_usb2_480
 7499 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2_480
 7500 0038 0900     		.short	9
 7501 003a 0000     		.space	2
 7502 003c 00000000 		.word	CyFxGpifTransition_usb2_480
 7503 0040 4C00     		.short	76
 7504 0042 0000     		.space	2
 7505 0044 00000000 		.word	CyFxGpifRegValue_usb2_480
 7508              	CyFxGpifConfig_usb2_640:
 7509 0048 9B00     		.short	155
 7510 004a 0000     		.space	2
 7511 004c 00000000 		.word	CyFxGpifWavedata_usb2_640
 7512 0050 00000000 		.word	CyFxGpifWavedataPosition_usb2_640
 7513 0054 0900     		.short	9
 7514 0056 0000     		.space	2
 7515 0058 00000000 		.word	CyFxGpifTransition_usb2_640
 7516 005c 4C00     		.short	76
 7517 005e 0000     		.space	2
 7518 0060 00000000 		.word	CyFxGpifRegValue_usb2_640
 7519              		.data
 7520              		.align	2
 7521              		.set	.LANCHOR1,. + 0
 7524              	ExUCtrlParArry:
 7525 0000 13       		.byte	19
 7526 0001 14       		.byte	20
 7527 0002 02       		.byte	2
 7528 0003 01       		.byte	1
 7529 0004 00       		.byte	0
 7530 0005 03       		.byte	3
 7531 0006 00       		.byte	0
 7532 0007 01       		.byte	1
 7533 0008 00       		.byte	0
 7534 0009 03       		.byte	3
 7535 000a 00       		.byte	0
 7536 000b 23       		.byte	35
 7537 000c 37       		.byte	55
 7538 000d 23       		.byte	35
 7539 000e 37       		.byte	55
 7540 000f 30       		.byte	48
 7541 0010 01       		.byte	1
 7542 0011 00       		.byte	0
 7543 0012 00       		.byte	0
 7544 0013 00000000 		.space	5
 7544      00
 7545 0018 11       		.byte	17
 7546 0019 00       		.byte	0
 7547 001a 02       		.byte	2
 7548 001b 01       		.byte	1
 7549 001c 00       		.byte	0
 7550 001d 03       		.byte	3
 7551 001e 00       		.byte	0
 7552 001f 01       		.byte	1
 7553 0020 00       		.byte	0
 7554 0021 03       		.byte	3
 7555 0022 00       		.byte	0
 7556 0023 01       		.byte	1
 7557 0024 00       		.byte	0
 7558 0025 01       		.byte	1
 7559 0026 00       		.byte	0
 7560 0027 30       		.byte	48
 7561 0028 01       		.byte	1
 7562 0029 01       		.byte	1
 7563 002a 00       		.byte	0
 7564 002b 00000000 		.space	5
 7564      00
 7565 0030 17       		.byte	23
 7566 0031 00       		.byte	0
 7567 0032 01       		.byte	1
 7568 0033 01       		.byte	1
 7569 0034 00       		.byte	0
 7570 0035 02       		.byte	2
 7571 0036 00       		.byte	0
 7572 0037 01       		.byte	1
 7573 0038 00       		.byte	0
 7574 0039 03       		.byte	3
 7575 003a 00       		.byte	0
 7576 003b 00       		.byte	0
 7577 003c 00       		.byte	0
 7578 003d 00       		.byte	0
 7579 003e 00       		.byte	0
 7580 003f 30       		.byte	48
 7581 0040 01       		.byte	1
 7582 0041 01       		.byte	1
 7583 0042 00       		.byte	0
 7584 0043 00000000 		.space	5
 7584      00
 7585 0048 00       		.byte	0
 7586 0049 00       		.byte	0
 7587 004a 04       		.byte	4
 7588 004b 01       		.byte	1
 7589 004c 00       		.byte	0
 7590 004d 38       		.byte	56
 7591 004e 01       		.byte	1
 7592 004f 01       		.byte	1
 7593 0050 00       		.byte	0
 7594 0051 03       		.byte	3
 7595 0052 00       		.byte	0
 7596 0053 4E       		.byte	78
 7597 0054 00       		.byte	0
 7598 0055 4E       		.byte	78
 7599 0056 00       		.byte	0
 7600 0057 30       		.byte	48
 7601 0058 01       		.byte	1
 7602 0059 00       		.byte	0
 7603 005a 00       		.byte	0
 7604 005b 00000000 		.space	5
 7604      00
 7605 0060 00       		.byte	0
 7606 0061 00       		.byte	0
 7607 0062 01       		.byte	1
 7608 0063 00       		.byte	0
 7609 0064 00       		.byte	0
 7610 0065 00       		.byte	0
 7611 0066 00       		.byte	0
 7612 0067 01       		.byte	1
 7613 0068 00       		.byte	0
 7614 0069 03       		.byte	3
 7615 006a 00       		.byte	0
 7616 006b 00       		.byte	0
 7617 006c 00       		.byte	0
 7618 006d 00       		.byte	0
 7619 006e 00       		.byte	0
 7620 006f 30       		.byte	48
 7621 0070 01       		.byte	1
 7622 0071 00       		.byte	0
 7623 0072 00       		.byte	0
 7624 0073 00000000 		.space	5
 7624      00
 7625 0078 00       		.byte	0
 7626 0079 00       		.byte	0
 7627 007a 02       		.byte	2
 7628 007b 00       		.byte	0
 7629 007c 00       		.byte	0
 7630 007d FF       		.byte	-1
 7631 007e 00       		.byte	0
 7632 007f 01       		.byte	1
 7633 0080 00       		.byte	0
 7634 0081 03       		.byte	3
 7635 0082 00       		.byte	0
 7636 0083 01       		.byte	1
 7637 0084 00       		.byte	0
 7638 0085 00       		.byte	0
 7639 0086 00       		.byte	0
 7640 0087 30       		.byte	48
 7641 0088 01       		.byte	1
 7642 0089 01       		.byte	1
 7643 008a 00       		.byte	0
 7644 008b 00000000 		.space	5
 7644      00
 7645 0090 00       		.byte	0
 7646 0091 00       		.byte	0
 7647 0092 02       		.byte	2
 7648 0093 00       		.byte	0
 7649 0094 00       		.byte	0
 7650 0095 00       		.byte	0
 7651 0096 00       		.byte	0
 7652 0097 00       		.byte	0
 7653 0098 00       		.byte	0
 7654 0099 03       		.byte	3
 7655 009a 00       		.byte	0
 7656 009b 00       		.byte	0
 7657 009c 00       		.byte	0
 7658 009d 00       		.byte	0
 7659 009e 00       		.byte	0
 7660 009f 30       		.byte	48
 7661 00a0 01       		.byte	1
 7662 00a1 01       		.byte	1
 7663 00a2 00       		.byte	0
 7664 00a3 00000000 		.space	5
 7664      00
 7665 00a8 00       		.byte	0
 7666 00a9 00       		.byte	0
 7667 00aa 02       		.byte	2
 7668 00ab 00       		.byte	0
 7669 00ac 00       		.byte	0
 7670 00ad 30       		.byte	48
 7671 00ae 00       		.byte	0
 7672 00af 01       		.byte	1
 7673 00b0 00       		.byte	0
 7674 00b1 03       		.byte	3
 7675 00b2 0A       		.byte	10
 7676 00b3 00       		.byte	0
 7677 00b4 00       		.byte	0
 7678 00b5 0A       		.byte	10
 7679 00b6 00       		.byte	0
 7680 00b7 30       		.byte	48
 7681 00b8 01       		.byte	1
 7682 00b9 01       		.byte	1
 7683 00ba 00       		.byte	0
 7684 00bb 00000000 		.space	5
 7684      00
 7685 00c0 00       		.byte	0
 7686 00c1 00       		.byte	0
 7687 00c2 01       		.byte	1
 7688 00c3 00       		.byte	0
 7689 00c4 00       		.byte	0
 7690 00c5 7F       		.byte	127
 7691 00c6 00       		.byte	0
 7692 00c7 01       		.byte	1
 7693 00c8 00       		.byte	0
 7694 00c9 03       		.byte	3
 7695 00ca 00       		.byte	0
 7696 00cb 00       		.byte	0
 7697 00cc 00       		.byte	0
 7698 00cd 00       		.byte	0
 7699 00ce 00       		.byte	0
 7700 00cf 30       		.byte	48
 7701 00d0 01       		.byte	1
 7702 00d1 00       		.byte	0
 7703 00d2 00       		.byte	0
 7704 00d3 00000000 		.space	5
 7704      00
 7705 00d8 00       		.byte	0
 7706 00d9 00       		.byte	0
 7707 00da 02       		.byte	2
 7708 00db 00       		.byte	0
 7709 00dc 00       		.byte	0
 7710 00dd 05       		.byte	5
 7711 00de 00       		.byte	0
 7712 00df 01       		.byte	1
 7713 00e0 00       		.byte	0
 7714 00e1 03       		.byte	3
 7715 00e2 00       		.byte	0
 7716 00e3 00       		.byte	0
 7717 00e4 00       		.byte	0
 7718 00e5 00       		.byte	0
 7719 00e6 00       		.byte	0
 7720 00e7 30       		.byte	48
 7721 00e8 01       		.byte	1
 7722 00e9 00       		.byte	0
 7723 00ea 00       		.byte	0
 7724 00eb 00000000 		.space	5
 7724      00
 7725 00f0 00       		.byte	0
 7726 00f1 00       		.byte	0
 7727 00f2 03       		.byte	3
 7728 00f3 00       		.byte	0
 7729 00f4 00       		.byte	0
 7730 00f5 0A       		.byte	10
 7731 00f6 00       		.byte	0
 7732 00f7 01       		.byte	1
 7733 00f8 00       		.byte	0
 7734 00f9 03       		.byte	3
 7735 00fa 00       		.byte	0
 7736 00fb 00       		.byte	0
 7737 00fc 00       		.byte	0
 7738 00fd 00       		.byte	0
 7739 00fe 00       		.byte	0
 7740 00ff 30       		.byte	48
 7741 0100 01       		.byte	1
 7742 0101 00       		.byte	0
 7743 0102 00       		.byte	0
 7744 0103 00000000 		.space	5
 7744      00
 7745 0108 00       		.byte	0
 7746 0109 00       		.byte	0
 7747 010a 02       		.byte	2
 7748 010b 00       		.byte	0
 7749 010c 00       		.byte	0
 7750 010d 40       		.byte	64
 7751 010e 00       		.byte	0
 7752 010f 01       		.byte	1
 7753 0110 00       		.byte	0
 7754 0111 03       		.byte	3
 7755 0112 00       		.byte	0
 7756 0113 0F       		.byte	15
 7757 0114 11       		.byte	17
 7758 0115 00       		.byte	0
 7759 0116 00       		.byte	0
 7760 0117 30       		.byte	48
 7761 0118 01       		.byte	1
 7762 0119 00       		.byte	0
 7763 011a 00       		.byte	0
 7764 011b 00000000 		.space	5
 7764      00
 7765 0120 00       		.byte	0
 7766 0121 00       		.byte	0
 7767 0122 02       		.byte	2
 7768 0123 00       		.byte	0
 7769 0124 00       		.byte	0
 7770 0125 64       		.byte	100
 7771 0126 00       		.byte	0
 7772 0127 01       		.byte	1
 7773 0128 00       		.byte	0
 7774 0129 03       		.byte	3
 7775 012a 00       		.byte	0
 7776 012b 00       		.byte	0
 7777 012c 00       		.byte	0
 7778 012d 00       		.byte	0
 7779 012e 00       		.byte	0
 7780 012f 30       		.byte	48
 7781 0130 01       		.byte	1
 7782 0131 00       		.byte	0
 7783 0132 00       		.byte	0
 7784 0133 00000000 		.space	5
 7784      00
 7785 0138 00       		.byte	0
 7786 0139 00       		.byte	0
 7787 013a 02       		.byte	2
 7788 013b 00       		.byte	0
 7789 013c 00       		.byte	0
 7790 013d 64       		.byte	100
 7791 013e 00       		.byte	0
 7792 013f 01       		.byte	1
 7793 0140 00       		.byte	0
 7794 0141 03       		.byte	3
 7795 0142 00       		.byte	0
 7796 0143 00       		.byte	0
 7797 0144 00       		.byte	0
 7798 0145 00       		.byte	0
 7799 0146 00       		.byte	0
 7800 0147 30       		.byte	48
 7801 0148 01       		.byte	1
 7802 0149 00       		.byte	0
 7803 014a 00       		.byte	0
 7804 014b 00000000 		.space	5
 7804      00
 7805 0150 00       		.byte	0
 7806 0151 00       		.byte	0
 7807 0152 02       		.byte	2
 7808 0153 00       		.byte	0
 7809 0154 00       		.byte	0
 7810 0155 64       		.byte	100
 7811 0156 00       		.byte	0
 7812 0157 01       		.byte	1
 7813 0158 00       		.byte	0
 7814 0159 03       		.byte	3
 7815 015a 00       		.byte	0
 7816 015b 00       		.byte	0
 7817 015c 00       		.byte	0
 7818 015d 00       		.byte	0
 7819 015e 00       		.byte	0
 7820 015f 30       		.byte	48
 7821 0160 01       		.byte	1
 7822 0161 00       		.byte	0
 7823 0162 00       		.byte	0
 7824 0163 00000000 		.space	5
 7824      00
 7825 0168 00       		.byte	0
 7826 0169 00       		.byte	0
 7827 016a 02       		.byte	2
 7828 016b 00       		.byte	0
 7829 016c 00       		.byte	0
 7830 016d 64       		.byte	100
 7831 016e 00       		.byte	0
 7832 016f 01       		.byte	1
 7833 0170 00       		.byte	0
 7834 0171 03       		.byte	3
 7835 0172 00       		.byte	0
 7836 0173 00       		.byte	0
 7837 0174 00       		.byte	0
 7838 0175 00       		.byte	0
 7839 0176 00       		.byte	0
 7840 0177 30       		.byte	48
 7841 0178 01       		.byte	1
 7842 0179 00       		.byte	0
 7843 017a 00       		.byte	0
 7844 017b 00000000 		.space	5
 7844      00
 7847              	CtrlParArry:
 7848 0180 10       		.byte	16
 7849 0181 10       		.byte	16
 7850 0182 02       		.byte	2
 7851 0183 00       		.byte	0
 7852 0184 00       		.byte	0
 7853 0185 03       		.byte	3
 7854 0186 00       		.byte	0
 7855 0187 01       		.byte	1
 7856 0188 00       		.byte	0
 7857 0189 03       		.byte	3
 7858 018a 00       		.byte	0
 7859 018b 03       		.byte	3
 7860 018c 00       		.byte	0
 7861 018d 03       		.byte	3
 7862 018e 00       		.byte	0
 7863 018f 30       		.byte	48
 7864 0190 01       		.byte	1
 7865 0191 00       		.byte	0
 7866 0192 00       		.byte	0
 7867 0193 00000000 		.space	5
 7867      00
 7868 0198 01       		.byte	1
 7869 0199 00       		.byte	0
 7870 019a 02       		.byte	2
 7871 019b 00       		.byte	0
 7872 019c 00       		.byte	0
 7873 019d FF       		.byte	-1
 7874 019e 00       		.byte	0
 7875 019f 01       		.byte	1
 7876 01a0 00       		.byte	0
 7877 01a1 03       		.byte	3
 7878 01a2 00       		.byte	0
 7879 01a3 76       		.byte	118
 7880 01a4 00       		.byte	0
 7881 01a5 76       		.byte	118
 7882 01a6 C7       		.byte	-57
 7883 01a7 C6       		.byte	-58
 7884 01a8 01       		.byte	1
 7885 01a9 01       		.byte	1
 7886 01aa 00       		.byte	0
 7887 01ab 00000000 		.space	5
 7887      00
 7888 01b0 02       		.byte	2
 7889 01b1 02       		.byte	2
 7890 01b2 02       		.byte	2
 7891 01b3 00       		.byte	0
 7892 01b4 00       		.byte	0
 7893 01b5 FF       		.byte	-1
 7894 01b6 00       		.byte	0
 7895 01b7 01       		.byte	1
 7896 01b8 00       		.byte	0
 7897 01b9 03       		.byte	3
 7898 01ba 00       		.byte	0
 7899 01bb 70       		.byte	112
 7900 01bc 00       		.byte	0
 7901 01bd 70       		.byte	112
 7902 01be 00       		.byte	0
 7903 01bf C6       		.byte	-58
 7904 01c0 01       		.byte	1
 7905 01c1 01       		.byte	1
 7906 01c2 00       		.byte	0
 7907 01c3 00000000 		.space	5
 7907      00
 7908 01c8 00       		.byte	0
 7909 01c9 00       		.byte	0
 7910 01ca 02       		.byte	2
 7911 01cb 00       		.byte	0
 7912 01cc 00       		.byte	0
 7913 01cd 64       		.byte	100
 7914 01ce 00       		.byte	0
 7915 01cf 01       		.byte	1
 7916 01d0 00       		.byte	0
 7917 01d1 03       		.byte	3
 7918 01d2 00       		.byte	0
 7919 01d3 00       		.byte	0
 7920 01d4 00       		.byte	0
 7921 01d5 00       		.byte	0
 7922 01d6 00       		.byte	0
 7923 01d7 30       		.byte	48
 7924 01d8 01       		.byte	1
 7925 01d9 00       		.byte	0
 7926 01da 00       		.byte	0
 7927 01db 00000000 		.space	5
 7927      00
 7928 01e0 07       		.byte	7
 7929 01e1 07       		.byte	7
 7930 01e2 02       		.byte	2
 7931 01e3 00       		.byte	0
 7932 01e4 00       		.byte	0
 7933 01e5 01       		.byte	1
 7934 01e6 00       		.byte	0
 7935 01e7 01       		.byte	1
 7936 01e8 00       		.byte	0
 7937 01e9 03       		.byte	3
 7938 01ea 00       		.byte	0
 7939 01eb 01       		.byte	1
 7940 01ec 00       		.byte	0
 7941 01ed 01       		.byte	1
 7942 01ee 00       		.byte	0
 7943 01ef 30       		.byte	48
 7944 01f0 01       		.byte	1
 7945 01f1 00       		.byte	0
 7946 01f2 00       		.byte	0
 7947 01f3 00000000 		.space	5
 7947      00
 7948 01f8 DF       		.byte	-33
 7949 01f9 E1       		.byte	-31
 7950 01fa 02       		.byte	2
 7951 01fb 00       		.byte	0
 7952 01fc 00       		.byte	0
 7953 01fd FF       		.byte	-1
 7954 01fe 00       		.byte	0
 7955 01ff 01       		.byte	1
 7956 0200 00       		.byte	0
 7957 0201 03       		.byte	3
 7958 0202 00       		.byte	0
 7959 0203 80       		.byte	-128
 7960 0204 00       		.byte	0
 7961 0205 00       		.byte	0
 7962 0206 00       		.byte	0
 7963 0207 C6       		.byte	-58
 7964 0208 01       		.byte	1
 7965 0209 01       		.byte	1
 7966 020a 00       		.byte	0
 7967 020b 00000000 		.space	5
 7967      00
 7968 0210 85       		.byte	-123
 7969 0211 86       		.byte	-122
 7970 0212 02       		.byte	2
 7971 0213 00       		.byte	0
 7972 0214 00       		.byte	0
 7973 0215 64       		.byte	100
 7974 0216 00       		.byte	0
 7975 0217 01       		.byte	1
 7976 0218 00       		.byte	0
 7977 0219 03       		.byte	3
 7978 021a 00       		.byte	0
 7979 021b 32       		.byte	50
 7980 021c 00       		.byte	0
 7981 021d 32       		.byte	50
 7982 021e 00       		.byte	0
 7983 021f F2       		.byte	-14
 7984 0220 01       		.byte	1
 7985 0221 01       		.byte	1
 7986 0222 00       		.byte	0
 7987 0223 00000000 		.space	5
 7987      00
 7988 0228 06       		.byte	6
 7989 0229 06       		.byte	6
 7990 022a 02       		.byte	2
 7991 022b 00       		.byte	0
 7992 022c 00       		.byte	0
 7993 022d 40       		.byte	64
 7994 022e 00       		.byte	0
 7995 022f 01       		.byte	1
 7996 0230 00       		.byte	0
 7997 0231 03       		.byte	3
 7998 0232 00       		.byte	0
 7999 0233 20       		.byte	32
 8000 0234 00       		.byte	0
 8001 0235 20       		.byte	32
 8002 0236 00       		.byte	0
 8003 0237 30       		.byte	48
 8004 0238 01       		.byte	1
 8005 0239 01       		.byte	1
 8006 023a 00       		.byte	0
 8007 023b 00000000 		.space	5
 8007      00
 8008 0240 00       		.byte	0
 8009 0241 00       		.byte	0
 8010 0242 02       		.byte	2
 8011 0243 00       		.byte	0
 8012 0244 00       		.byte	0
 8013 0245 64       		.byte	100
 8014 0246 00       		.byte	0
 8015 0247 01       		.byte	1
 8016 0248 00       		.byte	0
 8017 0249 03       		.byte	3
 8018 024a 00       		.byte	0
 8019 024b 00       		.byte	0
 8020 024c 00       		.byte	0
 8021 024d 00       		.byte	0
 8022 024e 00       		.byte	0
 8023 024f 30       		.byte	48
 8024 0250 01       		.byte	1
 8025 0251 00       		.byte	0
 8026 0252 00       		.byte	0
 8027 0253 00000000 		.space	5
 8027      00
 8028 0258 08       		.byte	8
 8029 0259 08       		.byte	8
 8030 025a 02       		.byte	2
 8031 025b 00       		.byte	0
 8032 025c 00       		.byte	0
 8033 025d 05       		.byte	5
 8034 025e 00       		.byte	0
 8035 025f 01       		.byte	1
 8036 0260 00       		.byte	0
 8037 0261 03       		.byte	3
 8038 0262 00       		.byte	0
 8039 0263 00       		.byte	0
 8040 0264 00       		.byte	0
 8041 0265 00       		.byte	0
 8042 0266 00       		.byte	0
 8043 0267 30       		.byte	48
 8044 0268 01       		.byte	1
 8045 0269 00       		.byte	0
 8046 026a 00       		.byte	0
 8047 026b 00000000 		.space	5
 8047      00
 8048 0270 00       		.byte	0
 8049 0271 00       		.byte	0
 8050 0272 02       		.byte	2
 8051 0273 00       		.byte	0
 8052 0274 00       		.byte	0
 8053 0275 40       		.byte	64
 8054 0276 00       		.byte	0
 8055 0277 01       		.byte	1
 8056 0278 00       		.byte	0
 8057 0279 03       		.byte	3
 8058 027a 00       		.byte	0
 8059 027b 00       		.byte	0
 8060 027c 00       		.byte	0
 8061 027d 00       		.byte	0
 8062 027e 00       		.byte	0
 8063 027f 30       		.byte	48
 8064 0280 01       		.byte	1
 8065 0281 00       		.byte	0
 8066 0282 00       		.byte	0
 8067 0283 00000000 		.space	5
 8067      00
 8068 0288 09       		.byte	9
 8069 0289 0A       		.byte	10
 8070 028a 04       		.byte	4
 8071 028b 00       		.byte	0
 8072 028c 00       		.byte	0
 8073 028d 40       		.byte	64
 8074 028e 00       		.byte	0
 8075 028f 01       		.byte	1
 8076 0290 00       		.byte	0
 8077 0291 03       		.byte	3
 8078 0292 00       		.byte	0
 8079 0293 20       		.byte	32
 8080 0294 38       		.byte	56
 8081 0295 20       		.byte	32
 8082 0296 38       		.byte	56
 8083 0297 30       		.byte	48
 8084 0298 01       		.byte	1
 8085 0299 00       		.byte	0
 8086 029a 00       		.byte	0
 8087 029b 00000000 		.space	5
 8087      00
 8088 02a0 00       		.byte	0
 8089 02a1 00       		.byte	0
 8090 02a2 02       		.byte	2
 8091 02a3 00       		.byte	0
 8092 02a4 00       		.byte	0
 8093 02a5 64       		.byte	100
 8094 02a6 00       		.byte	0
 8095 02a7 01       		.byte	1
 8096 02a8 00       		.byte	0
 8097 02a9 03       		.byte	3
 8098 02aa 00       		.byte	0
 8099 02ab 00       		.byte	0
 8100 02ac 00       		.byte	0
 8101 02ad 00       		.byte	0
 8102 02ae 00       		.byte	0
 8103 02af 30       		.byte	48
 8104 02b0 01       		.byte	1
 8105 02b1 00       		.byte	0
 8106 02b2 00       		.byte	0
 8107 02b3 00000000 		.space	5
 8107      00
 8108 02b8 00       		.byte	0
 8109 02b9 00       		.byte	0
 8110 02ba 02       		.byte	2
 8111 02bb 00       		.byte	0
 8112 02bc 00       		.byte	0
 8113 02bd 64       		.byte	100
 8114 02be 00       		.byte	0
 8115 02bf 01       		.byte	1
 8116 02c0 00       		.byte	0
 8117 02c1 03       		.byte	3
 8118 02c2 00       		.byte	0
 8119 02c3 00       		.byte	0
 8120 02c4 00       		.byte	0
 8121 02c5 00       		.byte	0
 8122 02c6 00       		.byte	0
 8123 02c7 30       		.byte	48
 8124 02c8 01       		.byte	1
 8125 02c9 00       		.byte	0
 8126 02ca 00       		.byte	0
 8127 02cb 00000000 		.space	5
 8127      00
 8128 02d0 2A       		.byte	42
 8129 02d1 2A       		.byte	42
 8130 02d2 02       		.byte	2
 8131 02d3 00       		.byte	0
 8132 02d4 00       		.byte	0
 8133 02d5 1B       		.byte	27
 8134 02d6 00       		.byte	0
 8135 02d7 01       		.byte	1
 8136 02d8 00       		.byte	0
 8137 02d9 03       		.byte	3
 8138 02da 00       		.byte	0
 8139 02db 00       		.byte	0
 8140 02dc 00       		.byte	0
 8141 02dd 00       		.byte	0
 8142 02de 00       		.byte	0
 8143 02df 30       		.byte	48
 8144 02e0 01       		.byte	1
 8145 02e1 00       		.byte	0
 8146 02e2 00       		.byte	0
 8147 02e3 00000000 		.space	5
 8147      00
 8148 02e8 00       		.byte	0
 8149 02e9 00       		.byte	0
 8150 02ea 02       		.byte	2
 8151 02eb 00       		.byte	0
 8152 02ec 00       		.byte	0
 8153 02ed 64       		.byte	100
 8154 02ee 00       		.byte	0
 8155 02ef 01       		.byte	1
 8156 02f0 00       		.byte	0
 8157 02f1 03       		.byte	3
 8158 02f2 00       		.byte	0
 8159 02f3 00       		.byte	0
 8160 02f4 00       		.byte	0
 8161 02f5 00       		.byte	0
 8162 02f6 00       		.byte	0
 8163 02f7 30       		.byte	48
 8164 02f8 01       		.byte	1
 8165 02f9 00       		.byte	0
 8166 02fa 00       		.byte	0
 8167 02fb 00000000 		.space	5
 8167      00
 8168 0300 00       		.byte	0
 8169 0301 00       		.byte	0
 8170 0302 02       		.byte	2
 8171 0303 00       		.byte	0
 8172 0304 00       		.byte	0
 8173 0305 12       		.byte	18
 8174 0306 00       		.byte	0
 8175 0307 01       		.byte	1
 8176 0308 00       		.byte	0
 8177 0309 03       		.byte	3
 8178 030a 00       		.byte	0
 8179 030b 00       		.byte	0
 8180 030c 00       		.byte	0
 8181 030d 00       		.byte	0
 8182 030e 00       		.byte	0
 8183 030f 30       		.byte	48
 8184 0310 01       		.byte	1
 8185 0311 00       		.byte	0
 8186 0312 00       		.byte	0
 8187 0313 00000000 		.space	5
 8187      00
 8188 0318 01       		.byte	1
 8189 0319 01       		.byte	1
 8190 031a 02       		.byte	2
 8191 031b 00       		.byte	0
 8192 031c 00       		.byte	0
 8193 031d 09       		.byte	9
 8194 031e 00       		.byte	0
 8195 031f 01       		.byte	1
 8196 0320 00       		.byte	0
 8197 0321 03       		.byte	3
 8198 0322 00       		.byte	0
 8199 0323 00       		.byte	0
 8200 0324 00       		.byte	0
 8201 0325 01       		.byte	1
 8202 0326 00       		.byte	0
 8203 0327 30       		.byte	48
 8204 0328 01       		.byte	1
 8205 0329 00       		.byte	0
 8206 032a 00       		.byte	0
 8207 032b 00000000 		.space	5
 8207      00
 8208 0330 05       		.byte	5
 8209 0331 05       		.byte	5
 8210 0332 02       		.byte	2
 8211 0333 00       		.byte	0
 8212 0334 00       		.byte	0
 8213 0335 03       		.byte	3
 8214 0336 00       		.byte	0
 8215 0337 01       		.byte	1
 8216 0338 00       		.byte	0
 8217 0339 03       		.byte	3
 8218 033a 00       		.byte	0
 8219 033b 00       		.byte	0
 8220 033c 00       		.byte	0
 8221 033d 02       		.byte	2
 8222 033e 00       		.byte	0
 8223 033f 30       		.byte	48
 8224 0340 01       		.byte	1
 8225 0341 00       		.byte	0
 8226 0342 00       		.byte	0
 8227 0343 00000000 		.space	5
 8227      00
 8228 0348 18       		.byte	24
 8229 0349 18       		.byte	24
 8230 034a 02       		.byte	2
 8231 034b 00       		.byte	0
 8232 034c 00       		.byte	0
 8233 034d 01       		.byte	1
 8234 034e 00       		.byte	0
 8235 034f 01       		.byte	1
 8236 0350 00       		.byte	0
 8237 0351 03       		.byte	3
 8238 0352 00       		.byte	0
 8239 0353 00       		.byte	0
 8240 0354 00       		.byte	0
 8241 0355 00       		.byte	0
 8242 0356 00       		.byte	0
 8243 0357 30       		.byte	48
 8244 0358 01       		.byte	1
 8245 0359 00       		.byte	0
 8246 035a 00       		.byte	0
 8247 035b 00000000 		.space	5
 8247      00
 8248 0360 19       		.byte	25
 8249 0361 19       		.byte	25
 8250 0362 01       		.byte	1
 8251 0363 00       		.byte	0
 8252 0364 00       		.byte	0
 8253 0365 40       		.byte	64
 8254 0366 00       		.byte	0
 8255 0367 01       		.byte	1
 8256 0368 00       		.byte	0
 8257 0369 03       		.byte	3
 8258 036a 00       		.byte	0
 8259 036b 20       		.byte	32
 8260 036c 00       		.byte	0
 8261 036d 20       		.byte	32
 8262 036e 00       		.byte	0
 8263 036f 30       		.byte	48
 8264 0370 01       		.byte	1
 8265 0371 00       		.byte	0
 8266 0372 00       		.byte	0
 8267 0373 00000000 		.space	5
 8267      00
 8268 0378 20       		.byte	32
 8269 0379 20       		.byte	32
 8270 037a 02       		.byte	2
 8271 037b 00       		.byte	0
 8272 037c 00       		.byte	0
 8273 037d 02       		.byte	2
 8274 037e 00       		.byte	0
 8275 037f 01       		.byte	1
 8276 0380 00       		.byte	0
 8277 0381 03       		.byte	3
 8278 0382 00       		.byte	0
 8279 0383 00       		.byte	0
 8280 0384 00       		.byte	0
 8281 0385 00       		.byte	0
 8282 0386 00       		.byte	0
 8283 0387 30       		.byte	48
 8284 0388 01       		.byte	1
 8285 0389 00       		.byte	0
 8286 038a 00       		.byte	0
 8287 038b 00000000 		.space	5
 8287      00
 8288 0390 22       		.byte	34
 8289 0391 22       		.byte	34
 8290 0392 02       		.byte	2
 8291 0393 00       		.byte	0
 8292 0394 00       		.byte	0
 8293 0395 3F       		.byte	63
 8294 0396 00       		.byte	0
 8295 0397 01       		.byte	1
 8296 0398 00       		.byte	0
 8297 0399 03       		.byte	3
 8298 039a 00       		.byte	0
 8299 039b 00       		.byte	0
 8300 039c 00       		.byte	0
 8301 039d 00       		.byte	0
 8302 039e 00       		.byte	0
 8303 039f 30       		.byte	48
 8304 03a0 01       		.byte	1
 8305 03a1 00       		.byte	0
 8306 03a2 00       		.byte	0
 8307 03a3 00000000 		.space	5
 8307      00
 8308 03a8 23       		.byte	35
 8309 03a9 23       		.byte	35
 8310 03aa 02       		.byte	2
 8311 03ab 00       		.byte	0
 8312 03ac 00       		.byte	0
 8313 03ad 64       		.byte	100
 8314 03ae 00       		.byte	0
 8315 03af 01       		.byte	1
 8316 03b0 00       		.byte	0
 8317 03b1 03       		.byte	3
 8318 03b2 00       		.byte	0
 8319 03b3 10       		.byte	16
 8320 03b4 00       		.byte	0
 8321 03b5 10       		.byte	16
 8322 03b6 00       		.byte	0
 8323 03b7 30       		.byte	48
 8324 03b8 01       		.byte	1
 8325 03b9 00       		.byte	0
 8326 03ba 00       		.byte	0
 8327 03bb 00000000 		.space	5
 8327      00
 8328 03c0 24       		.byte	36
 8329 03c1 24       		.byte	36
 8330 03c2 02       		.byte	2
 8331 03c3 00       		.byte	0
 8332 03c4 00       		.byte	0
 8333 03c5 64       		.byte	100
 8334 03c6 00       		.byte	0
 8335 03c7 01       		.byte	1
 8336 03c8 00       		.byte	0
 8337 03c9 03       		.byte	3
 8338 03ca 00       		.byte	0
 8339 03cb 10       		.byte	16
 8340 03cc 00       		.byte	0
 8341 03cd 10       		.byte	16
 8342 03ce 00       		.byte	0
 8343 03cf 30       		.byte	48
 8344 03d0 01       		.byte	1
 8345 03d1 00       		.byte	0
 8346 03d2 00       		.byte	0
 8347 03d3 00000000 		.space	5
 8347      00
 8348 03d8 02       		.byte	2
 8349 03d9 03       		.byte	3
 8350 03da 04       		.byte	4
 8351 03db 00       		.byte	0
 8352 03dc 00       		.byte	0
 8353 03dd 7F       		.byte	127
 8354 03de 00       		.byte	0
 8355 03df 01       		.byte	1
 8356 03e0 00       		.byte	0
 8357 03e1 03       		.byte	3
 8358 03e2 00       		.byte	0
 8359 03e3 00       		.byte	0
 8360 03e4 20       		.byte	32
 8361 03e5 00       		.byte	0
 8362 03e6 20       		.byte	32
 8363 03e7 30       		.byte	48
 8364 03e8 01       		.byte	1
 8365 03e9 00       		.byte	0
 8366 03ea 00       		.byte	0
 8367 03eb 00000000 		.space	5
 8367      00
 8368 03f0 04       		.byte	4
 8369 03f1 04       		.byte	4
 8370 03f2 02       		.byte	2
 8371 03f3 00       		.byte	0
 8372 03f4 00       		.byte	0
 8373 03f5 40       		.byte	64
 8374 03f6 00       		.byte	0
 8375 03f7 01       		.byte	1
 8376 03f8 00       		.byte	0
 8377 03f9 03       		.byte	3
 8378 03fa 00       		.byte	0
 8379 03fb 20       		.byte	32
 8380 03fc 00       		.byte	0
 8381 03fd 20       		.byte	32
 8382 03fe 00       		.byte	0
 8383 03ff 30       		.byte	48
 8384 0400 01       		.byte	1
 8385 0401 00       		.byte	0
 8386 0402 00       		.byte	0
 8387 0403 00000000 		.space	5
 8387      00
 8388 0408 00       		.byte	0
 8389 0409 00       		.byte	0
 8390 040a 02       		.byte	2
 8391 040b 00       		.byte	0
 8392 040c 00       		.byte	0
 8393 040d 19       		.byte	25
 8394 040e 00       		.byte	0
 8395 040f 01       		.byte	1
 8396 0410 00       		.byte	0
 8397 0411 03       		.byte	3
 8398 0412 00       		.byte	0
 8399 0413 00       		.byte	0
 8400 0414 00       		.byte	0
 8401 0415 00       		.byte	0
 8402 0416 00       		.byte	0
 8403 0417 30       		.byte	48
 8404 0418 01       		.byte	1
 8405 0419 00       		.byte	0
 8406 041a 00       		.byte	0
 8407 041b 00000000 		.space	5
 8407      00
 8408 0420 10       		.byte	16
 8409 0421 10       		.byte	16
 8410 0422 02       		.byte	2
 8411 0423 00       		.byte	0
 8412 0424 00       		.byte	0
 8413 0425 06       		.byte	6
 8414 0426 00       		.byte	0
 8415 0427 01       		.byte	1
 8416 0428 00       		.byte	0
 8417 0429 03       		.byte	3
 8418 042a 00       		.byte	0
 8419 042b 03       		.byte	3
 8420 042c 00       		.byte	0
 8421 042d 03       		.byte	3
 8422 042e 00       		.byte	0
 8423 042f 30       		.byte	48
 8424 0430 01       		.byte	1
 8425 0431 00       		.byte	0
 8426 0432 00       		.byte	0
 8427 0433 00000000 		.space	5
 8427      00
 8428 0438 00       		.byte	0
 8429 0439 00       		.byte	0
 8430 043a 02       		.byte	2
 8431 043b 00       		.byte	0
 8432 043c 00       		.byte	0
 8433 043d 03       		.byte	3
 8434 043e 00       		.byte	0
 8435 043f 01       		.byte	1
 8436 0440 00       		.byte	0
 8437 0441 03       		.byte	3
 8438 0442 00       		.byte	0
 8439 0443 00       		.byte	0
 8440 0444 00       		.byte	0
 8441 0445 00       		.byte	0
 8442 0446 00       		.byte	0
 8443 0447 30       		.byte	48
 8444 0448 01       		.byte	1
 8445 0449 00       		.byte	0
 8446 044a 00       		.byte	0
 8447 044b 00000000 		.space	5
 8447      00
 8448 0450 50       		.byte	80
 8449 0451 50       		.byte	80
 8450 0452 01       		.byte	1
 8451 0453 00       		.byte	0
 8452 0454 00       		.byte	0
 8453 0455 03       		.byte	3
 8454 0456 00       		.byte	0
 8455 0457 01       		.byte	1
 8456 0458 00       		.byte	0
 8457 0459 03       		.byte	3
 8458 045a 00       		.byte	0
 8459 045b 00       		.byte	0
 8460 045c 00       		.byte	0
 8461 045d 00       		.byte	0
 8462 045e 00       		.byte	0
 8463 045f 30       		.byte	48
 8464 0460 01       		.byte	1
 8465 0461 00       		.byte	0
 8466 0462 00       		.byte	0
 8467 0463 00000000 		.space	5
 8467      00
 8468 0468 00       		.byte	0
 8469 0469 00       		.byte	0
 8470 046a 0B       		.byte	11
 8471 046b 00       		.byte	0
 8472 046c 00       		.byte	0
 8473 046d FF       		.byte	-1
 8474 046e FF       		.byte	-1
 8475 046f 01       		.byte	1
 8476 0470 00       		.byte	0
 8477 0471 03       		.byte	3
 8478 0472 00       		.byte	0
 8479 0473 00       		.byte	0
 8480 0474 00       		.byte	0
 8481 0475 00       		.byte	0
 8482 0476 00       		.byte	0
 8483 0477 00       		.byte	0
 8484 0478 01       		.byte	1
 8485 0479 00       		.byte	0
 8486 047a 00       		.byte	0
 8487 047b 00000000 		.space	5
 8487      00
 8490              	glUVCHeader:
 8491 0480 0C       		.byte	12
 8492 0481 8C       		.byte	-116
 8493 0482 00       		.byte	0
 8494 0483 00       		.byte	0
 8495 0484 00       		.byte	0
 8496 0485 00       		.byte	0
 8497 0486 00       		.byte	0
 8498 0487 00       		.byte	0
 8499 0488 00       		.byte	0
 8500 0489 00       		.byte	0
 8501 048a 00       		.byte	0
 8502 048b 00       		.byte	0
 8505              	WBMenuCmpArry:
 8506 048c 20       		.byte	32
 8507 048d 0F       		.byte	15
 8508 048e 38       		.byte	56
 8509 048f F0       		.byte	-16
 8512              	CTCtrlParArry:
 8513 0490 00       		.byte	0
 8514 0491 00       		.byte	0
 8515 0492 01       		.byte	1
 8516 0493 00       		.byte	0
 8517 0494 00       		.byte	0
 8518 0495 03       		.byte	3
 8519 0496 00       		.byte	0
 8520 0497 01       		.byte	1
 8521 0498 00       		.byte	0
 8522 0499 03       		.byte	3
 8523 049a 00       		.byte	0
 8524 049b 03       		.byte	3
 8525 049c 00       		.byte	0
 8526 049d 03       		.byte	3
 8527 049e 00       		.byte	0
 8528 049f 30       		.byte	48
 8529 04a0 01       		.byte	1
 8530 04a1 00       		.byte	0
 8531 04a2 00       		.byte	0
 8532 04a3 00000000 		.space	5
 8532      00
 8533 04a8 00       		.byte	0
 8534 04a9 00       		.byte	0
 8535 04aa 01       		.byte	1
 8536 04ab 01       		.byte	1
 8537 04ac 00       		.byte	0
 8538 04ad 0F       		.byte	15
 8539 04ae 00       		.byte	0
 8540 04af 0F       		.byte	15
 8541 04b0 00       		.byte	0
 8542 04b1 03       		.byte	3
 8543 04b2 00       		.byte	0
 8544 04b3 02       		.byte	2
 8545 04b4 00       		.byte	0
 8546 04b5 02       		.byte	2
 8547 04b6 00       		.byte	0
 8548 04b7 30       		.byte	48
 8549 04b8 01       		.byte	1
 8550 04b9 01       		.byte	1
 8551 04ba 00       		.byte	0
 8552 04bb 00000000 		.space	5
 8552      00
 8553 04c0 02       		.byte	2
 8554 04c1 00       		.byte	0
 8555 04c2 01       		.byte	1
 8556 04c3 00       		.byte	0
 8557 04c4 00       		.byte	0
 8558 04c5 01       		.byte	1
 8559 04c6 00       		.byte	0
 8560 04c7 01       		.byte	1
 8561 04c8 00       		.byte	0
 8562 04c9 03       		.byte	3
 8563 04ca 00       		.byte	0
 8564 04cb 00       		.byte	0
 8565 04cc 00       		.byte	0
 8566 04cd 00       		.byte	0
 8567 04ce 00       		.byte	0
 8568 04cf 30       		.byte	48
 8569 04d0 01       		.byte	1
 8570 04d1 01       		.byte	1
 8571 04d2 00       		.byte	0
 8572 04d3 00000000 		.space	5
 8572      00
 8573 04d8 00       		.byte	0
 8574 04d9 00       		.byte	0
 8575 04da 04       		.byte	4
 8576 04db 01       		.byte	1
 8577 04dc 00       		.byte	0
 8578 04dd 38       		.byte	56
 8579 04de 01       		.byte	1
 8580 04df 01       		.byte	1
 8581 04e0 00       		.byte	0
 8582 04e1 03       		.byte	3
 8583 04e2 00       		.byte	0
 8584 04e3 4E       		.byte	78
 8585 04e4 00       		.byte	0
 8586 04e5 4E       		.byte	78
 8587 04e6 00       		.byte	0
 8588 04e7 30       		.byte	48
 8589 04e8 01       		.byte	1
 8590 04e9 00       		.byte	0
 8591 04ea 00       		.byte	0
 8592 04eb 00000000 		.space	5
 8592      00
 8593 04f0 04       		.byte	4
 8594 04f1 00       		.byte	0
 8595 04f2 01       		.byte	1
 8596 04f3 00       		.byte	0
 8597 04f4 00       		.byte	0
 8598 04f5 00       		.byte	0
 8599 04f6 00       		.byte	0
 8600 04f7 01       		.byte	1
 8601 04f8 00       		.byte	0
 8602 04f9 03       		.byte	3
 8603 04fa 00       		.byte	0
 8604 04fb 00       		.byte	0
 8605 04fc 00       		.byte	0
 8606 04fd 00       		.byte	0
 8607 04fe 00       		.byte	0
 8608 04ff 30       		.byte	48
 8609 0500 01       		.byte	1
 8610 0501 00       		.byte	0
 8611 0502 00       		.byte	0
 8612 0503 00000000 		.space	5
 8612      00
 8613 0508 05       		.byte	5
 8614 0509 00       		.byte	0
 8615 050a 02       		.byte	2
 8616 050b 00       		.byte	0
 8617 050c 00       		.byte	0
 8618 050d FF       		.byte	-1
 8619 050e 00       		.byte	0
 8620 050f 01       		.byte	1
 8621 0510 00       		.byte	0
 8622 0511 03       		.byte	3
 8623 0512 00       		.byte	0
 8624 0513 01       		.byte	1
 8625 0514 00       		.byte	0
 8626 0515 00       		.byte	0
 8627 0516 00       		.byte	0
 8628 0517 30       		.byte	48
 8629 0518 01       		.byte	1
 8630 0519 01       		.byte	1
 8631 051a 00       		.byte	0
 8632 051b 00000000 		.space	5
 8632      00
 8633 0520 06       		.byte	6
 8634 0521 00       		.byte	0
 8635 0522 02       		.byte	2
 8636 0523 00       		.byte	0
 8637 0524 00       		.byte	0
 8638 0525 00       		.byte	0
 8639 0526 00       		.byte	0
 8640 0527 00       		.byte	0
 8641 0528 00       		.byte	0
 8642 0529 03       		.byte	3
 8643 052a 00       		.byte	0
 8644 052b 00       		.byte	0
 8645 052c 00       		.byte	0
 8646 052d 00       		.byte	0
 8647 052e 00       		.byte	0
 8648 052f 30       		.byte	48
 8649 0530 01       		.byte	1
 8650 0531 01       		.byte	1
 8651 0532 00       		.byte	0
 8652 0533 00000000 		.space	5
 8652      00
 8653 0538 23       		.byte	35
 8654 0539 00       		.byte	0
 8655 053a 02       		.byte	2
 8656 053b 00       		.byte	0
 8657 053c 00       		.byte	0
 8658 053d 30       		.byte	48
 8659 053e 00       		.byte	0
 8660 053f 01       		.byte	1
 8661 0540 00       		.byte	0
 8662 0541 03       		.byte	3
 8663 0542 0A       		.byte	10
 8664 0543 00       		.byte	0
 8665 0544 00       		.byte	0
 8666 0545 0A       		.byte	10
 8667 0546 00       		.byte	0
 8668 0547 30       		.byte	48
 8669 0548 01       		.byte	1
 8670 0549 01       		.byte	1
 8671 054a 00       		.byte	0
 8672 054b 00000000 		.space	5
 8672      00
 8673 0550 08       		.byte	8
 8674 0551 00       		.byte	0
 8675 0552 01       		.byte	1
 8676 0553 00       		.byte	0
 8677 0554 00       		.byte	0
 8678 0555 7F       		.byte	127
 8679 0556 00       		.byte	0
 8680 0557 01       		.byte	1
 8681 0558 00       		.byte	0
 8682 0559 03       		.byte	3
 8683 055a 00       		.byte	0
 8684 055b 00       		.byte	0
 8685 055c 00       		.byte	0
 8686 055d 00       		.byte	0
 8687 055e 00       		.byte	0
 8688 055f 30       		.byte	48
 8689 0560 01       		.byte	1
 8690 0561 00       		.byte	0
 8691 0562 00       		.byte	0
 8692 0563 00000000 		.space	5
 8692      00
 8693 0568 09       		.byte	9
 8694 0569 00       		.byte	0
 8695 056a 02       		.byte	2
 8696 056b 00       		.byte	0
 8697 056c 00       		.byte	0
 8698 056d 05       		.byte	5
 8699 056e 00       		.byte	0
 8700 056f 01       		.byte	1
 8701 0570 00       		.byte	0
 8702 0571 03       		.byte	3
 8703 0572 00       		.byte	0
 8704 0573 00       		.byte	0
 8705 0574 00       		.byte	0
 8706 0575 00       		.byte	0
 8707 0576 00       		.byte	0
 8708 0577 30       		.byte	48
 8709 0578 01       		.byte	1
 8710 0579 00       		.byte	0
 8711 057a 00       		.byte	0
 8712 057b 00000000 		.space	5
 8712      00
 8713 0580 10       		.byte	16
 8714 0581 00       		.byte	0
 8715 0582 03       		.byte	3
 8716 0583 00       		.byte	0
 8717 0584 00       		.byte	0
 8718 0585 00       		.byte	0
 8719 0586 00       		.byte	0
 8720 0587 00       		.byte	0
 8721 0588 00       		.byte	0
 8722 0589 03       		.byte	3
 8723 058a 00       		.byte	0
 8724 058b 00       		.byte	0
 8725 058c 00       		.byte	0
 8726 058d 00       		.byte	0
 8727 058e 00       		.byte	0
 8728 058f 30       		.byte	48
 8729 0590 01       		.byte	1
 8730 0591 00       		.byte	0
 8731 0592 00       		.byte	0
 8732 0593 00000000 		.space	5
 8732      00
 8733 0598 00       		.byte	0
 8734 0599 00       		.byte	0
 8735 059a 02       		.byte	2
 8736 059b 00       		.byte	0
 8737 059c 00       		.byte	0
 8738 059d 40       		.byte	64
 8739 059e 00       		.byte	0
 8740 059f 01       		.byte	1
 8741 05a0 00       		.byte	0
 8742 05a1 03       		.byte	3
 8743 05a2 00       		.byte	0
 8744 05a3 0F       		.byte	15
 8745 05a4 11       		.byte	17
 8746 05a5 00       		.byte	0
 8747 05a6 00       		.byte	0
 8748 05a7 30       		.byte	48
 8749 05a8 01       		.byte	1
 8750 05a9 00       		.byte	0
 8751 05aa 00       		.byte	0
 8752 05ab 00000000 		.space	5
 8752      00
 8753 05b0 00       		.byte	0
 8754 05b1 00       		.byte	0
 8755 05b2 02       		.byte	2
 8756 05b3 00       		.byte	0
 8757 05b4 00       		.byte	0
 8758 05b5 64       		.byte	100
 8759 05b6 00       		.byte	0
 8760 05b7 01       		.byte	1
 8761 05b8 00       		.byte	0
 8762 05b9 03       		.byte	3
 8763 05ba 00       		.byte	0
 8764 05bb 00       		.byte	0
 8765 05bc 00       		.byte	0
 8766 05bd 00       		.byte	0
 8767 05be 00       		.byte	0
 8768 05bf 30       		.byte	48
 8769 05c0 01       		.byte	1
 8770 05c1 00       		.byte	0
 8771 05c2 00       		.byte	0
 8772 05c3 00000000 		.space	5
 8772      00
 8773 05c8 00       		.byte	0
 8774 05c9 00       		.byte	0
 8775 05ca 02       		.byte	2
 8776 05cb 00       		.byte	0
 8777 05cc 00       		.byte	0
 8778 05cd 64       		.byte	100
 8779 05ce 00       		.byte	0
 8780 05cf 01       		.byte	1
 8781 05d0 00       		.byte	0
 8782 05d1 03       		.byte	3
 8783 05d2 00       		.byte	0
 8784 05d3 00       		.byte	0
 8785 05d4 00       		.byte	0
 8786 05d5 00       		.byte	0
 8787 05d6 00       		.byte	0
 8788 05d7 30       		.byte	48
 8789 05d8 01       		.byte	1
 8790 05d9 00       		.byte	0
 8791 05da 00       		.byte	0
 8792 05db 00000000 		.space	5
 8792      00
 8793 05e0 00       		.byte	0
 8794 05e1 00       		.byte	0
 8795 05e2 02       		.byte	2
 8796 05e3 00       		.byte	0
 8797 05e4 00       		.byte	0
 8798 05e5 64       		.byte	100
 8799 05e6 00       		.byte	0
 8800 05e7 01       		.byte	1
 8801 05e8 00       		.byte	0
 8802 05e9 03       		.byte	3
 8803 05ea 00       		.byte	0
 8804 05eb 00       		.byte	0
 8805 05ec 00       		.byte	0
 8806 05ed 00       		.byte	0
 8807 05ee 00       		.byte	0
 8808 05ef 30       		.byte	48
 8809 05f0 01       		.byte	1
 8810 05f1 00       		.byte	0
 8811 05f2 00       		.byte	0
 8812 05f3 00000000 		.space	5
 8812      00
 8813 05f8 00       		.byte	0
 8814 05f9 00       		.byte	0
 8815 05fa 02       		.byte	2
 8816 05fb 00       		.byte	0
 8817 05fc 00       		.byte	0
 8818 05fd 64       		.byte	100
 8819 05fe 00       		.byte	0
 8820 05ff 01       		.byte	1
 8821 0600 00       		.byte	0
 8822 0601 03       		.byte	3
 8823 0602 00       		.byte	0
 8824 0603 00       		.byte	0
 8825 0604 00       		.byte	0
 8826 0605 00       		.byte	0
 8827 0606 00       		.byte	0
 8828 0607 30       		.byte	48
 8829 0608 01       		.byte	1
 8830 0609 00       		.byte	0
 8831 060a 00       		.byte	0
 8832 060b 00000000 		.space	5
 8832      00
 8835              	glProbeCtrl:
 8836 0610 00       		.byte	0
 8837 0611 00       		.byte	0
 8838 0612 01       		.byte	1
 8839 0613 01       		.byte	1
 8840 0614 15       		.byte	21
 8841 0615 16       		.byte	22
 8842 0616 05       		.byte	5
 8843 0617 00       		.byte	0
 8844 0618 00       		.byte	0
 8845 0619 00       		.byte	0
 8846 061a 00       		.byte	0
 8847 061b 00       		.byte	0
 8848 061c 00       		.byte	0
 8849 061d 00       		.byte	0
 8850 061e 00       		.byte	0
 8851 061f 00       		.byte	0
 8852 0620 00       		.byte	0
 8853 0621 00       		.byte	0
 8854 0622 00       		.byte	0
 8855 0623 48       		.byte	72
 8856 0624 3F       		.byte	63
 8857 0625 00       		.byte	0
 8858 0626 00       		.byte	0
 8859 0627 0C       		.byte	12
 8860 0628 00       		.byte	0
 8861 0629 00       		.byte	0
 8862 062a 0000     		.space	2
 8865              	glProbeCtrl20:
 8866 062c 00       		.byte	0
 8867 062d 00       		.byte	0
 8868 062e 01       		.byte	1
 8869 062f 01       		.byte	1
 8870 0630 15       		.byte	21
 8871 0631 16       		.byte	22
 8872 0632 05       		.byte	5
 8873 0633 00       		.byte	0
 8874 0634 00       		.byte	0
 8875 0635 00       		.byte	0
 8876 0636 00       		.byte	0
 8877 0637 00       		.byte	0
 8878 0638 00       		.byte	0
 8879 0639 00       		.byte	0
 8880 063a 00       		.byte	0
 8881 063b 00       		.byte	0
 8882 063c 00       		.byte	0
 8883 063d 00       		.byte	0
 8884 063e 00       		.byte	0
 8885 063f D2       		.byte	-46
 8886 0640 0F       		.byte	15
 8887 0641 00       		.byte	0
 8888 0642 00       		.byte	0
 8889 0643 0C       		.byte	12
 8890 0644 00       		.byte	0
 8891 0645 00       		.byte	0
 8892 0646 0000     		.space	2
 8895              	glProbeStilCtrl:
 8896 0648 01       		.byte	1
 8897 0649 01       		.byte	1
 8898 064a 00       		.byte	0
 8899 064b 00       		.byte	0
 8900 064c 48       		.byte	72
 8901 064d 3F       		.byte	63
 8902 064e 00       		.byte	0
 8903 064f 00       		.byte	0
 8904 0650 0C       		.byte	12
 8905 0651 00       		.byte	0
 8906 0652 00       		.byte	0
 8907 0653 00       		.space	1
 8910              	glProbeStilCtrl20:
 8911 0654 01       		.byte	1
 8912 0655 01       		.byte	1
 8913 0656 00       		.byte	0
 8914 0657 00       		.byte	0
 8915 0658 D2       		.byte	-46
 8916 0659 0F       		.byte	15
 8917 065a 00       		.byte	0
 8918 065b 00       		.byte	0
 8919 065c 0C       		.byte	12
 8920 065d 00       		.byte	0
 8921 065e 00       		.byte	0
 8924              	snapButFlag:
 8925 065f 01       		.byte	1
 8928              	CyFxGpifTransition:
 8929 0660 0000     		.short	0
 8930 0662 5555     		.short	21845
 8931 0664 8888     		.short	-30584
 8932 0666 AAAA     		.short	-21846
 8933 0668 3333     		.short	13107
 8934 066a 0000     		.space	2
 8937              	CyFxGpifWavedata:
 8938 066c 0181731E 		.word	510886145
 8939 0670 00000000 		.word	0
 8940 0674 00000080 		.word	-2147483648
 8941 0678 00000000 		.word	0
 8942 067c 00000000 		.word	0
 8943 0680 00000000 		.word	0
 8944 0684 0201702E 		.word	779092226
 8945 0688 00010000 		.word	256
 8946 068c A0000080 		.word	-2147483488
 8947 0690 00000000 		.word	0
 8948 0694 00000000 		.word	0
 8949 0698 00000000 		.word	0
 8950 069c 0380722E 		.word	779255811
 8951 06a0 02010020 		.word	536871170
 8952 06a4 60000080 		.word	-2147483552
 8953 06a8 00000000 		.word	0
 8954 06ac 00000000 		.word	0
 8955 06b0 00000000 		.word	0
 8956 06b4 0460722E 		.word	779247620
 8957 06b8 02010024 		.word	603980034
 8958 06bc 90000080 		.word	-2147483504
 8959 06c0 0594731E 		.word	510891013
 8960 06c4 06000000 		.word	6
 8961 06c8 00000080 		.word	-2147483648
 8962 06cc 0380722E 		.word	779255811
 8963 06d0 02010020 		.word	536871170
 8964 06d4 60000080 		.word	-2147483552
 8965 06d8 0693731E 		.word	510890758
 8966 06dc 06000000 		.word	6
 8967 06e0 00000080 		.word	-2147483648
 8968 06e4 0720703E 		.word	1047535623
 8969 06e8 08010000 		.word	264
 8970 06ec 00000080 		.word	-2147483648
 8971 06f0 0820703E 		.word	1047535624
 8972 06f4 08010000 		.word	264
 8973 06f8 00000080 		.word	-2147483648
 8974 06fc 0920703E 		.word	1047535625
 8975 0700 08010000 		.word	264
 8976 0704 00000080 		.word	-2147483648
 8977 0708 0A20703E 		.word	1047535626
 8978 070c 08010000 		.word	264
 8979 0710 00000080 		.word	-2147483648
 8980 0714 0380722E 		.word	779255811
 8981 0718 02010020 		.word	536871170
 8982 071c 60000080 		.word	-2147483552
 8983 0720 0B000000 		.word	11
 8984 0724 00000000 		.word	0
 8985 0728 00010080 		.word	-2147483392
 8986 072c 0460722E 		.word	779247620
 8987 0730 02010024 		.word	603980034
 8988 0734 90000080 		.word	-2147483504
 8989 0738 0D000000 		.word	13
 8990 073c 00000000 		.word	0
 8991 0740 00010080 		.word	-2147483392
 8992 0744 0460722E 		.word	779247620
 8993 0748 02010024 		.word	603980034
 8994 074c 90000080 		.word	-2147483504
 8995 0750 0C000000 		.word	12
 8996 0754 00000000 		.word	0
 8997 0758 00010080 		.word	-2147483392
 8998 075c 0380722E 		.word	779255811
 8999 0760 02010020 		.word	536871170
 9000 0764 60000080 		.word	-2147483552
 9001 0768 0E000000 		.word	14
 9002 076c 00000000 		.word	0
 9003 0770 00010080 		.word	-2147483392
 9004 0774 00000000 		.word	0
 9005 0778 00000000 		.word	0
 9006 077c 00000000 		.word	0
 9007 0780 00000000 		.word	0
 9008 0784 00000000 		.word	0
 9009 0788 00000000 		.word	0
 9012              	CyFxGpifWavedataPosition:
 9013 078c 00       		.byte	0
 9014 078d 01       		.byte	1
 9015 078e 02       		.byte	2
 9016 078f 03       		.byte	3
 9017 0790 04       		.byte	4
 9018 0791 05       		.byte	5
 9019 0792 06       		.byte	6
 9020 0793 07       		.byte	7
 9021 0794 08       		.byte	8
 9022 0795 09       		.byte	9
 9023 0796 0A       		.byte	10
 9024 0797 0B       		.byte	11
 9025 0798 0B       		.byte	11
 9026 0799 0B       		.byte	11
 9027 079a 0B       		.byte	11
 9028 079b 00       		.space	1
 9031              	CyFxGpifRegValue:
 9032 079c 08830080 		.word	-2147450104
 9033 07a0 67000000 		.word	103
 9034 07a4 00000000 		.word	0
 9035 07a8 46000000 		.word	70
 9036 07ac 00000000 		.word	0
 9037 07b0 00000000 		.word	0
 9038 07b4 02000000 		.word	2
 9039 07b8 82000000 		.word	130
 9040 07bc 82070000 		.word	1922
 9041 07c0 40040000 		.word	1088
 9042 07c4 FCFF0000 		.word	65532
 9043 07c8 28000000 		.word	40
 9044 07cc 00000000 		.word	0
 9045 07d0 00000000 		.word	0
 9046 07d4 00000000 		.word	0
 9047 07d8 00000000 		.word	0
 9048 07dc 01000000 		.word	1
 9049 07e0 00000000 		.word	0
 9050 07e4 00000000 		.word	0
 9051 07e8 00000000 		.word	0
 9052 07ec 00000000 		.word	0
 9053 07f0 00000000 		.word	0
 9054 07f4 00000000 		.word	0
 9055 07f8 00000000 		.word	0
 9056 07fc 00000000 		.word	0
 9057 0800 00000000 		.word	0
 9058 0804 00000000 		.word	0
 9059 0808 00000000 		.word	0
 9060 080c 00000000 		.word	0
 9061 0810 06000000 		.word	6
 9062 0814 00000000 		.word	0
 9063 0818 FFFF0000 		.word	65535
 9064 081c 09010000 		.word	265
 9065 0820 00000000 		.word	0
 9066 0824 F71F0000 		.word	8183
 9067 0828 00000000 		.word	0
 9068 082c FFFF0000 		.word	65535
 9069 0830 09010000 		.word	265
 9070 0834 00000000 		.word	0
 9071 0838 F71F0000 		.word	8183
 9072 083c 00000000 		.word	0
 9073 0840 00000000 		.word	0
 9074 0844 00000000 		.word	0
 9075 0848 00000000 		.word	0
 9076 084c 00000000 		.word	0
 9077 0850 00000000 		.word	0
 9078 0854 00000000 		.word	0
 9079 0858 00000000 		.word	0
 9080 085c 00000000 		.word	0
 9081 0860 00000000 		.word	0
 9082 0864 00000000 		.word	0
 9083 0868 00000000 		.word	0
 9084 086c 00000000 		.word	0
 9085 0870 00000000 		.word	0
 9086 0874 00000000 		.word	0
 9087 0878 00000000 		.word	0
 9088 087c 00000000 		.word	0
 9089 0880 00000000 		.word	0
 9090 0884 00000000 		.word	0
 9091 0888 00000000 		.word	0
 9092 088c 00000000 		.word	0
 9093 0890 00000000 		.word	0
 9094 0894 00000000 		.word	0
 9095 0898 00040180 		.word	-2147417088
 9096 089c 01040180 		.word	-2147417087
 9097 08a0 02040180 		.word	-2147417086
 9098 08a4 03040180 		.word	-2147417085
 9099 08a8 00000000 		.word	0
 9100 08ac 00000000 		.word	0
 9101 08b0 00000000 		.word	0
 9102 08b4 00000000 		.word	0
 9103 08b8 00000000 		.word	0
 9104 08bc 00000000 		.word	0
 9105 08c0 00000000 		.word	0
 9106 08c4 00000000 		.word	0
 9107 08c8 C1FFFFFF 		.word	-63
 9110              	CyFxGpifTransition_usb2_480:
 9111 08cc 0000     		.short	0
 9112 08ce AAAA     		.short	-21846
 9113 08d0 5555     		.short	21845
 9114 08d2 1111     		.short	4369
 9115 08d4 4444     		.short	17476
 9116 08d6 3333     		.short	13107
 9117 08d8 CCCC     		.short	-13108
 9118 08da 8888     		.short	-30584
 9119 08dc 2222     		.short	8738
 9120 08de 0000     		.space	2
 9123              	CyFxGpifWavedata_usb2_480:
 9124 08e0 0181732E 		.word	779321601
 9125 08e4 00000000 		.word	0
 9126 08e8 00000080 		.word	-2147483648
 9127 08ec 00000000 		.word	0
 9128 08f0 00000000 		.word	0
 9129 08f4 00000000 		.word	0
 9130 08f8 0201707E 		.word	2121269506
 9131 08fc 00000000 		.word	0
 9132 0900 A80000C0 		.word	-1073741656
 9133 0904 00000000 		.word	0
 9134 0908 00000000 		.word	0
 9135 090c 00000000 		.word	0
 9136 0910 0380732E 		.word	779321347
 9137 0914 00000000 		.word	0
 9138 0918 000000C0 		.word	-1073741824
 9139 091c 00000000 		.word	0
 9140 0920 00000000 		.word	0
 9141 0924 00000000 		.word	0
 9142 0928 1840728E 		.word	-1905115112
 9143 092c 0E000000 		.word	14
 9144 0930 040040C0 		.word	-1069547516
 9145 0934 00000000 		.word	0
 9146 0938 00000000 		.word	0
 9147 093c 00000000 		.word	0
 9148 0940 0701702E 		.word	779092231
 9149 0944 0C000000 		.word	12
 9150 0948 00000080 		.word	-2147483648
 9151 094c 0701702E 		.word	779092231
 9152 0950 0C000000 		.word	12
 9153 0954 00000080 		.word	-2147483648
 9154 0958 0F94731E 		.word	510891023
 9155 095c 04000024 		.word	603979780
 9156 0960 40004080 		.word	-2143289280
 9157 0964 1020701E 		.word	510664720
 9158 0968 0A000000 		.word	10
 9159 096c 00000080 		.word	-2147483648
 9160 0970 0494731E 		.word	510891012
 9161 0974 04000020 		.word	536870916
 9162 0978 40004080 		.word	-2143289280
 9163 097c 0701702E 		.word	779092231
 9164 0980 0C000000 		.word	12
 9165 0984 00000080 		.word	-2147483648
 9166 0988 08000000 		.word	8
 9167 098c 00000000 		.word	0
 9168 0990 00010080 		.word	-2147483392
 9169 0994 0980723E 		.word	1047691273
 9170 0998 08000000 		.word	8
 9171 099c 00000080 		.word	-2147483648
 9172 09a0 00000000 		.word	0
 9173 09a4 00000000 		.word	0
 9174 09a8 00000000 		.word	0
 9175 09ac 00000000 		.word	0
 9176 09b0 00000000 		.word	0
 9177 09b4 00000000 		.word	0
 9178 09b8 0A20701E 		.word	510664714
 9179 09bc 0A000000 		.word	10
 9180 09c0 200000C0 		.word	-1073741792
 9181 09c4 0B01702E 		.word	779092235
 9182 09c8 0C000000 		.word	12
 9183 09cc 200000C0 		.word	-1073741792
 9184 09d0 0C60727E 		.word	2121424908
 9185 09d4 00010000 		.word	256
 9186 09d8 10004080 		.word	-2143289328
 9187 09dc 08000000 		.word	8
 9188 09e0 00000000 		.word	0
 9189 09e4 00010080 		.word	-2147483392
 9190 09e8 0D000000 		.word	13
 9191 09ec 00000000 		.word	0
 9192 09f0 00010080 		.word	-2147483392
 9193 09f4 0E60727E 		.word	2121424910
 9194 09f8 00010000 		.word	256
 9195 09fc 10004080 		.word	-2143289328
 9196 0a00 0494731E 		.word	510891012
 9197 0a04 04000020 		.word	536870916
 9198 0a08 40004080 		.word	-2143289280
 9199 0a0c 00000000 		.word	0
 9200 0a10 00000000 		.word	0
 9201 0a14 00000000 		.word	0
 9202 0a18 0F94731E 		.word	510891023
 9203 0a1c 04000024 		.word	603979780
 9204 0a20 40004080 		.word	-2143289280
 9205 0a24 00000000 		.word	0
 9206 0a28 00000000 		.word	0
 9207 0a2c 00000000 		.word	0
 9208 0a30 1020701E 		.word	510664720
 9209 0a34 0A000000 		.word	10
 9210 0a38 00000080 		.word	-2147483648
 9211 0a3c 1020701E 		.word	510664720
 9212 0a40 0A000000 		.word	10
 9213 0a44 00000080 		.word	-2147483648
 9214 0a48 1180723E 		.word	1047691281
 9215 0a4c 08000000 		.word	8
 9216 0a50 00000080 		.word	-2147483648
 9217 0a54 12000000 		.word	18
 9218 0a58 00000000 		.word	0
 9219 0a5c 00010080 		.word	-2147483392
 9220 0a60 1301702E 		.word	779092243
 9221 0a64 0C000000 		.word	12
 9222 0a68 200000C0 		.word	-1073741792
 9223 0a6c 1401702E 		.word	779092244
 9224 0a70 0C000000 		.word	12
 9225 0a74 200000C0 		.word	-1073741792
 9226 0a78 12000000 		.word	18
 9227 0a7c 00000000 		.word	0
 9228 0a80 00010080 		.word	-2147483392
 9229 0a84 1560727E 		.word	2121424917
 9230 0a88 00010000 		.word	256
 9231 0a8c 10004080 		.word	-2143289328
 9232 0a90 16000000 		.word	22
 9233 0a94 00000000 		.word	0
 9234 0a98 00010080 		.word	-2147483392
 9235 0a9c 1760727E 		.word	2121424919
 9236 0aa0 00010000 		.word	256
 9237 0aa4 10004080 		.word	-2143289328
 9238 0aa8 0380732E 		.word	779321347
 9239 0aac 00000000 		.word	0
 9240 0ab0 000000C0 		.word	-1073741824
 9241 0ab4 1980731E 		.word	510885913
 9242 0ab8 00000000 		.word	0
 9243 0abc 200000C0 		.word	-1073741792
 9244 0ac0 1A60727E 		.word	2121424922
 9245 0ac4 00010000 		.word	256
 9246 0ac8 10004080 		.word	-2143289328
 9247 0acc 00000000 		.word	0
 9248 0ad0 00000000 		.word	0
 9249 0ad4 00000000 		.word	0
 9250 0ad8 0580731E 		.word	510885893
 9251 0adc 04010000 		.word	260
 9252 0ae0 000040C0 		.word	-1069547520
 9253 0ae4 0680731E 		.word	510885894
 9254 0ae8 04010000 		.word	260
 9255 0aec 000040C0 		.word	-1069547520
 9256 0af0 0680731E 		.word	510885894
 9257 0af4 04010000 		.word	260
 9258 0af8 000040C0 		.word	-1069547520
 9259 0afc 0580731E 		.word	510885893
 9260 0b00 04010000 		.word	260
 9261 0b04 000040C0 		.word	-1069547520
 9264              	CyFxGpifWavedataPosition_usb2_480:
 9265 0b08 00       		.byte	0
 9266 0b09 01       		.byte	1
 9267 0b0a 02       		.byte	2
 9268 0b0b 03       		.byte	3
 9269 0b0c 04       		.byte	4
 9270 0b0d 05       		.byte	5
 9271 0b0e 06       		.byte	6
 9272 0b0f 07       		.byte	7
 9273 0b10 08       		.byte	8
 9274 0b11 09       		.byte	9
 9275 0b12 0A       		.byte	10
 9276 0b13 0B       		.byte	11
 9277 0b14 0C       		.byte	12
 9278 0b15 08       		.byte	8
 9279 0b16 0D       		.byte	13
 9280 0b17 0E       		.byte	14
 9281 0b18 0F       		.byte	15
 9282 0b19 10       		.byte	16
 9283 0b1a 08       		.byte	8
 9284 0b1b 11       		.byte	17
 9285 0b1c 12       		.byte	18
 9286 0b1d 0D       		.byte	13
 9287 0b1e 08       		.byte	8
 9288 0b1f 0C       		.byte	12
 9289 0b20 13       		.byte	19
 9290 0b21 14       		.byte	20
 9291 0b22 0C       		.byte	12
 9292 0b23 08       		.byte	8
 9293 0b24 08       		.byte	8
 9294 0b25 08       		.byte	8
 9295 0b26 08       		.byte	8
 9296 0b27 08       		.byte	8
 9297 0b28 08       		.byte	8
 9298 0b29 08       		.byte	8
 9299 0b2a 08       		.byte	8
 9300 0b2b 08       		.byte	8
 9301 0b2c 08       		.byte	8
 9302 0b2d 08       		.byte	8
 9303 0b2e 08       		.byte	8
 9304 0b2f 08       		.byte	8
 9305 0b30 08       		.byte	8
 9306 0b31 08       		.byte	8
 9307 0b32 08       		.byte	8
 9308 0b33 08       		.byte	8
 9309 0b34 08       		.byte	8
 9310 0b35 08       		.byte	8
 9311 0b36 08       		.byte	8
 9312 0b37 08       		.byte	8
 9313 0b38 08       		.byte	8
 9314 0b39 08       		.byte	8
 9315 0b3a 08       		.byte	8
 9316 0b3b 08       		.byte	8
 9317 0b3c 08       		.byte	8
 9318 0b3d 08       		.byte	8
 9319 0b3e 08       		.byte	8
 9320 0b3f 08       		.byte	8
 9321 0b40 08       		.byte	8
 9322 0b41 08       		.byte	8
 9323 0b42 08       		.byte	8
 9324 0b43 08       		.byte	8
 9325 0b44 08       		.byte	8
 9326 0b45 08       		.byte	8
 9327 0b46 08       		.byte	8
 9328 0b47 08       		.byte	8
 9329 0b48 08       		.byte	8
 9330 0b49 08       		.byte	8
 9331 0b4a 08       		.byte	8
 9332 0b4b 08       		.byte	8
 9333 0b4c 08       		.byte	8
 9334 0b4d 08       		.byte	8
 9335 0b4e 08       		.byte	8
 9336 0b4f 08       		.byte	8
 9337 0b50 08       		.byte	8
 9338 0b51 08       		.byte	8
 9339 0b52 08       		.byte	8
 9340 0b53 08       		.byte	8
 9341 0b54 08       		.byte	8
 9342 0b55 08       		.byte	8
 9343 0b56 08       		.byte	8
 9344 0b57 08       		.byte	8
 9345 0b58 08       		.byte	8
 9346 0b59 08       		.byte	8
 9347 0b5a 08       		.byte	8
 9348 0b5b 08       		.byte	8
 9349 0b5c 08       		.byte	8
 9350 0b5d 08       		.byte	8
 9351 0b5e 08       		.byte	8
 9352 0b5f 08       		.byte	8
 9353 0b60 08       		.byte	8
 9354 0b61 08       		.byte	8
 9355 0b62 08       		.byte	8
 9356 0b63 08       		.byte	8
 9357 0b64 08       		.byte	8
 9358 0b65 08       		.byte	8
 9359 0b66 08       		.byte	8
 9360 0b67 08       		.byte	8
 9361 0b68 08       		.byte	8
 9362 0b69 08       		.byte	8
 9363 0b6a 08       		.byte	8
 9364 0b6b 08       		.byte	8
 9365 0b6c 08       		.byte	8
 9366 0b6d 08       		.byte	8
 9367 0b6e 08       		.byte	8
 9368 0b6f 08       		.byte	8
 9369 0b70 08       		.byte	8
 9370 0b71 08       		.byte	8
 9371 0b72 08       		.byte	8
 9372 0b73 08       		.byte	8
 9373 0b74 08       		.byte	8
 9374 0b75 08       		.byte	8
 9375 0b76 08       		.byte	8
 9376 0b77 08       		.byte	8
 9377 0b78 08       		.byte	8
 9378 0b79 08       		.byte	8
 9379 0b7a 08       		.byte	8
 9380 0b7b 08       		.byte	8
 9381 0b7c 08       		.byte	8
 9382 0b7d 08       		.byte	8
 9383 0b7e 08       		.byte	8
 9384 0b7f 08       		.byte	8
 9385 0b80 08       		.byte	8
 9386 0b81 08       		.byte	8
 9387 0b82 08       		.byte	8
 9388 0b83 08       		.byte	8
 9389 0b84 08       		.byte	8
 9390 0b85 08       		.byte	8
 9391 0b86 08       		.byte	8
 9392 0b87 08       		.byte	8
 9393 0b88 00       		.byte	0
 9394 0b89 01       		.byte	1
 9395 0b8a 02       		.byte	2
 9396 0b8b 03       		.byte	3
 9397 0b8c 15       		.byte	21
 9398 0b8d 05       		.byte	5
 9399 0b8e 06       		.byte	6
 9400 0b8f 07       		.byte	7
 9401 0b90 08       		.byte	8
 9402 0b91 09       		.byte	9
 9403 0b92 0A       		.byte	10
 9404 0b93 0B       		.byte	11
 9405 0b94 0C       		.byte	12
 9406 0b95 08       		.byte	8
 9407 0b96 0D       		.byte	13
 9408 0b97 16       		.byte	22
 9409 0b98 0F       		.byte	15
 9410 0b99 10       		.byte	16
 9411 0b9a 08       		.byte	8
 9412 0b9b 11       		.byte	17
 9413 0b9c 12       		.byte	18
 9414 0b9d 0D       		.byte	13
 9415 0b9e 08       		.byte	8
 9416 0b9f 0C       		.byte	12
 9417 0ba0 13       		.byte	19
 9418 0ba1 14       		.byte	20
 9419 0ba2 0C       		.byte	12
 9420 0ba3 00       		.space	1
 9423              	CyFxGpifRegValue_usb2_480:
 9424 0ba4 08830080 		.word	-2147450104
 9425 0ba8 67000000 		.word	103
 9426 0bac 01000000 		.word	1
 9427 0bb0 46000000 		.word	70
 9428 0bb4 00000000 		.word	0
 9429 0bb8 00000000 		.word	0
 9430 0bbc 02000000 		.word	2
 9431 0bc0 82000000 		.word	130
 9432 0bc4 82070000 		.word	1922
 9433 0bc8 40040000 		.word	1088
 9434 0bcc FCFF0000 		.word	65532
 9435 0bd0 28000000 		.word	40
 9436 0bd4 00000000 		.word	0
 9437 0bd8 00000000 		.word	0
 9438 0bdc 00000000 		.word	0
 9439 0be0 00000000 		.word	0
 9440 0be4 01000000 		.word	1
 9441 0be8 00000000 		.word	0
 9442 0bec 00000000 		.word	0
 9443 0bf0 00000000 		.word	0
 9444 0bf4 00000000 		.word	0
 9445 0bf8 00000000 		.word	0
 9446 0bfc 00000000 		.word	0
 9447 0c00 00000000 		.word	0
 9448 0c04 00000000 		.word	0
 9449 0c08 00000000 		.word	0
 9450 0c0c 00000000 		.word	0
 9451 0c10 00000000 		.word	0
 9452 0c14 00000000 		.word	0
 9453 0c18 03000000 		.word	3
 9454 0c1c 00000000 		.word	0
 9455 0c20 B8010000 		.word	440
 9456 0c24 09010000 		.word	265
 9457 0c28 00000000 		.word	0
 9458 0c2c BF030000 		.word	959
 9459 0c30 00000000 		.word	0
 9460 0c34 FFFF0000 		.word	65535
 9461 0c38 0B010000 		.word	267
 9462 0c3c 00000000 		.word	0
 9463 0c40 B7050000 		.word	1463
 9464 0c44 00000000 		.word	0
 9465 0c48 00000000 		.word	0
 9466 0c4c 00000000 		.word	0
 9467 0c50 00000000 		.word	0
 9468 0c54 00000000 		.word	0
 9469 0c58 00000000 		.word	0
 9470 0c5c 00000000 		.word	0
 9471 0c60 00000000 		.word	0
 9472 0c64 00000000 		.word	0
 9473 0c68 00000000 		.word	0
 9474 0c6c 00000000 		.word	0
 9475 0c70 00000000 		.word	0
 9476 0c74 00000000 		.word	0
 9477 0c78 00000000 		.word	0
 9478 0c7c 00000000 		.word	0
 9479 0c80 00000000 		.word	0
 9480 0c84 00000000 		.word	0
 9481 0c88 00000000 		.word	0
 9482 0c8c 00000000 		.word	0
 9483 0c90 00000000 		.word	0
 9484 0c94 00000000 		.word	0
 9485 0c98 00000000 		.word	0
 9486 0c9c 00000000 		.word	0
 9487 0ca0 00040180 		.word	-2147417088
 9488 0ca4 01040180 		.word	-2147417087
 9489 0ca8 02040180 		.word	-2147417086
 9490 0cac 03040180 		.word	-2147417085
 9491 0cb0 00000000 		.word	0
 9492 0cb4 00000000 		.word	0
 9493 0cb8 00000000 		.word	0
 9494 0cbc 00000000 		.word	0
 9495 0cc0 00000000 		.word	0
 9496 0cc4 00000000 		.word	0
 9497 0cc8 00000000 		.word	0
 9498 0ccc 00000000 		.word	0
 9499 0cd0 C1FFFFFF 		.word	-63
 9502              	CyFxGpifTransition_usb2_640:
 9503 0cd4 0000     		.short	0
 9504 0cd6 AAAA     		.short	-21846
 9505 0cd8 5555     		.short	21845
 9506 0cda 1111     		.short	4369
 9507 0cdc 4444     		.short	17476
 9508 0cde 3333     		.short	13107
 9509 0ce0 CCCC     		.short	-13108
 9510 0ce2 8888     		.short	-30584
 9511 0ce4 2222     		.short	8738
 9512 0ce6 0000     		.space	2
 9515              	CyFxGpifWavedata_usb2_640:
 9516 0ce8 0181732E 		.word	779321601
 9517 0cec 00000000 		.word	0
 9518 0cf0 00000080 		.word	-2147483648
 9519 0cf4 00000000 		.word	0
 9520 0cf8 00000000 		.word	0
 9521 0cfc 00000000 		.word	0
 9522 0d00 0201707E 		.word	2121269506
 9523 0d04 00000000 		.word	0
 9524 0d08 A80000C0 		.word	-1073741656
 9525 0d0c 00000000 		.word	0
 9526 0d10 00000000 		.word	0
 9527 0d14 00000000 		.word	0
 9528 0d18 0380732E 		.word	779321347
 9529 0d1c 00000000 		.word	0
 9530 0d20 000000C0 		.word	-1073741824
 9531 0d24 00000000 		.word	0
 9532 0d28 00000000 		.word	0
 9533 0d2c 00000000 		.word	0
 9534 0d30 1840728E 		.word	-1905115112
 9535 0d34 0E000000 		.word	14
 9536 0d38 040040C0 		.word	-1069547516
 9537 0d3c 00000000 		.word	0
 9538 0d40 00000000 		.word	0
 9539 0d44 00000000 		.word	0
 9540 0d48 0701702E 		.word	779092231
 9541 0d4c 0C000000 		.word	12
 9542 0d50 00000080 		.word	-2147483648
 9543 0d54 0701702E 		.word	779092231
 9544 0d58 0C000000 		.word	12
 9545 0d5c 00000080 		.word	-2147483648
 9546 0d60 0F94731E 		.word	510891023
 9547 0d64 04000024 		.word	603979780
 9548 0d68 40004080 		.word	-2143289280
 9549 0d6c 1020701E 		.word	510664720
 9550 0d70 0A000000 		.word	10
 9551 0d74 00000080 		.word	-2147483648
 9552 0d78 0494731E 		.word	510891012
 9553 0d7c 04000020 		.word	536870916
 9554 0d80 40004080 		.word	-2143289280
 9555 0d84 0701702E 		.word	779092231
 9556 0d88 0C000000 		.word	12
 9557 0d8c 00000080 		.word	-2147483648
 9558 0d90 08000000 		.word	8
 9559 0d94 00000000 		.word	0
 9560 0d98 00010080 		.word	-2147483392
 9561 0d9c 0980723E 		.word	1047691273
 9562 0da0 08000000 		.word	8
 9563 0da4 00000080 		.word	-2147483648
 9564 0da8 00000000 		.word	0
 9565 0dac 00000000 		.word	0
 9566 0db0 00000000 		.word	0
 9567 0db4 00000000 		.word	0
 9568 0db8 00000000 		.word	0
 9569 0dbc 00000000 		.word	0
 9570 0dc0 0A20701E 		.word	510664714
 9571 0dc4 0A000000 		.word	10
 9572 0dc8 200000C0 		.word	-1073741792
 9573 0dcc 0B01702E 		.word	779092235
 9574 0dd0 0C000000 		.word	12
 9575 0dd4 200000C0 		.word	-1073741792
 9576 0dd8 0C60727E 		.word	2121424908
 9577 0ddc 00010000 		.word	256
 9578 0de0 10004080 		.word	-2143289328
 9579 0de4 08000000 		.word	8
 9580 0de8 00000000 		.word	0
 9581 0dec 00010080 		.word	-2147483392
 9582 0df0 0D000000 		.word	13
 9583 0df4 00000000 		.word	0
 9584 0df8 00010080 		.word	-2147483392
 9585 0dfc 0E60727E 		.word	2121424910
 9586 0e00 00010000 		.word	256
 9587 0e04 10004080 		.word	-2143289328
 9588 0e08 0494731E 		.word	510891012
 9589 0e0c 04000020 		.word	536870916
 9590 0e10 40004080 		.word	-2143289280
 9591 0e14 00000000 		.word	0
 9592 0e18 00000000 		.word	0
 9593 0e1c 00000000 		.word	0
 9594 0e20 0F94731E 		.word	510891023
 9595 0e24 04000024 		.word	603979780
 9596 0e28 40004080 		.word	-2143289280
 9597 0e2c 00000000 		.word	0
 9598 0e30 00000000 		.word	0
 9599 0e34 00000000 		.word	0
 9600 0e38 1020701E 		.word	510664720
 9601 0e3c 0A000000 		.word	10
 9602 0e40 00000080 		.word	-2147483648
 9603 0e44 1020701E 		.word	510664720
 9604 0e48 0A000000 		.word	10
 9605 0e4c 00000080 		.word	-2147483648
 9606 0e50 1180723E 		.word	1047691281
 9607 0e54 08000000 		.word	8
 9608 0e58 00000080 		.word	-2147483648
 9609 0e5c 12000000 		.word	18
 9610 0e60 00000000 		.word	0
 9611 0e64 00010080 		.word	-2147483392
 9612 0e68 1301702E 		.word	779092243
 9613 0e6c 0C000000 		.word	12
 9614 0e70 200000C0 		.word	-1073741792
 9615 0e74 1401702E 		.word	779092244
 9616 0e78 0C000000 		.word	12
 9617 0e7c 200000C0 		.word	-1073741792
 9618 0e80 12000000 		.word	18
 9619 0e84 00000000 		.word	0
 9620 0e88 00010080 		.word	-2147483392
 9621 0e8c 1560727E 		.word	2121424917
 9622 0e90 00010000 		.word	256
 9623 0e94 10004080 		.word	-2143289328
 9624 0e98 16000000 		.word	22
 9625 0e9c 00000000 		.word	0
 9626 0ea0 00010080 		.word	-2147483392
 9627 0ea4 1760727E 		.word	2121424919
 9628 0ea8 00010000 		.word	256
 9629 0eac 10004080 		.word	-2143289328
 9630 0eb0 0380732E 		.word	779321347
 9631 0eb4 00000000 		.word	0
 9632 0eb8 000000C0 		.word	-1073741824
 9633 0ebc 1980731E 		.word	510885913
 9634 0ec0 00000000 		.word	0
 9635 0ec4 200000C0 		.word	-1073741792
 9636 0ec8 1A60727E 		.word	2121424922
 9637 0ecc 00010000 		.word	256
 9638 0ed0 10004080 		.word	-2143289328
 9639 0ed4 00000000 		.word	0
 9640 0ed8 00000000 		.word	0
 9641 0edc 00000000 		.word	0
 9642 0ee0 0580731E 		.word	510885893
 9643 0ee4 04010000 		.word	260
 9644 0ee8 000040C0 		.word	-1069547520
 9645 0eec 0680731E 		.word	510885894
 9646 0ef0 04010000 		.word	260
 9647 0ef4 000040C0 		.word	-1069547520
 9648 0ef8 0680731E 		.word	510885894
 9649 0efc 04010000 		.word	260
 9650 0f00 000040C0 		.word	-1069547520
 9651 0f04 0580731E 		.word	510885893
 9652 0f08 04010000 		.word	260
 9653 0f0c 000040C0 		.word	-1069547520
 9656              	CyFxGpifWavedataPosition_usb2_640:
 9657 0f10 00       		.byte	0
 9658 0f11 01       		.byte	1
 9659 0f12 02       		.byte	2
 9660 0f13 03       		.byte	3
 9661 0f14 04       		.byte	4
 9662 0f15 05       		.byte	5
 9663 0f16 06       		.byte	6
 9664 0f17 07       		.byte	7
 9665 0f18 08       		.byte	8
 9666 0f19 09       		.byte	9
 9667 0f1a 0A       		.byte	10
 9668 0f1b 0B       		.byte	11
 9669 0f1c 0C       		.byte	12
 9670 0f1d 08       		.byte	8
 9671 0f1e 0D       		.byte	13
 9672 0f1f 0E       		.byte	14
 9673 0f20 0F       		.byte	15
 9674 0f21 10       		.byte	16
 9675 0f22 08       		.byte	8
 9676 0f23 11       		.byte	17
 9677 0f24 12       		.byte	18
 9678 0f25 0D       		.byte	13
 9679 0f26 08       		.byte	8
 9680 0f27 0C       		.byte	12
 9681 0f28 13       		.byte	19
 9682 0f29 14       		.byte	20
 9683 0f2a 0C       		.byte	12
 9684 0f2b 08       		.byte	8
 9685 0f2c 08       		.byte	8
 9686 0f2d 08       		.byte	8
 9687 0f2e 08       		.byte	8
 9688 0f2f 08       		.byte	8
 9689 0f30 08       		.byte	8
 9690 0f31 08       		.byte	8
 9691 0f32 08       		.byte	8
 9692 0f33 08       		.byte	8
 9693 0f34 08       		.byte	8
 9694 0f35 08       		.byte	8
 9695 0f36 08       		.byte	8
 9696 0f37 08       		.byte	8
 9697 0f38 08       		.byte	8
 9698 0f39 08       		.byte	8
 9699 0f3a 08       		.byte	8
 9700 0f3b 08       		.byte	8
 9701 0f3c 08       		.byte	8
 9702 0f3d 08       		.byte	8
 9703 0f3e 08       		.byte	8
 9704 0f3f 08       		.byte	8
 9705 0f40 08       		.byte	8
 9706 0f41 08       		.byte	8
 9707 0f42 08       		.byte	8
 9708 0f43 08       		.byte	8
 9709 0f44 08       		.byte	8
 9710 0f45 08       		.byte	8
 9711 0f46 08       		.byte	8
 9712 0f47 08       		.byte	8
 9713 0f48 08       		.byte	8
 9714 0f49 08       		.byte	8
 9715 0f4a 08       		.byte	8
 9716 0f4b 08       		.byte	8
 9717 0f4c 08       		.byte	8
 9718 0f4d 08       		.byte	8
 9719 0f4e 08       		.byte	8
 9720 0f4f 08       		.byte	8
 9721 0f50 08       		.byte	8
 9722 0f51 08       		.byte	8
 9723 0f52 08       		.byte	8
 9724 0f53 08       		.byte	8
 9725 0f54 08       		.byte	8
 9726 0f55 08       		.byte	8
 9727 0f56 08       		.byte	8
 9728 0f57 08       		.byte	8
 9729 0f58 08       		.byte	8
 9730 0f59 08       		.byte	8
 9731 0f5a 08       		.byte	8
 9732 0f5b 08       		.byte	8
 9733 0f5c 08       		.byte	8
 9734 0f5d 08       		.byte	8
 9735 0f5e 08       		.byte	8
 9736 0f5f 08       		.byte	8
 9737 0f60 08       		.byte	8
 9738 0f61 08       		.byte	8
 9739 0f62 08       		.byte	8
 9740 0f63 08       		.byte	8
 9741 0f64 08       		.byte	8
 9742 0f65 08       		.byte	8
 9743 0f66 08       		.byte	8
 9744 0f67 08       		.byte	8
 9745 0f68 08       		.byte	8
 9746 0f69 08       		.byte	8
 9747 0f6a 08       		.byte	8
 9748 0f6b 08       		.byte	8
 9749 0f6c 08       		.byte	8
 9750 0f6d 08       		.byte	8
 9751 0f6e 08       		.byte	8
 9752 0f6f 08       		.byte	8
 9753 0f70 08       		.byte	8
 9754 0f71 08       		.byte	8
 9755 0f72 08       		.byte	8
 9756 0f73 08       		.byte	8
 9757 0f74 08       		.byte	8
 9758 0f75 08       		.byte	8
 9759 0f76 08       		.byte	8
 9760 0f77 08       		.byte	8
 9761 0f78 08       		.byte	8
 9762 0f79 08       		.byte	8
 9763 0f7a 08       		.byte	8
 9764 0f7b 08       		.byte	8
 9765 0f7c 08       		.byte	8
 9766 0f7d 08       		.byte	8
 9767 0f7e 08       		.byte	8
 9768 0f7f 08       		.byte	8
 9769 0f80 08       		.byte	8
 9770 0f81 08       		.byte	8
 9771 0f82 08       		.byte	8
 9772 0f83 08       		.byte	8
 9773 0f84 08       		.byte	8
 9774 0f85 08       		.byte	8
 9775 0f86 08       		.byte	8
 9776 0f87 08       		.byte	8
 9777 0f88 08       		.byte	8
 9778 0f89 08       		.byte	8
 9779 0f8a 08       		.byte	8
 9780 0f8b 08       		.byte	8
 9781 0f8c 08       		.byte	8
 9782 0f8d 08       		.byte	8
 9783 0f8e 08       		.byte	8
 9784 0f8f 08       		.byte	8
 9785 0f90 00       		.byte	0
 9786 0f91 01       		.byte	1
 9787 0f92 02       		.byte	2
 9788 0f93 03       		.byte	3
 9789 0f94 15       		.byte	21
 9790 0f95 05       		.byte	5
 9791 0f96 06       		.byte	6
 9792 0f97 07       		.byte	7
 9793 0f98 08       		.byte	8
 9794 0f99 09       		.byte	9
 9795 0f9a 0A       		.byte	10
 9796 0f9b 0B       		.byte	11
 9797 0f9c 0C       		.byte	12
 9798 0f9d 08       		.byte	8
 9799 0f9e 0D       		.byte	13
 9800 0f9f 16       		.byte	22
 9801 0fa0 0F       		.byte	15
 9802 0fa1 10       		.byte	16
 9803 0fa2 08       		.byte	8
 9804 0fa3 11       		.byte	17
 9805 0fa4 12       		.byte	18
 9806 0fa5 0D       		.byte	13
 9807 0fa6 08       		.byte	8
 9808 0fa7 0C       		.byte	12
 9809 0fa8 13       		.byte	19
 9810 0fa9 14       		.byte	20
 9811 0faa 0C       		.byte	12
 9812 0fab 00       		.space	1
 9815              	CyFxGpifRegValue_usb2_640:
 9816 0fac 08830080 		.word	-2147450104
 9817 0fb0 67000000 		.word	103
 9818 0fb4 01000000 		.word	1
 9819 0fb8 46000000 		.word	70
 9820 0fbc 00000000 		.word	0
 9821 0fc0 00000000 		.word	0
 9822 0fc4 02000000 		.word	2
 9823 0fc8 82000000 		.word	130
 9824 0fcc 82070000 		.word	1922
 9825 0fd0 40040000 		.word	1088
 9826 0fd4 FCFF0000 		.word	65532
 9827 0fd8 28000000 		.word	40
 9828 0fdc 00000000 		.word	0
 9829 0fe0 00000000 		.word	0
 9830 0fe4 00000000 		.word	0
 9831 0fe8 00000000 		.word	0
 9832 0fec 01000000 		.word	1
 9833 0ff0 00000000 		.word	0
 9834 0ff4 00000000 		.word	0
 9835 0ff8 00000000 		.word	0
 9836 0ffc 00000000 		.word	0
 9837 1000 00000000 		.word	0
 9838 1004 00000000 		.word	0
 9839 1008 00000000 		.word	0
 9840 100c 00000000 		.word	0
 9841 1010 00000000 		.word	0
 9842 1014 00000000 		.word	0
 9843 1018 00000000 		.word	0
 9844 101c 00000000 		.word	0
 9845 1020 03000000 		.word	3
 9846 1024 00000000 		.word	0
 9847 1028 78000000 		.word	120
 9848 102c 09010000 		.word	265
 9849 1030 00000000 		.word	0
 9850 1034 7F020000 		.word	639
 9851 1038 00000000 		.word	0
 9852 103c FFFF0000 		.word	65535
 9853 1040 0B010000 		.word	267
 9854 1044 00000000 		.word	0
 9855 1048 B7050000 		.word	1463
 9856 104c 00000000 		.word	0
 9857 1050 00000000 		.word	0
 9858 1054 00000000 		.word	0
 9859 1058 00000000 		.word	0
 9860 105c 00000000 		.word	0
 9861 1060 00000000 		.word	0
 9862 1064 00000000 		.word	0
 9863 1068 00000000 		.word	0
 9864 106c 00000000 		.word	0
 9865 1070 00000000 		.word	0
 9866 1074 00000000 		.word	0
 9867 1078 00000000 		.word	0
 9868 107c 00000000 		.word	0
 9869 1080 00000000 		.word	0
 9870 1084 00000000 		.word	0
 9871 1088 00000000 		.word	0
 9872 108c 00000000 		.word	0
 9873 1090 00000000 		.word	0
 9874 1094 00000000 		.word	0
 9875 1098 00000000 		.word	0
 9876 109c 00000000 		.word	0
 9877 10a0 00000000 		.word	0
 9878 10a4 00000000 		.word	0
 9879 10a8 00040180 		.word	-2147417088
 9880 10ac 01040180 		.word	-2147417087
 9881 10b0 02040180 		.word	-2147417086
 9882 10b4 03040180 		.word	-2147417085
 9883 10b8 00000000 		.word	0
 9884 10bc 00000000 		.word	0
 9885 10c0 00000000 		.word	0
 9886 10c4 00000000 		.word	0
 9887 10c8 00000000 		.word	0
 9888 10cc 00000000 		.word	0
 9889 10d0 00000000 		.word	0
 9890 10d4 00000000 		.word	0
 9891 10d8 C1FFFFFF 		.word	-63
 9892              		.section	.rodata.str1.4,"aMS",%progbits,1
 9893              		.align	2
 9894              	.LC0:
 9895 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9895      7065722D 
 9895      74696D65 
 9895      72202564 
 9895      0D0A00
 9896 0013 00       		.space	1
 9897              	.LC1:
 9898 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9898      636F6D6D 
 9898      616E6420 
 9898      71756575 
 9898      65206973 
 9899 0037 00       		.space	1
 9900              	.LC2:
 9901 0038 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9901      6F6D6D69 
 9901      74656F66 
 9901      20737461 
 9901      7465203D 
 9902              	.LC3:
 9903 0050 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9903      6E656C20 
 9903      53657420 
 9903      57726170 
 9903      55702066 
 9904 007d 000000   		.space	3
 9905              	.LC4:
 9906 0080 4572726F 		.ascii	"Error handler... 0x%x\015\012\000"
 9906      72206861 
 9906      6E646C65 
 9906      722E2E2E 
 9906      20307825 
 9907              	.LC5:
 9908 0098 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 9908      69742045 
 9908      4F462066 
 9908      61696C65 
 9908      64210A00 
 9909              	.LC6:
 9910 00ac 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 9910      7220696E 
 9910      206D756C 
 9910      74696368 
 9910      616E6E65 
 9911 00df 3D202578 		.ascii	"= %x, dmaDone %x, full %d\015\012\000"
 9911      2C20646D 
 9911      61446F6E 
 9911      65202578 
 9911      2C206675 
 9912 00fb 00       		.space	1
 9913              	.LC7:
 9914 00fc 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9914      5420656E 
 9914      636F756E 
 9914      74657265 
 9914      642E2E2E 
 9915              	.LC8:
 9916 011c 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9916      454E4420 
 9916      656E636F 
 9916      756E7465 
 9916      7265642E 
 9917 013e 0000     		.space	2
 9918              	.LC9:
 9919 0140 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9919      64697363 
 9919      6F6E6E65 
 9919      63746564 
 9919      2E2E2E30 
 9920 015f 00       		.space	1
 9921              	.LC10:
 9922 0160 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9922      43595F46 
 9922      585F5556 
 9922      435F5649 
 9922      44454F5F 
 9923 0193 0A00     		.ascii	"\012\000"
 9924 0195 000000   		.space	3
 9925              	.LC11:
 9926 0198 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9926      43595F46 
 9926      585F5556 
 9926      435F5649 
 9926      44454F5F 
 9927 01cb 00       		.ascii	"\000"
 9928              	.LC12:
 9929 01cc 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9929      726E6174 
 9929      65207365 
 9929      7474696E 
 9929      6720302E 
 9930              	.LC13:
 9931 01e4 416C7465 		.ascii	"Alternate setting %d..\015\012\000"
 9931      726E6174 
 9931      65207365 
 9931      7474696E 
 9931      67202564 
 9932 01fd 000000   		.space	3
 9933              	.LC14:
 9934 0200 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9934      72206665 
 9934      61747572 
 9934      65207265 
 9934      71756573 
 9935 0223 00       		.space	1
 9936              	.LC15:
 9937 0224 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9937      49324320 
 9937      636F6D6D 
 9937      616E6420 
 9937      69732030 
 9938 0257 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9938      78257820 
 9938      30782578 
 9938      20307825 
 9938      78203078 
 9939              	.LC16:
 9940 0270 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 9940      206C6967 
 9940      68742063 
 9940      6F6D7065 
 9940      6E736174 
 9941 02a3 25640D0A 		.ascii	"%d\015\012\000"
 9941      00
 9942              	.LC17:
 9943 02a8 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9943      49324320 
 9943      63757272 
 9943      656E7420 
 9943      64617461 
 9944 02db 64202564 		.ascii	"d %d\015\012\000"
 9944      0D0A00
 9945 02e2 0000     		.space	2
 9946              	.LC18:
 9947 02e4 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9947      26414743 
 9947      2073656E 
 9947      7420746F 
 9947      20686F73 
 9948 030a 0000     		.space	2
 9949              	.LC19:
 9950 030c 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9950      26414743 
 9950      20676F74 
 9950      74656E20 
 9950      66726F6D 
 9951 0336 0000     		.space	2
 9952              	.LC20:
 9953 0338 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9953      67657420 
 9953      64617461 
 9953      2066726F 
 9953      6D20686F 
 9954 0365 000000   		.space	3
 9955              	.LC21:
 9956 0368 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9956      52657175 
 9956      65737420 
 9956      30782578 
 9956      20706172 
 9957 039b 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9957      6E642074 
 9957      6F20686F 
 9957      73742030 
 9957      78257820 
 9958 03b6 0000     		.space	2
 9959              	.LC22:
 9960 03b8 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9960      204F7020 
 9960      72656365 
 9960      69766573 
 9960      20284354 
 9961 03df 00       		.space	1
 9962              	.LC23:
 9963 03e0 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9963      756C7420 
 9963      73656C65 
 9963      63746F72 
 9963      20284354 
 9964 0402 0000     		.space	2
 9965              	.LC24:
 9966 0404 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9966      756C7420 
 9966      72657175 
 9966      65737420 
 9966      28435429 
 9967 0425 000000   		.space	3
 9968              	.LC25:
 9969 0428 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9969      52657175 
 9969      65737420 
 9969      30782578 
 9969      20706172 
 9970 045b 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9970      20307825 
 9970      78202F20 
 9970      73656E64 
 9970      20746F20 
 9971 0488 00       		.ascii	"\000"
 9972 0489 000000   		.space	3
 9973              	.LC26:
 9974 048c 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9974      73706565 
 9974      64203D20 
 9974      25642065 
 9974      76656E66 
 9975 04bc 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9975      71756573 
 9975      74203D20 
 9975      30782578 
 9975      20775661 
 9976 04ec 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9976      203D2030 
 9976      78257820 
 9976      6973666C 
 9976      61672030 
 9977 0506 0000     		.space	2
 9978              	.LC27:
 9979 0508 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9979      64656661 
 9979      756C7420 
 9979      73657475 
 9979      70207265 
 9980              	.LC28:
 9981 0534 54686520 		.ascii	"The host command is not correct for 1080p camera 0x"
 9981      686F7374 
 9981      20636F6D 
 9981      6D616E64 
 9981      20697320 
 9982 0567 25782030 		.ascii	"%x 0x%x\015\012\000"
 9982      7825780D 
 9982      0A00
 9983 0571 000000   		.space	3
 9984              	.LC29:
 9985 0574 676C5072 		.ascii	"glProbeCtrl 20 ~25 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x"
 9985      6F626543 
 9985      74726C20 
 9985      3230207E 
 9985      32352030 
 9986 05a7 25780A0D 		.ascii	"%x\012\015\000"
 9986      00
 9987              	.LC30:
 9988 05ac 676C436F 		.ascii	"glCommitCtrl 20 ~25 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0"
 9988      6D6D6974 
 9988      4374726C 
 9988      20323020 
 9988      7E323520 
 9989 05df 7825780A 		.ascii	"x%x\012\015\000"
 9989      0D00
 9990 05e5 000000   		.space	3
 9991              	.LC31:
 9992 05e8 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9992      43595F46 
 9992      585F5556 
 9992      435F5354 
 9992      5245414D 
 9993 060e 0000     		.space	2
 9994              	.LC32:
 9995 0610 47657420 		.ascii	"Get UVC still trigger control %d %d\015\012\000"
 9995      55564320 
 9995      7374696C 
 9995      6C207472 
 9995      69676765 
 9996 0636 0000     		.space	2
 9997              	.LC33:
 9998 0638 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9998      7374696C 
 9998      6C207472 
 9998      69676765 
 9998      7220636F 
 9999 065f 00       		.space	1
 10000              	.LC34:
 10001 0660 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 10001      65642074 
 10001      6F207365 
 10001      6E642069 
 10001      6E746572 
 10002 0691 0A00     		.ascii	"\012\000"
 10003 0693 00       		.space	1
 10004              	.LC35:
 10005 0694 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 10005      73657420 
 10005      64656620 
 10005      64617461 
 10005      20307825 
 10006 06b3 00       		.space	1
 10007              	.LC36:
 10008 06b4 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 10008      73657420 
 10008      64656620 
 10008      64617461 
 10008      20307825 
 10009 06e7 2E0D0A00 		.ascii	".\015\012\000"
 10010 06eb 00       		.space	1
 10011              	.LC37:
 10012 06ec 55415254 		.ascii	"UART initialization failed!\012\000"
 10012      20696E69 
 10012      7469616C 
 10012      697A6174 
 10012      696F6E20 
 10013 0709 000000   		.space	3
 10014              	.LC38:
 10015 070c 74657374 		.ascii	"test UART config\000"
 10015      20554152 
 10015      5420636F 
 10015      6E666967 
 10015      00
 10016 071d 000000   		.space	3
 10017              	.LC39:
 10018 0720 74657374 		.ascii	"test UART transfer\000"
 10018      20554152 
 10018      54207472 
 10018      616E7366 
 10018      657200
 10019 0733 00       		.space	1
 10020              	.LC40:
 10021 0734 74657374 		.ascii	"test debug\000"
 10021      20646562 
 10021      756700
 10022 073f 00       		.space	1
 10023              	.LC41:
 10024 0740 49324320 		.ascii	"I2C initialization failed!\012\000"
 10024      696E6974 
 10024      69616C69 
 10024      7A617469 
 10024      6F6E2066 
 10025              	.LC42:
 10026 075c 49324320 		.ascii	"I2C configuration failed!\012\000"
 10026      636F6E66 
 10026      69677572 
 10026      6174696F 
 10026      6E206661 
 10027 0777 00       		.space	1
 10028              	.LC43:
 10029 0778 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 10029      43726561 
 10029      74652045 
 10029      76656E74 
 10029      20666169 
 10030 07a2 0000     		.space	2
 10031              	.LC44:
 10032 07a4 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 10032      20496E69 
 10032      74206661 
 10032      696C6564 
 10032      2C204572 
 10033 07c7 00       		.space	1
 10034              	.LC45:
 10035 07c8 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 10035      204F7665 
 10035      72726964 
 10035      65206661 
 10035      696C6564 
 10036 07ef 00       		.space	1
 10037              	.LC46:
 10038 07f0 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 10038      28323029 
 10038      204F7665 
 10038      72726964 
 10038      65206661 
 10039 081b 00       		.space	1
 10040              	.LC47:
 10041 081c 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 10041      28323429 
 10041      204F7665 
 10041      72726964 
 10041      65206661 
 10042 0847 00       		.space	1
 10043              	.LC48:
 10044 0848 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 10044      20536574 
 10044      20287265 
 10044      73657420 
 10044      32322920 
 10045 087a 00       		.ascii	"\000"
 10046 087b 00       		.space	1
 10047              	.LC49:
 10048 087c 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 10048      20536574 
 10048      2028706F 
 10048      77657220 
 10048      32302920 
 10049 08ae 00       		.ascii	"\000"
 10050 08af 00       		.space	1
 10051              	.LC50:
 10052 08b0 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 10052      20536574 
 10052      2028736E 
 10052      61702073 
 10052      686F7420 
 10053 08e3 25640A00 		.ascii	"%d\012\000"
 10054 08e7 00       		.space	1
 10055              	.LC51:
 10056 08e8 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 10056      46756E63 
 10056      74696F6E 
 10056      20466169 
 10056      6C656420 
 10057 0917 00       		.space	1
 10058              	.LC52:
 10059 0918 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 10059      46756E63 
 10059      74696F6E 
 10059      20466169 
 10059      6C656420 
 10060 0947 00       		.space	1
 10061              	.LC53:
 10062 0948 55534220 		.ascii	"USB Set Endpoint config failed(int), Error Code = %"
 10062      53657420 
 10062      456E6470 
 10062      6F696E74 
 10062      20636F6E 
 10063 097b 640A00   		.ascii	"d\012\000"
 10064 097e 0000     		.space	2
 10065              	.LC54:
 10066 0980 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 10066      496E7465 
 10066      72727570 
 10066      74205374 
 10066      61747573 
 10067 09b3 20436F64 		.ascii	" Code = %d\012\000"
 10067      65203D20 
 10067      25640A00 
 10068 09bf 00       		.space	1
 10069              	.LC55:
 10070 09c0 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 10070      65642074 
 10070      6F20616C 
 10070      6C6F6361 
 10070      7465206D 
 10071 09f3 65720D0A 		.ascii	"er\015\012\000"
 10071      00
 10072              	.LC56:
 10073 09f8 444D4120 		.ascii	"DMA Channel Creation. xfersize %d, size %d, count %"
 10073      4368616E 
 10073      6E656C20 
 10073      43726561 
 10073      74696F6E 
 10074 0a2b 642C2061 		.ascii	"d, activeProInd %d, activeConInd %d\012\000"
 10074      63746976 
 10074      6550726F 
 10074      496E6420 
 10074      25642C20 
 10075              	.LC57:
 10076 0a50 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 10076      4368616E 
 10076      6E656C20 
 10076      43726561 
 10076      74696F6E 
 10077 0a7e 0000     		.space	2
 10078              	.LC58:
 10079 0a80 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 10079      436F6E6E 
 10079      65637420 
 10079      6661696C 
 10079      65642C20 
 10080 0aa5 000000   		.space	3
 10081              	.LC59:
 10082 0aa8 55534220 		.ascii	"USB Set Endpoint config failed(iso), Error Code = %"
 10082      53657420 
 10082      456E6470 
 10082      6F696E74 
 10082      20636F6E 
 10083 0adb 640A00   		.ascii	"d\012\000"
 10084 0ade 0000     		.space	2
 10085              	.LC60:
 10086 0ae0 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 10086      4368616E 
 10086      6E656C20 
 10086      52657365 
 10086      74204661 
 10087 0b0b 00       		.space	1
 10088              	.LC61:
 10089 0b0c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 10089      4368616E 
 10089      6E656C20 
 10089      53657420 
 10089      5472616E 
 10090 0b3d 00       		.ascii	"\000"
 10091 0b3e 0000     		.space	2
 10092              	.LC62:
 10093 0b40 74657374 		.ascii	"test 1 0x%x\015\012\000"
 10093      20312030 
 10093      7825780D 
 10093      0A00
 10094 0b4e 0000     		.space	2
 10095              	.LC63:
 10096 0b50 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 10096      4368616E 
 10096      6E656C20 
 10096      53657420 
 10096      5472616E 
 10097 0b81 0A00     		.ascii	"\012\000"
 10098 0b83 00       		.space	1
 10099              	.LC64:
 10100 0b84 0D0A2073 		.ascii	"\015\012 super gpif\000"
 10100      75706572 
 10100      20677069 
 10100      6600
 10101 0b92 0000     		.space	2
 10102              	.LC65:
 10103 0b94 2564200D 		.ascii	"%d \015\012 high gpif\000"
 10103      0A206869 
 10103      67682067 
 10103      70696600 
 10104              	.LC66:
 10105 0ba4 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 10105      696E6720 
 10105      47504946 
 10105      20436F6E 
 10105      66696775 
 10106 0bd7 0A00     		.ascii	"\012\000"
 10107 0bd9 000000   		.space	3
 10108              	.LC67:
 10109 0bdc 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 10109      74696E67 
 10109      20475049 
 10109      46207374 
 10109      61746520 
 10110 0c0f 0D0A00   		.ascii	"\015\012\000"
 10111 0c12 0000     		.space	2
 10112              	.LC68:
 10113 0c14 33303A55 		.ascii	"30:UVC App Thread\000"
 10113      56432041 
 10113      70702054 
 10113      68726561 
 10113      6400
 10114 0c26 0000     		.space	2
 10115              	.LC69:
 10116 0c28 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 10116      56432041 
 10116      70702045 
 10116      50302054 
 10116      68726561 
 10117 0c3e 0000     		.space	2
 10118              	.LC70:
 10119 0c40 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 10119      32432041 
 10119      70702043 
 10119      54524C20 
 10119      54687265 
 10120 0c57 00       		.bss
 10121              		.align	2
 10122              		.set	.LANCHOR0,. + 0
 10125              	glFxUVCEvent:
 10126 0000 00000000 		.space	40
 10126      00000000 
 10126      00000000 
 10126      00000000 
 10126      00000000 
 10129              	hitFV:
 10130 0028 00000000 		.space	4
 10133              	usbSpeed:
 10134 002c 00       		.space	1
 10135 002d 00       		.space	1
 10138              	fb:
 10139 002e 0000     		.space	2
 10142              	takeFull:
 10143 0030 0000     		.space	2
 10146              	pb:
 10147 0032 0000     		.space	2
 10150              	pbc:
 10151 0034 0000     		.space	2
 10154              	prodCount:
 10155 0036 0000     		.space	2
 10158              	consCount:
 10159 0038 0000     		.space	2
 10160 003a 0000     		.space	2
 10163              	streamingStarted:
 10164 003c 00000000 		.space	4
 10167              	gpif_initialized:
 10168 0040 00000000 		.space	4
 10171              	isUsbConnected:
 10172 0044 00000000 		.space	4
 10175              	clearFeatureRqtReceived:
 10176 0048 00000000 		.space	4
 10179              	I2CCMDArry:
 10180 004c 00000000 		.space	12
 10180      00000000 
 10180      00000000 
 10183              	glEp0Buffer:
 10184 0058 00000000 		.space	32
 10184      00000000 
 10184      00000000 
 10184      00000000 
 10184      00000000 
 10187              	CamMode:
 10188 0078 00       		.space	1
 10189 0079 000000   		.space	3
 10192              	glCommitCtrl:
 10193 007c 00000000 		.space	32
 10193      00000000 
 10193      00000000 
 10193      00000000 
 10193      00000000 
 10196              	stiflag:
 10197 009c 00000000 		.space	4
 10200              	uvcAppThread:
 10201 00a0 00000000 		.space	168
 10201      00000000 
 10201      00000000 
 10201      00000000 
 10201      00000000 
 10204              	uvcAppEP0Thread:
 10205 0148 00000000 		.space	168
 10205      00000000 
 10205      00000000 
 10205      00000000 
 10205      00000000 
 10208              	i2cAppThread:
 10209 01f0 00000000 		.space	168
 10209      00000000 
 10209      00000000 
 10209      00000000 
 10209      00000000 
 10212              	testSnap:
 10213 0298 00       		.space	1
 10214 0299 00       		.space	1
 10217              	fbbak:
 10218 029a 0000     		.space	2
 10221              	pbbak:
 10222 029c 0000     		.space	2
 10225              	pbcbak:
 10226 029e 0000     		.space	2
 10229              	pbcpbak:
 10230 02a0 0000     		.space	2
 10231 02a2 0000     		.text
 10232              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:291    .text:0000021c $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:305    .text:0000023c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:302    .text:0000023c $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:324    .text:0000024c $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:328    .text:00000250 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:331    .text:00000250 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:402    .text:000002bc $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:408    .text:000002cc $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:460    .text:0000032c $d
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:471    .text:00000344 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:474    .text:00000344 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:647    .text:00000480 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:654    .text:00000490 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:656    .text:00000490 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:835    .text:000005f0 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:844    .text:00000600 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:846    .text:00000600 CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:1179   .text:000008f0 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000001 bRequest
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:1196   .text:00000920 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:1199   .text:00000920 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:1353   .text:00000a7c $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:1359   .text:00000a88 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:1362   .text:00000a88 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:1425   .text:00000b08 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:1632   .text:00000ca4 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:1670   .text:00000d30 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:1734   .text:00000db4 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:1770   .text:00000e3c $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:3031   .text:000019ec $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:3049   .text:00001a28 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:3052   .text:00001a28 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:3220   .text:00001b84 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:3233   .text:00001bac $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:3728   .text:000020bc $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:3739   .text:000020dc $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:3994   .text:00002394 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:4007   .text:000023bc $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:4010   .text:000023bc UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:4072   .text:00002438 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:4080   .text:00002448 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:5246   .text:00002e2c $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:5276   .text:00002e90 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:5279   .text:00002e90 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:5570   .text:00003148 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:5577   .text:00003158 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:5580   .text:00003158 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:5616   .text:00003184 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:5620   .text:00003188 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:5623   .text:00003188 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:5647   .text:000031a0 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:5651   .text:000031a4 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:5654   .text:000031a4 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:7071   .text:00003ccc $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:7136   .text:00003dbc $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:7139   .text:00003dbc CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:7296   .text:00003f34 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:7312   .text:00003f68 $a
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:7315   .text:00003f68 main
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:8928   .data:00000660 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:8937   .data:0000066c CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:9012   .data:0000078c CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:9031   .data:0000079c CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:7482   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:9110   .data:000008cc CyFxGpifTransition_usb2_480
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:9123   .data:000008e0 CyFxGpifWavedata_usb2_480
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:9264   .data:00000b08 CyFxGpifWavedataPosition_usb2_480
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:9423   .data:00000ba4 CyFxGpifRegValue_usb2_480
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:7495   .rodata:0000002c CyFxGpifConfig_usb2_480
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:9502   .data:00000cd4 CyFxGpifTransition_usb2_640
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:9515   .data:00000ce8 CyFxGpifWavedata_usb2_640
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:9656   .data:00000f10 CyFxGpifWavedataPosition_usb2_640
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:9815   .data:00000fac CyFxGpifRegValue_usb2_640
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:7508   .rodata:00000048 CyFxGpifConfig_usb2_640
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:8924   .data:0000065f snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10212  .bss:00000298 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10138  .bss:0000002e fb
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10146  .bss:00000032 pb
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10150  .bss:00000034 pbc
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10142  .bss:00000030 takeFull
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10217  .bss:0000029a fbbak
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10221  .bss:0000029c pbbak
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10225  .bss:0000029e pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10229  .bss:000002a0 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10171  .bss:00000044 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10133  .bss:0000002c usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10175  .bss:00000048 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10163  .bss:0000003c streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:8835   .data:00000610 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:8895   .data:00000648 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:8865   .data:0000062c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:8910   .data:00000654 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:8490   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:7459   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:7463   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:7520   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:7524   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:7847   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:8505   .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:8512   .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:9893   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10121  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10125  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10129  .bss:00000028 hitFV
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10154  .bss:00000036 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10158  .bss:00000038 consCount
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10167  .bss:00000040 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10179  .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10183  .bss:00000058 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10187  .bss:00000078 CamMode
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10192  .bss:0000007c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10196  .bss:0000009c stiflag
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10200  .bss:000000a0 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10204  .bss:00000148 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccGL4QC5.s:10208  .bss:000001f0 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PDmaMultiChannelSetWrapUp
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbAckSetup
CyU3PUsbStall
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
SensorWrite2B
SensorRead2B
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
